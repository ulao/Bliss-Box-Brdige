
bridge.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000b8  00800100  00005590  00005624  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005590  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001e8  008001b8  008001b8  000056dc  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000056dc  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000690  00000000  00000000  0000570c  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000bc53  00000000  00000000  00005d9c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000031eb  00000000  00000000  000119ef  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00008bce  00000000  00000000  00014bda  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000dbc  00000000  00000000  0001d7a8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00013b66  00000000  00000000  0001e564  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000067a9  00000000  00000000  000320ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000750  00000000  00000000  00038873  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_macro  00006518  00000000  00000000  00038fc3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
       0:	7a c5       	rjmp	.+2804   	; 0xaf6 <__ctors_end>
       2:	00 00       	nop
       4:	94 c5       	rjmp	.+2856   	; 0xb2e <__bad_interrupt>
       6:	00 00       	nop
       8:	92 c5       	rjmp	.+2852   	; 0xb2e <__bad_interrupt>
       a:	00 00       	nop
       c:	90 c5       	rjmp	.+2848   	; 0xb2e <__bad_interrupt>
       e:	00 00       	nop
      10:	8e c5       	rjmp	.+2844   	; 0xb2e <__bad_interrupt>
      12:	00 00       	nop
      14:	8c c5       	rjmp	.+2840   	; 0xb2e <__bad_interrupt>
      16:	00 00       	nop
      18:	8a c5       	rjmp	.+2836   	; 0xb2e <__bad_interrupt>
      1a:	00 00       	nop
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
      1c:	88 c5       	rjmp	.+2832   	; 0xb2e <__bad_interrupt>
      1e:	00 00       	nop
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
      20:	86 c5       	rjmp	.+2828   	; 0xb2e <__bad_interrupt>
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
      22:	00 00       	nop
      24:	84 c5       	rjmp	.+2824   	; 0xb2e <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 e5 29 	jmp	0x53ca	; 0x53ca <__vector_10>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
      2c:	80 c5       	rjmp	.+2816   	; 0xb2e <__bad_interrupt>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
      2e:	00 00       	nop
      30:	7e c5       	rjmp	.+2812   	; 0xb2e <__bad_interrupt>

	if (Endpoint_IsSETUPReceived())
      32:	00 00       	nop
      34:	7c c5       	rjmp	.+2808   	; 0xb2e <__bad_interrupt>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
      36:	00 00       	nop
      38:	7a c5       	rjmp	.+2804   	; 0xb2e <__bad_interrupt>

		switch (USB_ControlRequest.bRequest)
      3a:	00 00       	nop
      3c:	78 c5       	rjmp	.+2800   	; 0xb2e <__bad_interrupt>
      3e:	00 00       	nop
      40:	76 c5       	rjmp	.+2796   	; 0xb2e <__bad_interrupt>
      42:	00 00       	nop
      44:	75 c5       	rjmp	.+2794   	; 0xb30 <__vector_17>
      46:	00 00       	nop
      48:	72 c5       	rjmp	.+2788   	; 0xb2e <__bad_interrupt>
      4a:	00 00       	nop
      4c:	70 c5       	rjmp	.+2784   	; 0xb2e <__bad_interrupt>
      4e:	00 00       	nop
      50:	6e c5       	rjmp	.+2780   	; 0xb2e <__bad_interrupt>
      52:	00 00       	nop
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
      54:	6c c5       	rjmp	.+2776   	; 0xb2e <__bad_interrupt>
      56:	00 00       	nop
      58:	6a c5       	rjmp	.+2772   	; 0xb2e <__bad_interrupt>
      5a:	00 00       	nop
      5c:	68 c5       	rjmp	.+2768   	; 0xb2e <__bad_interrupt>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
      5e:	00 00       	nop
      60:	66 c5       	rjmp	.+2764   	; 0xb2e <__bad_interrupt>
      62:	00 00       	nop
      64:	64 c5       	rjmp	.+2760   	; 0xb2e <__bad_interrupt>
      66:	00 00       	nop
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
      68:	62 c5       	rjmp	.+2756   	; 0xb2e <__bad_interrupt>
      6a:	00 00       	nop
      6c:	60 c5       	rjmp	.+2752   	; 0xb2e <__bad_interrupt>
      6e:	00 00       	nop
      70:	5e c5       	rjmp	.+2748   	; 0xb2e <__bad_interrupt>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
      72:	00 00       	nop
      74:	5c c5       	rjmp	.+2744   	; 0xb2e <__bad_interrupt>
      76:	00 00       	nop
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
      78:	5a c5       	rjmp	.+2740   	; 0xb2e <__bad_interrupt>
      7a:	00 00       	nop
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
      7c:	58 c5       	rjmp	.+2736   	; 0xb2e <__bad_interrupt>
      7e:	00 00       	nop
      80:	56 c5       	rjmp	.+2732   	; 0xb2e <__bad_interrupt>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
      82:	00 00       	nop
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
      84:	54 c5       	rjmp	.+2728   	; 0xb2e <__bad_interrupt>
      86:	00 00       	nop
      88:	52 c5       	rjmp	.+2724   	; 0xb2e <__bad_interrupt>
      8a:	00 00       	nop
      8c:	50 c5       	rjmp	.+2720   	; 0xb2e <__bad_interrupt>
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
      8e:	00 00       	nop
      90:	0c 94 1e 13 	jmp	0x263c	; 0x263c <__vector_36>
				UEDATX = (Data >> 8);
      94:	4c c5       	rjmp	.+2712   	; 0xb2e <__bad_interrupt>
      96:	00 00       	nop
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
      98:	4a c5       	rjmp	.+2708   	; 0xb2e <__bad_interrupt>
      9a:	00 00       	nop
      9c:	48 c5       	rjmp	.+2704   	; 0xb2e <__bad_interrupt>
      9e:	00 00       	nop
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
      a0:	46 c5       	rjmp	.+2700   	; 0xb2e <__bad_interrupt>
      a2:	00 00       	nop
      a4:	44 c5       	rjmp	.+2696   	; 0xb2e <__bad_interrupt>
      a6:	00 00       	nop
      a8:	42 c5       	rjmp	.+2692   	; 0xb2e <__bad_interrupt>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
      aa:	00 00       	nop
      ac:	02 0d       	add	r16, r2
      ae:	0a 0d       	add	r16, r10
      b0:	80 0c       	add	r8, r0
      b2:	d2 0c       	add	r13, r2
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
      b4:	24 0d       	add	r18, r4
      b6:	35 0d       	add	r19, r5
      b8:	53 0d       	add	r21, r3
      ba:	70 0d       	add	r23, r0
      bc:	6d 0e       	add	r6, r29
      be:	6d 0e       	add	r6, r29

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
      c0:	6d 0e       	add	r6, r29
      c2:	6d 0e       	add	r6, r29
      c4:	7e 0d       	add	r23, r14
      c6:	96 0d       	add	r25, r6
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
      c8:	6d 0e       	add	r6, r29
      ca:	a7 0d       	add	r26, r7

000000cc <__trampolines_end>:
      cc:	70 51       	subi	r23, 0x10	; 16

				if (EndpointIndex == ENDPOINT_CONTROLEP)
      ce:	03 86       	std	Z+11, r0	; 0x0b
      d0:	40 0d       	add	r20, r0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
      d2:	4f eb       	ldi	r20, 0xBF	; 191
      d4:	3e cc       	rjmp	.-1924   	; 0xfffff952 <__eeprom_end+0xff7ef952>
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
      d6:	d1 87       	std	Z+9, r29	; 0x09
      d8:	35 bd       	out	0x25, r19	; 37
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
      da:	f5 0b       	sbc	r31, r21
      dc:	5e d0       	rcall	.+188    	; 0x19a <__trampolines_end+0xce>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
      de:	f8 f2       	brcs	.-66     	; 0x9e <__SREG__+0x5f>
      e0:	d5 e2       	ldi	r29, 0x25	; 37
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
      e2:	6c 31       	cpi	r22, 0x1C	; 28
      e4:	0c ad       	ldd	r16, Y+60	; 0x3c
      e6:	fc 21       	and	r31, r12
      e8:	c3 78       	andi	r28, 0x83	; 131
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
      ea:	c1 06       	cpc	r12, r17
      ec:	c2 4c       	sbci	r28, 0xC2	; 194
      ee:	55 e6       	ldi	r21, 0x65	; 101
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
      f0:	4a 34       	cpi	r20, 0x4A	; 74
      f2:	48 11       	cpse	r20, r8
      f4:	1e da       	rcall	.-3012   	; 0xfffff532 <__eeprom_end+0xff7ef532>
      f6:	e7 1a       	sub	r14, r23
      f8:	84 a0       	ldd	r8, Z+36	; 0x24
      fa:	96 a7       	std	Z+46, r25	; 0x2e
      fc:	e3 7f       	andi	r30, 0xF3	; 243
      fe:	af 63       	ori	r26, 0x3F	; 63
     100:	9c fa       	.word	0xfa9c	; ????
				UERST = 0;
     102:	23 5b       	subi	r18, 0xB3	; 179
     104:	79 c8       	rjmp	.-3854   	; 0xfffff1f8 <__eeprom_end+0xff7ef1f8>

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
     106:	9e ba       	out	0x1e, r9	; 30
     108:	b2 c9       	rjmp	.-3228   	; 0xfffff46e <__eeprom_end+0xff7ef46e>
     10a:	22 12       	cpse	r2, r18
     10c:	4b b3       	in	r20, 0x1b	; 27
     10e:	a1 b6       	in	r10, 0x31	; 49
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
     110:	32 49       	sbci	r19, 0x92	; 146
     112:	a2 e1       	ldi	r26, 0x12	; 18
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     114:	89 39       	cpi	r24, 0x99	; 153
     116:	10 66       	ori	r17, 0x60	; 96
     118:	c5 07       	cpc	r28, r21
     11a:	8f 54       	subi	r24, 0x4F	; 79
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
     11c:	ea 91       	ld	r30, -Y
     11e:	ca 3f       	cpi	r28, 0xFA	; 250
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t    DeviceAddress    = (USB_ControlRequest.wValue & 0x7F);
     120:	f9 19       	sub	r31, r9
     122:	f0 d7       	rcall	.+4064   	; 0x1104 <con_autoMapper+0x36>
     124:	46 bc       	out	0x26, r4	; 38
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
     126:	28 1b       	sub	r18, r24
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
     128:	61 e8       	ldi	r22, 0x81	; 129
     12a:	2f 6a       	ori	r18, 0xAF	; 175
     12c:	ae 9d       	mul	r26, r14
     12e:	f6 4e       	sbci	r31, 0xE6	; 230
     130:	09 14       	cp	r0, r9
     132:	77 4d       	sbci	r23, 0xD7	; 215
	uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
	GlobalInterruptDisable();

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
     134:	db 1f       	adc	r29, r27
     136:	2e 7b       	andi	r18, 0xBE	; 190
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
     138:	7c f1       	brlt	.+94     	; 0x198 <__trampolines_end+0xcc>
     13a:	43 a3       	std	Z+35, r20	; 0x23

	while (!(Endpoint_IsINReady()));
     13c:	00 b8       	out	0x00, r0	; 0
     13e:	13 8c       	ldd	r1, Z+27	; 0x1b
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				uint8_t Temp = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
     140:	85 b9       	out	0x05, r24	; 5
     142:	29 75       	andi	r18, 0x59	; 89
     144:	88 fd       	.word	0xfd88	; ????
     146:	d2 56       	subi	r29, 0x62	; 98

				UDADDR = Temp;
     148:	1c 50       	subi	r17, 0x0C	; 12
     14a:	97 41       	sbci	r25, 0x17	; 23
				UDADDR = Temp | (1 << ADDEN);
     14c:	e5 3b       	cpi	r30, 0xB5	; 181
     14e:	60 b5       	in	r22, 0x20	; 32
     150:	c0 64       	ori	r28, 0x40	; 64

	USB_Device_SetDeviceAddress(DeviceAddress);
	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
     152:	ee 98       	cbi	0x1d, 6	; 29
     154:	d6 2d       	mov	r29, r6
     156:	25 a4       	ldd	r2, Z+45	; 0x2d
     158:	aa cd       	rjmp	.-1196   	; 0xfffffcae <__eeprom_end+0xff7efcae>
     15a:	7d a8       	ldd	r7, Y+53	; 0x35
     15c:	83 c6       	rjmp	.+3334   	; 0xe64 <do_LLAPI+0x1ec>
     15e:	ab be       	out	0x3b, r10	; 59
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
     160:	44 99       	sbic	0x08, 4	; 8
				  __builtin_csrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				SREG = GlobalIntState;
				#endif

				GCC_MEMORY_BARRIER();
     162:	26 3c       	cpi	r18, 0xC6	; 198
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
     164:	ce 9f       	mul	r28, r30
     166:	bf d3       	rcall	.+1918   	; 0x8e6 <__trampolines_end+0x81a>
     168:	cb 76       	andi	r28, 0x6B	; 107
     16a:	7a 7e       	andi	r23, 0xEA	; 234
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
     16c:	82 01       	movw	r16, r4
     16e:	8a 9a       	sbi	0x11, 2	; 17
     170:	80 1d       	adc	r24, r0
     172:	0e b0       	in	r0, 0x0e	; 14
     174:	5c d4       	rcall	.+2232   	; 0xa2e <__trampolines_end+0x962>
     176:	38 62       	ori	r19, 0x28	; 40
     178:	f4 30       	cpi	r31, 0x04	; 4
     17a:	e0 8e       	std	Z+24, r14	; 0x18
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
     17c:	53 b7       	in	r21, 0x33	; 51
     17e:	02 57       	subi	r16, 0x72	; 114
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
     180:	ac a6       	std	Y+44, r10	; 0x2c
     182:	52 0a       	sbc	r5, r18
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
     184:	6d 92       	st	X+, r6
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
     186:	65 17       	cp	r22, r21
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
     188:	24 33       	cpi	r18, 0x34	; 52
     18a:	45 72       	andi	r20, 0x25	; 37
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
     18c:	74 b1       	in	r23, 0x04	; 4
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
     18e:	b4 f7       	brge	.-20     	; 0x17c <__trampolines_end+0xb0>

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
     190:	5d ed       	ldi	r21, 0xDD	; 221
     192:	2c ff       	.word	0xff2c	; ????
     194:	47 37       	cpi	r20, 0x77	; 119
     196:	5a 90       	ld	r5, -Y
     198:	bb df       	rcall	.-138    	; 0x110 <__trampolines_end+0x44>
     19a:	2a 16       	cp	r2, r26

					if (SerialCharNum & 0x01)
     19c:	59 95       	.word	0x9559	; ????
     19e:	d9 c4       	rjmp	.+2482   	; 0xb52 <__vector_17+0x22>
					{
						SerialByte >>= 4;
     1a0:	27 67       	ori	r18, 0x77	; 119
     1a2:	73 c7       	rjmp	.+3814   	; 0x108a <main+0xbc>
						SigReadAddress++;
     1a4:	68 fe       	.word	0xfe68	; ????
					}

					SerialByte &= 0x0F;
     1a6:	a5 dd       	rcall	.-1206   	; 0xfffffcf2 <__eeprom_end+0xff7efcf2>
     1a8:	6b 5f       	subi	r22, 0xFB	; 251
     1aa:	93 d8       	rcall	.-3802   	; 0xfffff2d2 <__eeprom_end+0xff7ef2d2>

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
     1ac:	ec 05       	cpc	r30, r12
     1ae:	3a 8d       	ldd	r19, Y+26	; 0x1a
     1b0:	6e fb       	.word	0xfb6e	; ????
     1b2:	3d a9       	ldd	r19, Y+53	; 0x35
     1b4:	69 36       	cpi	r22, 0x69	; 105
     1b6:	f3 94       	inc	r15
     1b8:	de ef       	ldi	r29, 0xFE	; 254
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
     1ba:	15 6f       	ori	r17, 0xF5	; 245
     1bc:	8b 9b       	sbis	0x11, 3	; 17
     1be:	08 0f       	add	r16, r24
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
     1c0:	dc 81       	ldd	r29, Y+4	; 0x04
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     1c2:	18 20       	and	r1, r8
     1c4:	04 e4       	ldi	r16, 0x44	; 68
     1c6:	71 cf       	rjmp	.-286    	; 0xaa <__SREG__+0x6b>
     1c8:	e9 2b       	or	r30, r25
     1ca:	42 58       	subi	r20, 0x82	; 130

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
     1cc:	01 a0       	ldd	r0, Z+33	; 0x21
     1ce:	a9 62       	ori	r26, 0x29	; 41
     1d0:	d6 3f       	cpi	r29, 0xF6	; 246
     1d2:	85 a7       	std	Z+45, r24	; 0x2d
     1d4:	b6 d4       	rcall	.+2412   	; 0xb42 <__vector_17+0x12>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
     1d6:	fa 15       	cp	r31, r10
     1d8:	66 17       	cp	r22, r22
     1da:	09 bd       	out	0x29, r16	; 41
     1dc:	5d 14       	cp	r5, r13
     1de:	34 26       	eor	r3, r20
     1e0:	59 72       	andi	r21, 0x29	; 41
     1e2:	91 54       	subi	r25, 0x41	; 65
     1e4:	06 4f       	sbci	r16, 0xF6	; 246
     1e6:	f8 b0       	in	r15, 0x08	; 8
     1e8:	5b 74       	andi	r21, 0x4B	; 75
     1ea:	93 99       	sbic	0x12, 3	; 18
     1ec:	8c f2       	brlt	.-94     	; 0x190 <__trampolines_end+0xc4>
     1ee:	45 cd       	rjmp	.-1398   	; 0xfffffc7a <__eeprom_end+0xff7efc7a>
     1f0:	ea 4e       	sbci	r30, 0xEA	; 234
     1f2:	ad 10       	cpse	r10, r13
     1f4:	4a e5       	ldi	r20, 0x5A	; 90
     1f6:	ca ee       	ldi	r28, 0xEA	; 234
     1f8:	df c6       	rjmp	.+3518   	; 0xfb8 <main_update+0x130>
     1fa:	6f 9f       	mul	r22, r31
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
	#else
	if (DescriptorAddressSpace == MEMSPACE_FLASH)
     1fc:	88 8e       	std	Y+24, r8	; 0x18
     1fe:	02 cc       	rjmp	.-2044   	; 0xfffffa04 <__eeprom_end+0xff7efa04>
     200:	08 a8       	ldd	r0, Y+48	; 0x30
     202:	77 94       	ror	r7
     204:	6d 21       	and	r22, r13
	  Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
     206:	b1 28       	or	r11, r1
     208:	e4 39       	cpi	r30, 0x94	; 148
     20a:	79 96       	adiw	r30, 0x19	; 25
	else if (DescriptorAddressSpace == MEMSPACE_EEPROM)
     20c:	60 71       	andi	r22, 0x10	; 16
     20e:	81 16       	cp	r8, r17
	  Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
     210:	2e e6       	ldi	r18, 0x6E	; 110
     212:	78 b9       	out	0x08, r23	; 8
     214:	c4 46       	sbci	r28, 0x64	; 100
	else
	  Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
     216:	9a 42       	sbci	r25, 0x2A	; 42
     218:	ae b7       	in	r26, 0x3e	; 62
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     21a:	7c 43       	sbci	r23, 0x3C	; 60
     21c:	b3 22       	and	r11, r19
     21e:	1a 86       	std	Y+10, r1	; 0x0a
     220:	c2 32       	cpi	r28, 0x22	; 34
     222:	3d 2d       	mov	r19, r13
     224:	9c d2       	rcall	.+1336   	; 0x75e <__trampolines_end+0x692>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
     226:	29 e9       	ldi	r18, 0x99	; 153
     228:	63 9b       	sbis	0x0c, 3	; 12
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     22a:	d1 31       	cpi	r29, 0x11	; 17
     22c:	38 5e       	subi	r19, 0xE8	; 232
     22e:	1e 36       	cpi	r17, 0x6E	; 110
     230:	41 bb       	out	0x11, r20	; 17
     232:	03 18       	sub	r0, r3

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
     234:	2b 3e       	cpi	r18, 0xEB	; 235
     236:	bf 68       	ori	r27, 0x8F	; 143
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     238:	61 fc       	sbrc	r6, 1
     23a:	52 c0       	rjmp	.+164    	; 0x2e0 <__trampolines_end+0x214>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     23c:	de e0       	ldi	r29, 0x0E	; 14
     23e:	0a 58       	subi	r16, 0x8A	; 138
     240:	13 5a       	subi	r17, 0xA3	; 163
     242:	00 be       	out	0x30, r0	; 48
     244:	1c 90       	ld	r1, X
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
     246:	0e 53       	subi	r16, 0x3E	; 62
     248:	12 fd       	sbrc	r17, 2
     24a:	e2 6e       	ori	r30, 0xE2	; 226
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
     24c:	ba ce       	rjmp	.-652    	; 0xffffffc2 <__eeprom_end+0xff7effc2>
     24e:	24 27       	eor	r18, r20
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
     250:	44 7f       	andi	r20, 0xF4	; 244
     252:	87 a3       	std	Z+39, r24	; 0x27
     254:	a1 d5       	rcall	.+2882   	; 0xd98 <do_LLAPI+0x120>
     256:	50 40       	sbci	r21, 0x00	; 0
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     258:	e3 f9       	bld	r30, 3
     25a:	83 f7       	brvc	.-32     	; 0x23c <__trampolines_end+0x170>
     25c:	c7 a2       	std	Z+39, r12	; 0x27
     25e:	35 c8       	rjmp	.-3990   	; 0xfffff2ca <__eeprom_end+0xff7ef2ca>
     260:	db 19       	sub	r29, r11
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
     262:	ab 2f       	mov	r26, r27
     264:	11 25       	eor	r17, r1

	Endpoint_ClearStatusStage();
     266:	ed 33       	cpi	r30, 0x3D	; 61
     268:	9e 55       	subi	r25, 0x5E	; 94

	if (USB_Device_ConfigurationNumber)
     26a:	e1 48       	sbci	r30, 0x81	; 129
     26c:	af 73       	andi	r26, 0x3F	; 63
     26e:	84 da       	rcall	.-2808   	; 0xfffff778 <__eeprom_end+0xff7ef778>
     270:	2a aa       	std	Y+50, r2	; 0x32
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
     272:	51 eb       	ldi	r21, 0xB1	; 177
     274:	9d 95 b2 cb 	jmp	0x679764	; 0x679764 <__data_load_end+0x67411c>
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
     278:	e7 70       	andi	r30, 0x07	; 7
     27a:	80 fe       	sbrs	r8, 0
     27c:	4c 65       	ori	r20, 0x5C	; 92
     27e:	04 ef       	ldi	r16, 0xF4	; 244
     280:	c5 f1       	brhs	.+112    	; 0x2f2 <__trampolines_end+0x226>
     282:	c3 3a       	cpi	r28, 0xA3	; 163

	EVENT_USB_Device_ConfigurationChanged();
     284:	b4 f5       	brge	.+108    	; 0x2f2 <__trampolines_end+0x226>
     286:	5f 23       	and	r21, r31
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
     288:	89 dd       	rcall	.-1262   	; 0xfffffd9c <__eeprom_end+0xff7efd9c>
     28a:	30 a5       	ldd	r19, Z+40	; 0x28

				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
     28c:	8b d3       	rcall	.+1814   	; 0x9a4 <__trampolines_end+0x8d8>
     28e:	f6 dc       	rcall	.-1556   	; 0xfffffc7c <__eeprom_end+0xff7efc7c>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
     290:	4d 64       	ori	r20, 0x4D	; 77
     292:	d7 f0       	brie	.+52     	; 0x2c8 <__trampolines_end+0x1fc>
     294:	8f ec       	ldi	r24, 0xCF	; 207
     296:	56 37       	cpi	r21, 0x76	; 118
     298:	5c a4       	ldd	r5, Y+44	; 0x2c
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
     29a:	0d 07       	cpc	r16, r29
     29c:	76 8a       	std	Z+22, r7	; 0x16
     29e:	2c 0b       	sbc	r18, r28
     2a0:	b5 d8       	rcall	.-3734   	; 0xfffff40c <__eeprom_end+0xff7ef40c>
     2a2:	c1 1f       	adc	r28, r17
	{
		Endpoint_StallTransaction();
		Endpoint_ClearSETUP();
	}
}
     2a4:	e8 3b       	cpi	r30, 0xB8	; 184
     2a6:	f4 4b       	sbci	r31, 0xB4	; 180
     2a8:	1b 47       	sbci	r17, 0x7B	; 123
     2aa:	6c 49       	sbci	r22, 0x9C	; 156
     2ac:	67 7b       	andi	r22, 0xB7	; 183
     2ae:	92 cf       	rjmp	.-220    	; 0x1d4 <__trampolines_end+0x108>
     2b0:	75 7e       	andi	r23, 0xE5	; 229
     2b2:	20 d9       	rcall	.-3520   	; 0xfffff4f4 <__eeprom_end+0xff7ef4f4>
     2b4:	7d 3c       	cpi	r23, 0xCD	; 205
     2b6:	97 7a       	andi	r25, 0xA7	; 167
     2b8:	d0 05       	cpc	r29, r0
     2ba:	6b 0f       	add	r22, r27
     2bc:	1d fb       	.word	0xfb1d	; ????
     2be:	82 98       	cbi	0x10, 2	; 16
     2c0:	57 8d       	ldd	r21, Z+31	; 0x1f
     2c2:	f3 6a       	ori	r31, 0xA3	; 163
     2c4:	bc ac       	ldd	r11, Y+60	; 0x3c
     2c6:	c9 a6       	std	Y+41, r12	; 0x29
     2c8:	ff b8       	out	0x0f, r15	; 15
     2ca:	69 0c       	add	r6, r9
     2cc:	4c 4d       	sbci	r20, 0xDC	; 220
     2ce:	72 07       	cpc	r23, r18
     2d0:	5a 49       	sbci	r21, 0x9A	; 154
     2d2:	33 8d       	ldd	r19, Z+27	; 0x1b
     2d4:	a2 ab       	std	Z+50, r26	; 0x32
     2d6:	46 3d       	cpi	r20, 0xD6	; 214
     2d8:	63 0d       	add	r22, r3
     2da:	a0 97       	sbiw	r28, 0x20	; 32
     2dc:	ff f0       	brie	.+62     	; 0x31c <__trampolines_end+0x250>
     2de:	f5 fa       	bst	r15, 5
     2e0:	c0 e9       	ldi	r28, 0x90	; 144
     2e2:	db 62       	ori	r29, 0x2B	; 43
     2e4:	e4 e1       	ldi	r30, 0x14	; 20
     2e6:	74 43       	sbci	r23, 0x34	; 52
     2e8:	dc 86       	std	Y+12, r13	; 0x0c
     2ea:	18 29       	or	r17, r8
     2ec:	37 f4       	brid	.+12     	; 0x2fa <__trampolines_end+0x22e>
     2ee:	06 e2       	ldi	r16, 0x26	; 38
     2f0:	ed 6f       	ori	r30, 0xFD	; 253
     2f2:	90 48       	sbci	r25, 0x80	; 128
     2f4:	1e 2d       	mov	r17, r14
     2f6:	1d ea       	ldi	r17, 0xAD	; 173
     2f8:	73 94       	inc	r7
     2fa:	54 df       	rcall	.-344    	; 0x1a4 <__trampolines_end+0xd8>
     2fc:	25 f6       	brhc	.-120    	; 0x286 <__trampolines_end+0x1ba>
     2fe:	47 27       	eor	r20, r23
     300:	d9 11       	cpse	r29, r9
     302:	77 c9       	rjmp	.-3346   	; 0xfffff5f2 <__eeprom_end+0xff7ef5f2>
     304:	84 1c       	adc	r8, r4
     306:	5b 5c       	subi	r21, 0xCB	; 203
     308:	51 81       	ldd	r21, Z+1	; 0x01
     30a:	a6 22       	and	r10, r22
     30c:	3e 24       	eor	r3, r14
     30e:	96 c8       	rjmp	.-3796   	; 0xfffff43c <__eeprom_end+0xff7ef43c>
     310:	8a ec       	ldi	r24, 0xCA	; 202
     312:	82 7c       	andi	r24, 0xC2	; 194
     314:	09 b8       	out	0x09, r0	; 9
     316:	45 4a       	sbci	r20, 0xA5	; 165
     318:	57 bb       	out	0x17, r21	; 23
     31a:	2f 50       	subi	r18, 0x0F	; 15
     31c:	75 8e       	std	Z+29, r7	; 0x1d
     31e:	61 70       	andi	r22, 0x01	; 1
     320:	8c 6c       	ori	r24, 0xCC	; 204
     322:	af d0       	rcall	.+350    	; 0x482 <__trampolines_end+0x3b6>
     324:	fd b4       	in	r15, 0x2d	; 45
     326:	1b ae       	std	Y+59, r1	; 0x3b
     328:	de fe       	.word	0xfede	; ????
     32a:	3b b5       	in	r19, 0x2b	; 43
     32c:	36 bd       	out	0x26, r19	; 38
     32e:	55 01       	movw	r10, r10
     330:	0e 9c       	mul	r0, r14
     332:	41 56       	subi	r20, 0x61	; 97
     334:	5f b3       	in	r21, 0x1f	; 31
     336:	26 03       	mulsu	r18, r22
     338:	83 ba       	out	0x13, r8	; 19
     33a:	13 4b       	sbci	r17, 0xB3	; 179
     33c:	ca c5       	rjmp	.+2964   	; 0xed2 <main_update+0x4a>
     33e:	0a f8       	.word	0xf80a	; ????
     340:	60 a5       	ldd	r22, Z+40	; 0x28
     342:	b9 c7       	rjmp	.+3954   	; 0x12b6 <con_anagloToDigital+0x1e>
     344:	c3 98       	cbi	0x18, 3	; 24
     346:	32 fb       	bst	r19, 2
     348:	12 f9       	bld	r17, 2
     34a:	a7 92       	lat	Z, r10
     34c:	aa 68       	ori	r26, 0x8A	; 138
     34e:	f3 78       	andi	r31, 0x83	; 131
     350:	7e 05       	cpc	r23, r14
     352:	20 21       	and	r18, r0
     354:	02 e8       	ldi	r16, 0x82	; 130
     356:	bf f2       	brie	.-82     	; 0x306 <__trampolines_end+0x23a>
     358:	b0 59       	subi	r27, 0x90	; 144
     35a:	8f d2       	rcall	.+1310   	; 0x87a <__trampolines_end+0x7ae>
     35c:	cb 87       	std	Y+11, r28	; 0x0b
     35e:	65 15       	cp	r22, r5
     360:	f1 1a       	sub	r15, r17
     362:	b2 30       	cpi	r27, 0x02	; 2
     364:	ad ee       	ldi	r26, 0xED	; 237
     366:	58 a3       	std	Y+32, r21	; 0x20
     368:	8b 66       	ori	r24, 0x6B	; 107
     36a:	1f 2c       	mov	r1, r15
     36c:	d7 5d       	subi	r29, 0xD7	; 215
     36e:	19 85       	ldd	r17, Y+9	; 0x09
     370:	a8 e6       	ldi	r26, 0x68	; 104
     372:	d3 6b       	ori	r29, 0xB3	; 179
     374:	a1 0c       	add	r10, r1
     376:	91 93       	st	Z+, r25
     378:	6a 5e       	subi	r22, 0xEA	; 234
     37a:	0b 79       	andi	r16, 0x9B	; 155
     37c:	e3 dd       	rcall	.-1082   	; 0xffffff44 <__eeprom_end+0xff7eff44>
     37e:	00 4f       	sbci	r16, 0xF0	; 240
     380:	3c 89       	ldd	r19, Y+20	; 0x14
     382:	6e 71       	andi	r22, 0x1E	; 30
     384:	69 a9       	ldd	r22, Y+49	; 0x31
     386:	ac 40       	sbci	r26, 0x0C	; 12
     388:	e5 99       	sbic	0x1c, 5	; 28
     38a:	28 c6       	rjmp	.+3152   	; 0xfdc <main+0xe>
     38c:	31 4e       	sbci	r19, 0xE1	; 225
     38e:	7a cd       	rjmp	.-1292   	; 0xfffffe84 <__eeprom_end+0xff7efe84>
     390:	08 9e       	mul	r0, r24
     392:	7d ef       	ldi	r23, 0xFD	; 253
     394:	17 fc       	sbrc	r1, 7
     396:	88 d8       	rcall	.-3824   	; 0xfffff4a8 <__eeprom_end+0xff7ef4a8>
     398:	a4 6d       	ori	r26, 0xD4	; 212
     39a:	44 95       	.word	0x9544	; ????
     39c:	d1 b7       	in	r29, 0x31	; 49
     39e:	d4 9b       	sbis	0x1a, 4	; 26
     3a0:	be 2a       	or	r11, r30
     3a2:	34 64       	ori	r19, 0x44	; 68
     3a4:	2b cf       	rjmp	.-426    	; 0x1fc <__trampolines_end+0x130>
     3a6:	2e eb       	ldi	r18, 0xBE	; 190
     3a8:	38 ce       	rjmp	.-912    	; 0x1a <__zero_reg__+0x19>
     3aa:	23 e0       	ldi	r18, 0x03	; 3
     3ac:	3a 3f       	cpi	r19, 0xFA	; 250
     3ae:	f7 7b       	andi	r31, 0xB7	; 183
     3b0:	9f 10       	cpse	r9, r15
     3b2:	53 bc       	out	0x23, r5	; 35
     3b4:	52 67       	ori	r21, 0x72	; 114
     3b6:	16 e7       	ldi	r17, 0x76	; 118
     3b8:	80 76       	andi	r24, 0x60	; 96
     3ba:	04 c4       	rjmp	.+2056   	; 0xbc4 <getInfo+0x1e>
     3bc:	b6 c1       	rjmp	.+876    	; 0x72a <__trampolines_end+0x65e>
     3be:	c2 7f       	andi	r28, 0xF2	; 242
     3c0:	9a da       	rcall	.-2764   	; 0xfffff8f6 <__eeprom_end+0xff7ef8f6>
     3c2:	d5 39       	cpi	r29, 0x95	; 149
     3c4:	42 14       	cp	r4, r2
     3c6:	9d b1       	in	r25, 0x0d	; 13
     3c8:	0f 35       	cpi	r16, 0x5F	; 95
     3ca:	d6 cc       	rjmp	.-1620   	; 0xfffffd78 <__eeprom_end+0xff7efd78>
     3cc:	b9 da       	rcall	.-2702   	; 0xfffff940 <__eeprom_end+0xff7ef940>
     3ce:	38 0c       	add	r3, r8
     3d0:	a2 9c       	mul	r10, r2
     3d2:	09 1f       	adc	r16, r25
     3d4:	06 b1       	in	r16, 0x06	; 6
     3d6:	b6 fd       	sbrc	r27, 6
     3d8:	1a 69       	ori	r17, 0x9A	; 154
     3da:	23 30       	cpi	r18, 0x03	; 3
     3dc:	c4 de       	rcall	.-632    	; 0x166 <__trampolines_end+0x9a>
     3de:	01 d1       	rcall	.+514    	; 0x5e2 <__trampolines_end+0x516>
     3e0:	f4 58       	subi	r31, 0x84	; 132
     3e2:	29 37       	cpi	r18, 0x79	; 121
     3e4:	1c 7d       	andi	r17, 0xDC	; 220
     3e6:	d5 bf       	out	0x35, r29	; 53
     3e8:	ff bd       	out	0x2f, r31	; 47
     3ea:	c8 c9       	rjmp	.-3184   	; 0xfffff77c <__eeprom_end+0xff7ef77c>
     3ec:	cf 65       	ori	r28, 0x5F	; 95
     3ee:	be 7b       	andi	r27, 0xBE	; 190
     3f0:	78 97       	sbiw	r30, 0x18	; 24
     3f2:	98 67       	ori	r25, 0x78	; 120
     3f4:	08 b3       	in	r16, 0x18	; 24
     3f6:	26 57       	subi	r18, 0x76	; 118
     3f8:	f7 fa       	bst	r15, 7
     3fa:	40 ad       	ldd	r20, Z+56	; 0x38
     3fc:	8e 75       	andi	r24, 0x5E	; 94
     3fe:	a6 7c       	andi	r26, 0xC6	; 198
     400:	db 91       	.word	0x91db	; ????
     402:	8b 51       	subi	r24, 0x1B	; 27
     404:	99 d4       	rcall	.+2354   	; 0xd38 <do_LLAPI+0xc0>
     406:	17 7a       	andi	r17, 0xA7	; 167
     408:	90 8d       	ldd	r25, Z+24	; 0x18
     40a:	ce 63       	ori	r28, 0x3E	; 62
     40c:	cb 4e       	sbci	r28, 0xEB	; 235
     40e:	a0 ab       	std	Z+48, r26	; 0x30
     410:	18 3a       	cpi	r17, 0xA8	; 168
     412:	5b 50       	subi	r21, 0x0B	; 11
     414:	7f 21       	and	r23, r15
     416:	74 c1       	rjmp	.+744    	; 0x700 <__trampolines_end+0x634>
     418:	bb b8       	out	0x0b, r11	; 11
     41a:	b7 ba       	out	0x17, r11	; 23
     41c:	0b 35       	cpi	r16, 0x5B	; 91
     41e:	95 31       	cpi	r25, 0x15	; 21
     420:	59 9a       	sbi	0x0b, 1	; 11
     422:	4d 04       	cpc	r4, r13
     424:	07 1e       	adc	r0, r23
     426:	5a 76       	andi	r21, 0x6A	; 106
     428:	13 f3       	brvs	.-60     	; 0x3ee <__trampolines_end+0x322>
     42a:	71 83       	std	Z+1, r23	; 0x01
     42c:	d0 86       	std	Z+8, r13	; 0x08
     42e:	03 a8       	ldd	r0, Z+51	; 0x33
     430:	39 42       	sbci	r19, 0x29	; 41
     432:	aa 28       	or	r10, r10
     434:	e6 e4       	ldi	r30, 0x46	; 70
     436:	d8 5d       	subi	r29, 0xD8	; 216
     438:	d3 d0       	rcall	.+422    	; 0x5e0 <__trampolines_end+0x514>
     43a:	6e 6f       	ori	r22, 0xFE	; 254
     43c:	96 fb       	bst	r25, 6
     43e:	5e bc       	out	0x2e, r5	; 46
     440:	56 c2       	rjmp	.+1196   	; 0x8ee <__trampolines_end+0x822>
     442:	5f 85       	ldd	r21, Y+15	; 0x0f
     444:	9b e7       	ldi	r25, 0x7B	; 123
     446:	af d2       	rcall	.+1374   	; 0x9a6 <__trampolines_end+0x8da>
     448:	3b 84       	ldd	r3, Y+11	; 0x0b
     44a:	6a a7       	std	Y+42, r22	; 0x2a
     44c:	53 c5       	rjmp	.+2726   	; 0xef4 <main_update+0x6c>
     44e:	44 49       	sbci	r20, 0x94	; 148
     450:	a5 f9       	bld	r26, 5
     452:	36 72       	andi	r19, 0x26	; 38
     454:	3d 2c       	mov	r3, r13
     456:	d9 1b       	sub	r29, r25
     458:	a1 f5       	brne	.+104    	; 0x4c2 <__trampolines_end+0x3f6>
     45a:	4f 93       	push	r20
     45c:	9d 68       	ori	r25, 0x8D	; 141
     45e:	47 41       	sbci	r20, 0x17	; 23
     460:	16 ca       	rjmp	.-3028   	; 0xfffff88e <__eeprom_end+0xff7ef88e>
     462:	2a 4c       	sbci	r18, 0xCA	; 202
     464:	a3 87       	std	Z+11, r26	; 0x0b
     466:	d6 e5       	ldi	r29, 0x56	; 86
     468:	19 2e       	mov	r1, r25
     46a:	77 15       	cp	r23, r7
     46c:	6d 70       	andi	r22, 0x0D	; 13
     46e:	c0 df       	rcall	.-128    	; 0x3f0 <__trampolines_end+0x324>
     470:	b2 00       	.word	0x00b2	; ????
     472:	46 ed       	ldi	r20, 0xD6	; 214
     474:	c6 6c       	ori	r28, 0xC6	; 198
     476:	43 60       	ori	r20, 0x03	; 3
     478:	92 2d       	mov	r25, r2
     47a:	a9 22       	and	r10, r25
     47c:	45 8f       	std	Z+29, r20	; 0x1d
     47e:	34 55       	subi	r19, 0x54	; 84
     480:	ae a4       	ldd	r10, Y+46	; 0x2e
     482:	0a 66       	ori	r16, 0x6A	; 106
     484:	32 e0       	ldi	r19, 0x02	; 2
     486:	dc 02       	muls	r29, r28
     488:	ac e8       	ldi	r26, 0x8C	; 140
     48a:	20 8c       	ldd	r2, Z+24	; 0x18
     48c:	89 62       	ori	r24, 0x29	; 41
     48e:	4a fe       	.word	0xfe4a	; ????
     490:	ee c3       	rjmp	.+2012   	; 0xc6e <checkControllerType+0x40>
     492:	e3 3c       	cpi	r30, 0xC3	; 195
     494:	f1 79       	andi	r31, 0x91	; 145
     496:	05 e9       	ldi	r16, 0x95	; 149
     498:	f6 27       	eor	r31, r22
     49a:	33 cc       	rjmp	.-1946   	; 0xfffffd02 <__eeprom_end+0xff7efd02>
     49c:	f2 9e       	mul	r15, r18
     49e:	11 81       	ldd	r17, Z+1	; 0x01
     4a0:	7e 80       	ldd	r7, Y+6	; 0x06
     4a2:	10 8a       	std	Z+16, r1	; 0x10
     4a4:	82 9f       	mul	r24, r18
     4a6:	48 0d       	add	r20, r8
     4a8:	d7 b4       	in	r13, 0x27	; 39
     4aa:	fc 2f       	mov	r31, r28
     4ac:	b5 c7       	rjmp	.+3946   	; 0x1418 <con_probe+0x86>
     4ae:	dd 88       	ldd	r13, Y+21	; 0x15
     4b0:	14 6b       	ori	r17, 0xB4	; 180
     4b2:	2b 54       	subi	r18, 0x4B	; 75
     4b4:	ea 1d       	adc	r30, r10
     4b6:	94 5c       	subi	r25, 0xC4	; 196
     4b8:	b0 ef       	ldi	r27, 0xF0	; 240
     4ba:	12 24       	eor	r1, r2
     4bc:	cd eb       	ldi	r28, 0xBD	; 189
     4be:	e1 e2       	ldi	r30, 0x21	; 33
     4c0:	64 73       	andi	r22, 0x34	; 52
     4c2:	3f 0e       	add	r3, r31
     4c4:	52 61       	ori	r21, 0x12	; 18
     4c6:	25 3e       	cpi	r18, 0xE5	; 229
     4c8:	f8 0f       	add	r31, r24
     4ca:	4b ec       	ldi	r20, 0xCB	; 203
     4cc:	c0 00       	.word	0x00c0	; ????
     4ce:	30 f6       	brcc	.-116    	; 0x45c <__trampolines_end+0x390>
     4d0:	02 49       	sbci	r16, 0x92	; 146
     4d2:	3d 10       	cpse	r3, r13
     4d4:	6e 20       	and	r6, r14
     4d6:	c9 a6       	std	Y+41, r12	; 0x29
     4d8:	2f fe       	.word	0xfe2f	; ????
     4da:	2c 2b       	or	r18, r28
     4dc:	75 2e       	mov	r7, r21
     4de:	45 26       	eor	r4, r21
     4e0:	ab 48       	sbci	r26, 0x8B	; 139
     4e2:	a9 80       	ldd	r10, Y+1	; 0x01
     4e4:	fc 04       	cpc	r15, r12
     4e6:	cc d3       	rcall	.+1944   	; 0xc80 <do_LLAPI+0x8>
     4e8:	b5 ba       	out	0x15, r11	; 21
     4ea:	a3 38       	cpi	r26, 0x83	; 131
     4ec:	31 7d       	andi	r19, 0xD1	; 209
     4ee:	01 d9       	rcall	.-3582   	; 0xfffff6f2 <__eeprom_end+0xff7ef6f2>
     4f0:	a7 7b       	andi	r26, 0xB7	; 183
     4f2:	96 b6       	in	r9, 0x36	; 54
     4f4:	63 69       	ori	r22, 0x93	; 147
     4f6:	4e f7       	brtc	.-46     	; 0x4ca <__trampolines_end+0x3fe>
     4f8:	de e0       	ldi	r29, 0x0E	; 14
     4fa:	78 ca       	rjmp	.-2832   	; 0xfffff9ec <__eeprom_end+0xff7ef9ec>
     4fc:	50 aa       	std	Z+48, r5	; 0x30
     4fe:	41 91       	ld	r20, Z+
     500:	65 88       	ldd	r6, Z+21	; 0x15
     502:	e4 21       	and	r30, r4
     504:	85 da       	rcall	.-2806   	; 0xfffffa10 <__eeprom_end+0xff7efa10>
     506:	3a 27       	eor	r19, r26
     508:	be 1c       	adc	r11, r14
     50a:	3e 42       	sbci	r19, 0x2E	; 46
     50c:	5e 17       	cp	r21, r30
     50e:	52 7f       	andi	r21, 0xF2	; 242
     510:	1f 89       	ldd	r17, Y+23	; 0x17
     512:	24 6f       	ori	r18, 0xF4	; 244
     514:	8f 5c       	subi	r24, 0xCF	; 207
     516:	67 74       	andi	r22, 0x47	; 71
     518:	0e 12       	cpse	r0, r30
     51a:	87 8d       	ldd	r24, Z+31	; 0x1f
     51c:	e9 34       	cpi	r30, 0x49	; 73
     51e:	ed 73       	andi	r30, 0x3D	; 61
     520:	c4 f8       	bld	r12, 4
     522:	61 5b       	subi	r22, 0xB1	; 177
     524:	05 df       	rcall	.-502    	; 0x330 <__trampolines_end+0x264>
     526:	59 4c       	sbci	r21, 0xC9	; 201
     528:	97 79       	andi	r25, 0x97	; 151
     52a:	83 18       	sub	r8, r3
     52c:	a4 55       	subi	r26, 0x54	; 84
     52e:	95 eb       	ldi	r25, 0xB5	; 181
     530:	bd 53       	subi	r27, 0x3D	; 61
     532:	f5 f1       	brhs	.+124    	; 0x5b0 <__trampolines_end+0x4e4>
     534:	57 66       	ori	r21, 0x67	; 103
     536:	46 9f       	mul	r20, r22
     538:	b2 81       	ldd	r27, Z+2	; 0x02
     53a:	09 51       	subi	r16, 0x19	; 25
     53c:	86 22       	and	r8, r22
     53e:	16 dd       	rcall	.-1492   	; 0xffffff6c <__eeprom_end+0xff7eff6c>
     540:	23 93       	.word	0x9323	; ????
     542:	76 29       	or	r23, r6
     544:	c2 d7       	rcall	.+3972   	; 0x14ca <con_probe+0x138>
     546:	1d d4       	rcall	.+2106   	; 0xd82 <do_LLAPI+0x10a>
     548:	bf 36       	cpi	r27, 0x6F	; 111
     54a:	3f ea       	ldi	r19, 0xAF	; 175
     54c:	4b 11       	cpse	r20, r11
     54e:	32 b9       	out	0x02, r19	; 2
     550:	62 54       	subi	r22, 0x42	; 66
     552:	60 d6       	rcall	.+3264   	; 0x1214 <con_autoMapper+0x146>
     554:	6d 43       	sbci	r22, 0x3D	; 61
     556:	9a 0d       	add	r25, r10
     558:	92 9c       	mul	r9, r2
     55a:	b0 ef       	ldi	r27, 0xF0	; 240
     55c:	58 6c       	ori	r21, 0xC8	; 200
     55e:	9d 77       	andi	r25, 0x7D	; 125
     560:	2d 70       	andi	r18, 0x0D	; 13
     562:	fa f3       	brmi	.-2      	; 0x562 <__trampolines_end+0x496>
     564:	b3 0b       	sbc	r27, r19
     566:	e2 40       	sbci	r30, 0x02	; 2
     568:	7e f4       	brtc	.+30     	; 0x588 <__trampolines_end+0x4bc>
     56a:	8a e5       	ldi	r24, 0x5A	; 90
     56c:	8c 3c       	cpi	r24, 0xCC	; 204
     56e:	56 71       	andi	r21, 0x16	; 22
     570:	d1 64       	ori	r29, 0x41	; 65
     572:	e1 82       	std	Z+1, r14	; 0x01
     574:	0a cb       	rjmp	.-2540   	; 0xfffffb8a <__eeprom_end+0xff7efb8a>
     576:	13 15       	cp	r17, r3
     578:	90 ec       	ldi	r25, 0xC0	; 192
     57a:	03 99       	sbic	0x00, 3	; 0
     57c:	af 14       	cp	r10, r15
     57e:	5d 0f       	add	r21, r29
     580:	33 4a       	sbci	r19, 0xA3	; 163
     582:	94 a5       	ldd	r25, Z+44	; 0x2c
     584:	a8 35       	cpi	r26, 0x58	; 88
     586:	1b e3       	ldi	r17, 0x3B	; 59
     588:	6a c6       	rjmp	.+3284   	; 0x125e <con_autoMapper+0x190>
     58a:	28 ff       	.word	0xff28	; ????
     58c:	4d e7       	ldi	r20, 0x7D	; 125
     58e:	25 84       	ldd	r2, Z+13	; 0x0d
     590:	ac 08       	sbc	r10, r12
     592:	ae c5       	rjmp	.+2908   	; 0x10f0 <con_autoMapper+0x22>
     594:	a2 2a       	or	r10, r18
     596:	b8 37       	cpi	r27, 0x78	; 120
     598:	0c 7a       	andi	r16, 0xAC	; 172
     59a:	a0 c3       	rjmp	.+1856   	; 0xcdc <do_LLAPI+0x64>
     59c:	ce ad       	ldd	r28, Y+62	; 0x3e
     59e:	06 1a       	sub	r0, r22
     5a0:	9e 8b       	std	Y+22, r25	; 0x16
     5a2:	fb d5       	rcall	.+3062   	; 0x119a <con_autoMapper+0xcc>
     5a4:	d0 c1       	rjmp	.+928    	; 0x946 <__trampolines_end+0x87a>
     5a6:	1e d0       	rcall	.+60     	; 0x5e4 <__trampolines_end+0x518>
     5a8:	b4 9b       	sbis	0x16, 4	; 22
     5aa:	b1 44       	sbci	r27, 0x41	; 65
     5ac:	f2 47       	sbci	r31, 0x72	; 114
     5ae:	c7 68       	ori	r28, 0x87	; 135
     5b0:	cf 72       	andi	r28, 0x2F	; 47
     5b2:	bb 4f       	sbci	r27, 0xFB	; 251
     5b4:	5a f9       	.word	0xf95a	; ????
     5b6:	dc 6b       	ori	r29, 0xBC	; 188
     5b8:	db d2       	rcall	.+1462   	; 0xb70 <__vector_17+0x40>
     5ba:	e8 7c       	andi	r30, 0xC8	; 200
     5bc:	c8 ee       	ldi	r28, 0xE8	; 232
     5be:	98 a1       	ldd	r25, Y+32	; 0x20
     5c0:	e6 d8       	rcall	.-3636   	; 0xfffff78e <__eeprom_end+0xff7ef78e>
     5c2:	39 07       	cpc	r19, r25
     5c4:	5f fd       	.word	0xfd5f	; ????
     5c6:	8e 19       	sub	r24, r14
     5c8:	b7 3b       	cpi	r27, 0xB7	; 183
     5ca:	bc cd       	rjmp	.-1160   	; 0x144 <__trampolines_end+0x78>
     5cc:	7c e3       	ldi	r23, 0x3C	; 60
     5ce:	81 73       	andi	r24, 0x31	; 49
     5d0:	b2 11       	cpse	r27, r2
     5d2:	bf 6f       	ori	r27, 0xFF	; 255
     5d4:	20 98       	cbi	0x04, 0	; 4
     5d6:	fe 75       	andi	r31, 0x5E	; 94
     5d8:	96 ef       	ldi	r25, 0xF6	; 246
     5da:	6c da       	rcall	.-2856   	; 0xfffffab4 <__eeprom_end+0xff7efab4>
     5dc:	50 e1       	ldi	r21, 0x10	; 16
     5de:	09 72       	andi	r16, 0x29	; 41
     5e0:	54 45       	sbci	r21, 0x54	; 84
     5e2:	ba 34       	cpi	r27, 0x4A	; 74
     5e4:	80 5b       	subi	r24, 0xB0	; 176
     5e6:	ed 3e       	cpi	r30, 0xED	; 237
     5e8:	53 2c       	mov	r5, r3
     5ea:	87 a4       	ldd	r8, Z+47	; 0x2f
     5ec:	57 f3       	brie	.-44     	; 0x5c2 <__trampolines_end+0x4f6>
     5ee:	33 3f       	cpi	r19, 0xF3	; 243
     5f0:	3c b7       	in	r19, 0x3c	; 60
     5f2:	67 b4       	in	r6, 0x27	; 39
     5f4:	a3 25       	eor	r26, r3
     5f6:	60 4f       	sbci	r22, 0xF0	; 240
     5f8:	07 6b       	ori	r16, 0xB7	; 183
     5fa:	1b 47       	sbci	r17, 0x7B	; 123
     5fc:	15 0f       	add	r17, r21
     5fe:	e4 0a       	sbc	r14, r20
     600:	ea d1       	rcall	.+980    	; 0x9d6 <__trampolines_end+0x90a>
     602:	32 78       	andi	r19, 0x82	; 130
     604:	36 49       	sbci	r19, 0x96	; 150
     606:	8d 4b       	sbci	r24, 0xBD	; 189
     608:	d2 bc       	out	0x22, r13	; 34
     60a:	a5 dc       	rcall	.-1718   	; 0xffffff56 <__eeprom_end+0xff7eff56>
     60c:	1d 0d       	add	r17, r13
     60e:	4d cd       	rjmp	.-1382   	; 0xaa <__SREG__+0x6b>
     610:	9a 82       	std	Y+2, r9	; 0x02
     612:	5f fc       	.word	0xfc5f	; ????
     614:	94 65       	ori	r25, 0x54	; 84
     616:	be e2       	ldi	r27, 0x2E	; 46
     618:	f4 c9       	rjmp	.-3096   	; 0xfffffa02 <__eeprom_end+0xff7efa02>
     61a:	1e 44       	sbci	r17, 0x4E	; 78
     61c:	cb 9e       	mul	r12, r27
     61e:	0c 64       	ori	r16, 0x4C	; 76
     620:	71 26       	eor	r7, r17
     622:	63 b3       	in	r22, 0x13	; 19
     624:	14 e8       	ldi	r17, 0x84	; 132
     626:	40 70       	andi	r20, 0x00	; 0
     628:	8a 0e       	add	r8, r26
     62a:	19 42       	sbci	r17, 0x29	; 41
     62c:	6d ac       	ldd	r6, Y+61	; 0x3d
     62e:	88 10       	cpse	r8, r8
     630:	5c df       	rcall	.-328    	; 0x4ea <__trampolines_end+0x41e>
     632:	41 a9       	ldd	r20, Z+49	; 0x31
     634:	ad e5       	ldi	r26, 0x5D	; 93
     636:	fb 74       	andi	r31, 0x4B	; 75
     638:	cc d5       	rcall	.+2968   	; 0x11d2 <con_autoMapper+0x104>
     63a:	06 8e       	std	Z+30, r0	; 0x1e
     63c:	59 86       	std	Y+9, r5	; 0x09
     63e:	ce 1f       	adc	r28, r30
     640:	3d 76       	andi	r19, 0x6D	; 109
     642:	e0 8f       	std	Z+24, r30	; 0x18
     644:	b9 77       	andi	r27, 0x79	; 121
     646:	27 7b       	andi	r18, 0xB7	; 183
     648:	a6 d8       	rcall	.-3764   	; 0xfffff796 <__eeprom_end+0xff7ef796>
     64a:	29 d3       	rcall	.+1618   	; 0xc9e <do_LLAPI+0x26>
     64c:	ec b8       	out	0x0c, r14	; 12
     64e:	13 f7       	brvc	.-60     	; 0x614 <__trampolines_end+0x548>
     650:	fa c3       	rjmp	.+2036   	; 0xe46 <do_LLAPI+0x1ce>
     652:	51 6a       	ori	r21, 0xA1	; 161
     654:	de 4a       	sbci	r29, 0xAE	; 174
     656:	5a eb       	ldi	r21, 0xBA	; 186
     658:	c2 8b       	std	Z+18, r28	; 0x12
     65a:	23 48       	sbci	r18, 0x83	; 131
     65c:	92 cf       	rjmp	.-220    	; 0x582 <__trampolines_end+0x4b6>
     65e:	62 a8       	ldd	r6, Z+50	; 0x32
     660:	99 f8       	.word	0xf899	; ????
     662:	d0 2e       	mov	r13, r16
     664:	85 61       	ori	r24, 0x15	; 21
     666:	43 c8       	rjmp	.-3962   	; 0xfffff6ee <__eeprom_end+0xff7ef6ee>
     668:	bd f0       	brhs	.+46     	; 0x698 <__trampolines_end+0x5cc>
     66a:	05 93       	las	Z, r16
     66c:	ca 4e       	sbci	r28, 0xEA	; 234
     66e:	f1 7d       	andi	r31, 0xD1	; 209
     670:	30 fd       	sbrc	r19, 0
     672:	c4 69       	ori	r28, 0x94	; 148
     674:	66 2f       	mov	r22, r22
     676:	08 b1       	in	r16, 0x08	; 8
     678:	52 f9       	bld	r21, 2
     67a:	21 e6       	ldi	r18, 0x61	; 97
     67c:	7a 2b       	or	r23, r26
     67e:	dd 39       	cpi	r29, 0x9D	; 157
     680:	84 ff       	sbrs	r24, 4
     682:	c0 91 d6 37 	lds	r28, 0x37D6
     686:	d4 7f       	andi	r29, 0xF4	; 244
     688:	2d 9b       	sbis	0x05, 5	; 5
     68a:	5d a1       	ldd	r21, Y+37	; 0x25
     68c:	3b 6e       	ori	r19, 0xEB	; 235
     68e:	b5 c5       	rjmp	.+2922   	; 0x11fa <con_autoMapper+0x12c>
     690:	46 04       	cpc	r4, r6
     692:	f5 90       	lpm	r15, Z+
     694:	ee 7e       	andi	r30, 0xEE	; 238
     696:	83 1c       	adc	r8, r3
     698:	03 56       	subi	r16, 0x63	; 99
     69a:	b6 aa       	std	Z+54, r11	; 0x36
     69c:	00 17       	cp	r16, r16
     69e:	01 35       	cpi	r16, 0x51	; 81
     6a0:	55 79       	andi	r21, 0x95	; 149
     6a2:	0b 12       	cpse	r0, r27
     6a4:	bb 1a       	sub	r11, r27
     6a6:	31 e7       	ldi	r19, 0x71	; 113
     6a8:	02 28       	or	r0, r2
     6aa:	16 c1       	rjmp	.+556    	; 0x8d8 <__trampolines_end+0x80c>
     6ac:	f6 a2       	std	Z+38, r15	; 0x26
     6ae:	db 18       	sub	r13, r11
     6b0:	9c 89       	ldd	r25, Y+20	; 0x14
     6b2:	68 38       	cpi	r22, 0x88	; 136
     6b4:	97 ab       	std	Z+55, r25	; 0x37
     6b6:	c7 2a       	or	r12, r23
     6b8:	d7 3a       	cpi	r29, 0xA7	; 167
     6ba:	f2 c6       	rjmp	.+3556   	; 0x14a0 <con_probe+0x10e>
     6bc:	24 4c       	sbci	r18, 0xC4	; 196
     6be:	b0 58       	subi	r27, 0x80	; 128
     6c0:	a0 22       	and	r10, r16
     6c2:	5e 9d       	mul	r21, r14
     6c4:	d9 a7       	std	Y+41, r29	; 0x29
     6c6:	e9 ae       	std	Y+57, r14	; 0x39
     6c8:	af 8c       	ldd	r10, Y+31	; 0x1f
     6ca:	95 9f       	mul	r25, r21
     6cc:	28 b7       	in	r18, 0x38	; 56
     6ce:	20 d7       	rcall	.+3648   	; 0x1510 <con_probe+0x17e>
     6d0:	b0 30       	cpi	r27, 0x00	; 0
     6d2:	c3 09       	sbc	r28, r3
     6d4:	19 c0       	rjmp	.+50     	; 0x708 <__trampolines_end+0x63c>
     6d6:	67 d6       	rcall	.+3278   	; 0x13a6 <con_probe+0x14>
     6d8:	00 3c       	cpi	r16, 0xC0	; 192
     6da:	7e e7       	ldi	r23, 0x7E	; 126
     6dc:	e9 f4       	brne	.+58     	; 0x718 <__trampolines_end+0x64c>
     6de:	08 5a       	subi	r16, 0xA8	; 168
     6e0:	f8 b8       	out	0x08, r15	; 8
     6e2:	2e 05       	cpc	r18, r14
     6e4:	a6 25       	eor	r26, r6
     6e6:	9e 5c       	subi	r25, 0xCE	; 206
     6e8:	d8 15       	cp	r29, r8
     6ea:	0d e1       	ldi	r16, 0x1D	; 29
     6ec:	f6 11       	cpse	r31, r6
     6ee:	54 6b       	ori	r21, 0xB4	; 180
     6f0:	cd 21       	and	r28, r13
     6f2:	46 66       	ori	r20, 0x66	; 102
     6f4:	5e 84       	ldd	r5, Y+14	; 0x0e
     6f6:	ad 06       	cpc	r10, r29
     6f8:	38 29       	or	r19, r8
     6fa:	44 c5       	rjmp	.+2696   	; 0x1184 <con_autoMapper+0xb6>
     6fc:	a2 ce       	rjmp	.-700    	; 0x442 <__trampolines_end+0x376>
     6fe:	f1 aa       	std	Z+49, r15	; 0x31
     700:	c1 40       	sbci	r28, 0x01	; 1
     702:	71 86       	std	Z+9, r7	; 0x09
     704:	b5 ef       	ldi	r27, 0xF5	; 245
     706:	fc 36       	cpi	r31, 0x6C	; 108
     708:	a8 cb       	rjmp	.-2224   	; 0xfffffe5a <__eeprom_end+0xff7efe5a>
     70a:	0a 48       	sbci	r16, 0x8A	; 138
     70c:	27 45       	sbci	r18, 0x57	; 87
     70e:	64 a3       	std	Z+36, r22	; 0x24
     710:	af 8c       	ldd	r10, Y+31	; 0x1f
     712:	b2 c6       	rjmp	.+3428   	; 0x1478 <con_probe+0xe6>
     714:	9f 07       	cpc	r25, r31
     716:	89 dc       	rcall	.-1774   	; 0x2a <__zero_reg__+0x29>
     718:	17 d3       	rcall	.+1582   	; 0xd48 <do_LLAPI+0xd0>
     71a:	49 79       	andi	r20, 0x99	; 153
     71c:	fb fe       	.word	0xfefb	; ????
     71e:	1d d0       	rcall	.+58     	; 0x75a <__trampolines_end+0x68e>
     720:	b9 88       	ldd	r11, Y+17	; 0x11
     722:	43 52       	subi	r20, 0x23	; 35
     724:	bc 01       	movw	r22, r24
     726:	78 2b       	or	r23, r24
     728:	7d 94 c7 0e 	jmp	0x1e1d8e	; 0x1e1d8e <__data_load_end+0x1dc746>
     72c:	de a5       	ldd	r29, Y+46	; 0x2e
     72e:	d5 9b       	sbis	0x1a, 5	; 26
     730:	cc f7       	brge	.-14     	; 0x724 <__trampolines_end+0x658>
     732:	61 7a       	andi	r22, 0xA1	; 161
     734:	c2 74       	andi	r28, 0x42	; 66
     736:	81 39       	cpi	r24, 0x91	; 145
     738:	03 ab       	std	Z+51, r16	; 0x33
     73a:	96 a0       	ldd	r9, Z+38	; 0x26
     73c:	37 bd       	out	0x27, r19	; 39
     73e:	2d 72       	andi	r18, 0x2D	; 45
     740:	75 3f       	cpi	r23, 0xF5	; 245
     742:	c9 d4       	rcall	.+2450   	; 0x10d6 <con_autoMapper+0x8>
     744:	8e 6f       	ori	r24, 0xFE	; 254
     746:	f9 8d       	ldd	r31, Y+25	; 0x19
     748:	ed 62       	ori	r30, 0x2D	; 45
     74a:	db 1c       	adc	r13, r11
     74c:	df 04       	cpc	r13, r15
     74e:	ac 1b       	sub	r26, r28
     750:	6c 14       	cp	r6, r12
     752:	4b 63       	ori	r20, 0x3B	; 59
     754:	d0 bf       	out	0x30, r29	; 48
     756:	b4 82       	std	Z+4, r11	; 0x04
     758:	ec 7b       	andi	r30, 0xBC	; 188
     75a:	1a 59       	subi	r17, 0x9A	; 154
     75c:	92 d2       	rcall	.+1316   	; 0xc82 <do_LLAPI+0xa>
     75e:	10 60       	ori	r17, 0x00	; 0
     760:	b6 3d       	cpi	r27, 0xD6	; 214
     762:	5f e6       	ldi	r21, 0x6F	; 111
     764:	80 6e       	ori	r24, 0xE0	; 224
     766:	70 c4       	rjmp	.+2272   	; 0x1048 <main+0x7a>
     768:	f2 35       	cpi	r31, 0x52	; 82
     76a:	d9 7c       	andi	r29, 0xC9	; 201
     76c:	ee e5       	ldi	r30, 0x5E	; 94
     76e:	41 a4       	ldd	r4, Z+41	; 0x29
     770:	5b 50       	subi	r21, 0x0B	; 11
     772:	dd bb       	out	0x1d, r29	; 29
     774:	4c f3       	brlt	.-46     	; 0x748 <__trampolines_end+0x67c>
     776:	1f 9d       	mul	r17, r15
     778:	5d 57       	subi	r21, 0x7D	; 125
     77a:	55 51       	subi	r21, 0x15	; 21
     77c:	97 e3       	ldi	r25, 0x37	; 55
     77e:	58 42       	sbci	r21, 0x28	; 40
     780:	4d 9c       	mul	r4, r13
     782:	73 ba       	out	0x13, r7	; 19
     784:	c8 77       	andi	r28, 0x78	; 120
     786:	31 69       	ori	r19, 0x91	; 145
     788:	26 ae       	std	Z+62, r2	; 0x3e
     78a:	ea 8a       	std	Y+18, r14	; 0x12
     78c:	da 22       	and	r13, r26
     78e:	b3 87       	std	Z+11, r27	; 0x0b
     790:	56 fa       	bst	r5, 6
     792:	93 0b       	sbc	r25, r19
     794:	34 16       	cp	r3, r20
     796:	33 e8       	ldi	r19, 0x83	; 131
     798:	e4 53       	subi	r30, 0x34	; 52
     79a:	be a9       	ldd	r27, Y+54	; 0x36
     79c:	b1 3a       	cpi	r27, 0xA1	; 161
     79e:	3e f5       	brtc	.+78     	; 0x7ee <__trampolines_end+0x722>
     7a0:	90 6a       	ori	r25, 0xA0	; 160
     7a2:	cf 3b       	cpi	r28, 0xBF	; 191
     7a4:	12 fd       	sbrc	r17, 2
     7a6:	8f 9a       	sbi	0x11, 7	; 17
     7a8:	a7 47       	sbci	r26, 0x77	; 119
     7aa:	91 99       	sbic	0x12, 1	; 18
     7ac:	eb 0f       	add	r30, r27
     7ae:	24 ff       	sbrs	r18, 4
     7b0:	23 18       	sub	r2, r3
     7b2:	85 4e       	sbci	r24, 0xE5	; 229
     7b4:	7f 0c       	add	r7, r15
     7b6:	e0 a1       	ldd	r30, Z+32	; 0x20
     7b8:	d2 d1       	rcall	.+932    	; 0xb5e <__vector_17+0x2e>
     7ba:	2c 2a       	or	r2, r28
     7bc:	4a 02       	muls	r20, r26
     7be:	4f 1e       	adc	r4, r31
     7c0:	95 68       	ori	r25, 0x85	; 133
     7c2:	8b 98       	cbi	0x11, 3	; 17
     7c4:	83 6d       	ori	r24, 0xD3	; 211
     7c6:	76 ca       	rjmp	.-2836   	; 0xfffffcb4 <__eeprom_end+0xff7efcb4>
     7c8:	65 32       	cpi	r22, 0x25	; 37
     7ca:	13 2f       	mov	r17, r19
     7cc:	c3 82       	std	Z+3, r12	; 0x03
     7ce:	9a a4       	ldd	r9, Y+42	; 0x2a
     7d0:	ba 81       	ldd	r27, Y+2	; 0x02
     7d2:	60 37       	cpi	r22, 0x70	; 112
     7d4:	34 35       	cpi	r19, 0x54	; 84
     7d6:	fc 80       	ldd	r15, Y+4	; 0x04
     7d8:	a8 51       	subi	r26, 0x18	; 24
     7da:	65 67       	ori	r22, 0x75	; 117
     7dc:	ed 30       	cpi	r30, 0x0D	; 13
     7de:	5f 10       	cpse	r5, r15
     7e0:	d3 4a       	sbci	r29, 0xA3	; 163
     7e2:	27 2f       	mov	r18, r23
     7e4:	13 b9       	out	0x03, r17	; 3
     7e6:	2a d2       	rcall	.+1108   	; 0xc3c <checkControllerType+0xe>
     7e8:	cc e1       	ldi	r28, 0x1C	; 28
     7ea:	ef ae       	std	Y+63, r14	; 0x3f
     7ec:	eb be       	out	0x3b, r14	; 59
     7ee:	f4 bd       	out	0x24, r31	; 36
     7f0:	cf 43       	sbci	r28, 0x3F	; 63
     7f2:	b3 c5       	rjmp	.+2918   	; 0x135a <con_clear+0x12>
     7f4:	88 84       	ldd	r8, Y+8	; 0x08
     7f6:	b7 dd       	rcall	.-1170   	; 0x366 <__trampolines_end+0x29a>
     7f8:	39 40       	sbci	r19, 0x09	; 9
     7fa:	ce 48       	sbci	r28, 0x8E	; 142
     7fc:	6d 9b       	sbis	0x0d, 5	; 13
     7fe:	72 61       	ori	r23, 0x12	; 18
     800:	7e e7       	ldi	r23, 0x7E	; 126
     802:	a1 4e       	sbci	r26, 0xE1	; 225
     804:	53 2e       	mov	r5, r19
     806:	77 3b       	cpi	r23, 0xB7	; 183
     808:	e2 c9       	rjmp	.-3132   	; 0xfffffbce <__eeprom_end+0xff7efbce>
     80a:	36 22       	and	r3, r22
     80c:	1b 6e       	ori	r17, 0xEB	; 235
     80e:	73 b1       	in	r23, 0x03	; 3
     810:	03 b2       	in	r0, 0x13	; 19
     812:	4c 87       	std	Y+12, r20	; 0x0c
     814:	a9 d4       	rcall	.+2386   	; 0x1168 <con_autoMapper+0x9a>
     816:	4d 0f       	add	r20, r29
     818:	d8 15       	cp	r29, r8
     81a:	6c aa       	std	Y+52, r6	; 0x34
     81c:	18 f6       	brcc	.-122    	; 0x7a4 <__trampolines_end+0x6d8>
     81e:	49 57       	subi	r20, 0x79	; 121
     820:	5d fb       	.word	0xfb5d	; ????
     822:	7a 14       	cp	r7, r10
     824:	94 63       	ori	r25, 0x34	; 52
     826:	a0 11       	cpse	r26, r0
     828:	b0 9e       	mul	r11, r16
     82a:	de 05       	cpc	r29, r14
     82c:	46 c8       	rjmp	.-3956   	; 0xfffff8ba <__eeprom_end+0xff7ef8ba>
     82e:	ee 47       	sbci	r30, 0x7E	; 126
     830:	db dc       	rcall	.-1610   	; 0x1e8 <__trampolines_end+0x11c>
     832:	24 89       	ldd	r18, Z+20	; 0x14
     834:	9c 91       	ld	r25, X
     836:	97 29       	or	r25, r7
     838:	e9 7b       	andi	r30, 0xB9	; 185
     83a:	c1 07       	cpc	r28, r17
     83c:	1e b8       	out	0x0e, r1	; 14
     83e:	fd fe       	.word	0xfefd	; ????
     840:	ac c6       	rjmp	.+3416   	; 0x159a <con_probe+0x208>
     842:	62 98       	cbi	0x0c, 2	; 12
     844:	4f f1       	brie	.+82     	; 0x898 <__trampolines_end+0x7cc>
     846:	79 e0       	ldi	r23, 0x09	; 9
     848:	e8 6b       	ori	r30, 0xB8	; 184
     84a:	78 56       	subi	r23, 0x68	; 104
     84c:	b6 8d       	ldd	r27, Z+30	; 0x1e
     84e:	04 50       	subi	r16, 0x04	; 4
     850:	86 ca       	rjmp	.-2804   	; 0xfffffd5e <__eeprom_end+0xff7efd5e>
     852:	6f 20       	and	r6, r15
     854:	e6 ea       	ldi	r30, 0xA6	; 166
     856:	e5 76       	andi	r30, 0x65	; 101
     858:	17 1c       	adc	r1, r7
     85a:	74 7f       	andi	r23, 0xF4	; 244
     85c:	bc 0d       	add	r27, r12
     85e:	2c 85       	ldd	r18, Y+12	; 0x0c
     860:	f7 66       	ori	r31, 0x67	; 103
     862:	96 e4       	ldi	r25, 0x46	; 70
     864:	8b 75       	andi	r24, 0x5B	; 91
     866:	3f 4b       	sbci	r19, 0xBF	; 191
     868:	d9 38       	cpi	r29, 0x89	; 137
     86a:	af 7c       	andi	r26, 0xCF	; 207
     86c:	da 0b       	sbc	r29, r26
     86e:	83 2d       	mov	r24, r3
     870:	31 32       	cpi	r19, 0x21	; 33
     872:	a2 f5       	brpl	.+104    	; 0x8dc <__trampolines_end+0x810>
     874:	1d 59       	subi	r17, 0x9D	; 157
     876:	41 45       	sbci	r20, 0x51	; 81
     878:	bf 3c       	cpi	r27, 0xCF	; 207
     87a:	1f f8       	.word	0xf81f	; ????
     87c:	f9 8a       	std	Y+17, r15	; 0x11
     87e:	d0 16       	cp	r13, r16
     880:	25 69       	ori	r18, 0x95	; 149
     882:	12 99       	sbic	0x02, 2	; 2
     884:	9d 21       	and	r25, r13
     886:	95 ab       	std	Z+53, r25	; 0x35
     888:	01 a6       	std	Z+41, r0	; 0x29
     88a:	d7 b5       	in	r29, 0x27	; 39
     88c:	c0 7d       	andi	r28, 0xD0	; 208
     88e:	ff 58       	subi	r31, 0x8F	; 143
     890:	0e 3a       	cpi	r16, 0xAE	; 174
     892:	92 d1       	rcall	.+804    	; 0xbb8 <getInfo+0x12>
     894:	55 e3       	ldi	r21, 0x35	; 53
     896:	08 9f       	mul	r16, r24
     898:	d6 3e       	cpi	r29, 0xE6	; 230
     89a:	52 8e       	std	Z+26, r5	; 0x1a
     89c:	fa a3       	std	Y+34, r31	; 0x22
     89e:	c7 02       	muls	r28, r23
     8a0:	cd df       	rcall	.-102    	; 0x83c <__trampolines_end+0x770>
     8a2:	8f 64       	ori	r24, 0x4F	; 79
     8a4:	19 8c       	ldd	r1, Y+25	; 0x19
     8a6:	f3 a7       	std	Z+43, r31	; 0x2b
     8a8:	0c 5e       	subi	r16, 0xEC	; 236
     8aa:	0a 6a       	ori	r16, 0xAA	; 170
     8ac:	09 f0       	breq	.+2      	; 0x8b0 <__trampolines_end+0x7e4>
     8ae:	93 5b       	subi	r25, 0xB3	; 179
     8b0:	42 c2       	rjmp	.+1156   	; 0xd36 <do_LLAPI+0xbe>
     8b2:	06 23       	and	r16, r22
     8b4:	ec 71       	andi	r30, 0x1C	; 28
     8b6:	ad b4       	in	r10, 0x2d	; 45
     8b8:	cb bb       	out	0x1b, r28	; 27
     8ba:	70 28       	or	r7, r0
     8bc:	d5 1a       	sub	r13, r21
     8be:	5c 33       	cpi	r21, 0x3C	; 60
     8c0:	68 5a       	subi	r22, 0xA8	; 168
     8c2:	00 44       	sbci	r16, 0x40	; 64
     8c4:	90 a5       	ldd	r25, Z+40	; 0x28
     8c6:	c4 26       	eor	r12, r20
     8c8:	3d 2b       	or	r19, r29
     8ca:	f2 54       	subi	r31, 0x42	; 66
     8cc:	96 ad       	ldd	r25, Z+62	; 0x3e
     8ce:	da 1f       	adc	r29, r26
     8d0:	ed 33       	cpi	r30, 0x3D	; 61
     8d2:	e1 81       	ldd	r30, Z+1	; 0x01
     8d4:	69 08       	sbc	r6, r9
     8d6:	0d 0a       	sbc	r0, r29
     8d8:	db 35       	cpi	r29, 0x5B	; 91
     8da:	77 9a       	sbi	0x0e, 7	; 14
     8dc:	64 d1       	rcall	.+712    	; 0xba6 <getInfo>
     8de:	fc 78       	andi	r31, 0x8C	; 140
     8e0:	aa 1b       	sub	r26, r26
     8e2:	d0 67       	ori	r29, 0x70	; 112
     8e4:	a0 dd       	rcall	.-1216   	; 0x426 <__trampolines_end+0x35a>
     8e6:	fa 6c       	ori	r31, 0xCA	; 202
     8e8:	63 71       	andi	r22, 0x13	; 19
     8ea:	05 84       	ldd	r0, Z+13	; 0x0d
     8ec:	17 6a       	ori	r17, 0xA7	; 167
     8ee:	89 4f       	sbci	r24, 0xF9	; 249
     8f0:	66 7f       	andi	r22, 0xF6	; 246
     8f2:	c6 50       	subi	r28, 0x06	; 6
     8f4:	55 92       	las	Z, r5
     8f6:	6f bd       	out	0x2f, r22	; 47
     8f8:	e7 d2       	rcall	.+1486   	; 0xec8 <main_update+0x40>
     8fa:	40 72       	andi	r20, 0x20	; 32
     8fc:	8d bb       	out	0x1d, r24	; 29
     8fe:	ec 06       	cpc	r14, r28
     900:	42 8a       	std	Z+18, r4	; 0x12
     902:	e4 88       	ldd	r14, Z+20	; 0x14
     904:	9d 7e       	andi	r25, 0xED	; 237
     906:	7a 82       	std	Y+2, r7	; 0x02
     908:	27 13       	cpse	r18, r23
     90a:	41 1a       	sub	r4, r17
     90c:	af c8       	rjmp	.-3746   	; 0xfffffa6c <__eeprom_end+0xff7efa6c>
     90e:	a4 76       	andi	r26, 0x64	; 100
     910:	b4 c2       	rjmp	.+1384   	; 0xe7a <do_LLAPI+0x202>
     912:	fe 6d       	ori	r31, 0xDE	; 222
     914:	1c d9       	rcall	.-3528   	; 0xfffffb4e <__eeprom_end+0xff7efb4e>
     916:	61 30       	cpi	r22, 0x01	; 1
     918:	b3 7c       	andi	r27, 0xC3	; 195
     91a:	ea f7       	brpl	.-6      	; 0x916 <__trampolines_end+0x84a>
     91c:	29 0f       	add	r18, r25
     91e:	f2 3b       	cpi	r31, 0xB2	; 178
     920:	51 c1       	rjmp	.+674    	; 0xbc4 <getInfo+0x1e>
     922:	de 5f       	subi	r29, 0xFE	; 254
     924:	e5 2a       	or	r14, r21
     926:	2f 99       	sbic	0x05, 7	; 5
     928:	0b 5d       	subi	r16, 0xDB	; 219
     92a:	a3 2b       	or	r26, r19
     92c:	4a ab       	std	Y+50, r20	; 0x32
     92e:	95 a5       	ldd	r25, Z+45	; 0x2d
     930:	d3 58       	subi	r29, 0x83	; 131
     932:	56 ee       	ldi	r21, 0xE6	; 230
     934:	28 31       	cpi	r18, 0x18	; 24
     936:	00 cc       	rjmp	.-2048   	; 0x138 <__trampolines_end+0x6c>
     938:	15 46       	sbci	r17, 0x65	; 101
     93a:	ca e6       	ldi	r28, 0x6A	; 106
     93c:	86 38       	cpi	r24, 0x86	; 134
     93e:	3c 65       	ori	r19, 0x5C	; 92
     940:	f5 e3       	ldi	r31, 0x35	; 53
     942:	9f d6       	rcall	.+3390   	; 0x1682 <con_probe+0x2f0>
     944:	5b 09       	sbc	r21, r11
     946:	49 83       	std	Y+1, r20	; 0x01
     948:	70 2d       	mov	r23, r0
     94a:	53 a9       	ldd	r21, Z+51	; 0x33
     94c:	7d e2       	ldi	r23, 0x2D	; 45
     94e:	c4 ac       	ldd	r12, Z+60	; 0x3c
     950:	8e 5e       	subi	r24, 0xEE	; 238
     952:	b8 25       	eor	r27, r8
     954:	f4 b9       	out	0x04, r31	; 4
     956:	57 f3       	brie	.-44     	; 0x92c <__trampolines_end+0x860>
     958:	f1 68       	ori	r31, 0x81	; 129
     95a:	47 b2       	in	r4, 0x17	; 23
     95c:	a2 59       	subi	r26, 0x92	; 146
     95e:	20 ce       	rjmp	.-960    	; 0x5a0 <__trampolines_end+0x4d4>
     960:	34 79       	andi	r19, 0x94	; 148
     962:	5c 90       	ld	r5, X
     964:	0e 1e       	adc	r0, r30
     966:	be d5       	rcall	.+2940   	; 0x14e4 <con_probe+0x152>
     968:	22 23       	and	r18, r18
     96a:	b1 c9       	rjmp	.-3230   	; 0xfffffcce <__eeprom_end+0xff7efcce>
     96c:	18 62       	ori	r17, 0x28	; 40
     96e:	16 2e       	mov	r1, r22
     970:	91 3e       	cpi	r25, 0xE1	; 225
     972:	07 8f       	std	Z+31, r16	; 0x1f
     974:	d8 3f       	cpi	r29, 0xF8	; 248
     976:	93 3d       	cpi	r25, 0xD3	; 211
     978:	d4 9b       	sbis	0x1a, 4	; 26
     97a:	df 85       	ldd	r29, Y+15	; 0x0f
     97c:	21 fb       	bst	r18, 1
     97e:	11 74       	andi	r17, 0x41	; 65
     980:	97 c7       	rjmp	.+3886   	; 0x18b0 <Update+0xaa>
     982:	d7 dc       	rcall	.-1618   	; 0x332 <__trampolines_end+0x266>
     984:	4c 19       	sub	r20, r12
     986:	45 98       	cbi	0x08, 5	; 8
     988:	e9 43       	sbci	r30, 0x39	; 57
     98a:	02 4b       	sbci	r16, 0xB2	; 178
     98c:	bc c3       	rjmp	.+1912   	; 0x1106 <con_autoMapper+0x38>
     98e:	04 9c       	mul	r0, r4
     990:	6b f0       	brvs	.+26     	; 0x9ac <__trampolines_end+0x8e0>
     992:	75 52       	subi	r23, 0x25	; 37
     994:	a7 26       	eor	r10, r23
     996:	f6 c5       	rjmp	.+3052   	; 0x1584 <con_probe+0x1f2>
     998:	ba cf       	rjmp	.-140    	; 0x90e <__trampolines_end+0x842>
     99a:	b0 b7       	in	r27, 0x30	; 48
     99c:	ae 5a       	subi	r26, 0xAE	; 174
     99e:	a1 bf       	out	0x31, r26	; 49
     9a0:	03 8b       	std	Z+19, r16	; 0x13
     9a2:	80 12       	cpse	r8, r16
     9a4:	6e 0c       	add	r6, r14
     9a6:	eb f9       	.word	0xf9eb	; ????
     9a8:	c0 44       	sbci	r28, 0x40	; 64
     9aa:	24 ef       	ldi	r18, 0xF4	; 244
     9ac:	10 f8       	bld	r1, 0
     9ae:	a8 8c       	ldd	r10, Y+24	; 0x18
     9b0:	e8 7b       	andi	r30, 0xB8	; 184
     9b2:	ff 9e       	mul	r15, r31
     9b4:	2c cd       	rjmp	.-1448   	; 0x40e <__trampolines_end+0x342>
     9b6:	60 36       	cpi	r22, 0x60	; 96
     9b8:	87 b5       	in	r24, 0x27	; 39
     9ba:	94 a6       	std	Z+44, r9	; 0x2c
     9bc:	54 73       	andi	r21, 0x34	; 52
     9be:	3a 14       	cp	r3, r10
     9c0:	4e 01       	movw	r8, r28
     9c2:	1d b6       	in	r1, 0x3d	; 61
     9c4:	fd 37       	cpi	r31, 0x7D	; 125
     9c6:	48 4d       	sbci	r20, 0xD8	; 216
     9c8:	39 cb       	rjmp	.-2446   	; 0x3c <__zero_reg__+0x3b>
     9ca:	e0 32       	cpi	r30, 0x20	; 32
     9cc:	00 00       	nop
     9ce:	00 00       	nop
     9d0:	00 00       	nop
     9d2:	00 00       	nop
     9d4:	00 00       	nop
     9d6:	00 00       	nop
     9d8:	00 00       	nop
     9da:	00 00       	nop
     9dc:	00 00       	nop
     9de:	00 00       	nop
     9e0:	00 00       	nop
     9e2:	00 00       	nop
     9e4:	00 00       	nop
     9e6:	00 00       	nop
     9e8:	00 00       	nop
     9ea:	00 00       	nop
     9ec:	00 00       	nop
     9ee:	00 00       	nop
     9f0:	00 00       	nop
     9f2:	00 00       	nop
     9f4:	00 00       	nop
     9f6:	00 00       	nop
     9f8:	00 00       	nop
     9fa:	00 00       	nop
     9fc:	00 00       	nop
     9fe:	00 00       	nop
     a00:	00 00       	nop
     a02:	00 00       	nop
     a04:	00 00       	nop
     a06:	00 00       	nop
     a08:	00 00       	nop
     a0a:	00 00       	nop
     a0c:	00 00       	nop
     a0e:	00 00       	nop
     a10:	00 00       	nop
     a12:	00 00       	nop
     a14:	00 00       	nop
     a16:	00 00       	nop
     a18:	00 00       	nop
     a1a:	00 00       	nop
     a1c:	00 00       	nop
     a1e:	00 00       	nop
     a20:	00 00       	nop
     a22:	00 00       	nop
     a24:	00 00       	nop
     a26:	00 00       	nop
     a28:	00 00       	nop
     a2a:	00 00       	nop
     a2c:	00 00       	nop
     a2e:	00 00       	nop
     a30:	00 00       	nop
     a32:	00 00       	nop
     a34:	00 00       	nop
     a36:	00 00       	nop
     a38:	00 00       	nop
     a3a:	00 00       	nop
     a3c:	00 00       	nop
     a3e:	00 00       	nop
     a40:	00 00       	nop
     a42:	00 00       	nop
     a44:	00 00       	nop
     a46:	00 00       	nop
     a48:	00 00       	nop
     a4a:	00 00       	nop
     a4c:	00 00       	nop
     a4e:	00 00       	nop
     a50:	00 00       	nop
     a52:	00 00       	nop
     a54:	00 00       	nop
     a56:	00 00       	nop
     a58:	00 00       	nop
     a5a:	00 00       	nop
     a5c:	00 00       	nop
     a5e:	00 00       	nop
     a60:	00 00       	nop
     a62:	00 00       	nop
     a64:	00 00       	nop
     a66:	00 00       	nop
     a68:	00 00       	nop
     a6a:	00 00       	nop
     a6c:	00 00       	nop
     a6e:	00 00       	nop
     a70:	00 00       	nop
     a72:	00 00       	nop
     a74:	00 00       	nop
     a76:	00 00       	nop
     a78:	00 00       	nop
     a7a:	00 00       	nop
     a7c:	00 00       	nop
     a7e:	00 00       	nop
     a80:	00 00       	nop
     a82:	00 00       	nop
     a84:	00 00       	nop
     a86:	00 00       	nop
     a88:	00 00       	nop
     a8a:	00 00       	nop
     a8c:	00 00       	nop
     a8e:	00 00       	nop
     a90:	00 00       	nop
     a92:	00 00       	nop
     a94:	00 00       	nop
     a96:	00 00       	nop
     a98:	00 00       	nop
     a9a:	00 00       	nop
     a9c:	00 00       	nop
     a9e:	00 00       	nop
     aa0:	00 00       	nop
     aa2:	00 00       	nop
     aa4:	00 00       	nop
     aa6:	00 00       	nop
     aa8:	00 00       	nop
     aaa:	00 00       	nop
     aac:	00 00       	nop
     aae:	00 00       	nop
     ab0:	00 00       	nop
     ab2:	00 00       	nop
     ab4:	00 00       	nop
     ab6:	00 00       	nop
     ab8:	00 00       	nop
     aba:	00 00       	nop
     abc:	00 00       	nop
     abe:	00 00       	nop
     ac0:	00 00       	nop
     ac2:	00 00       	nop
     ac4:	00 00       	nop
     ac6:	00 00       	nop
     ac8:	00 00       	nop
     aca:	00 00       	nop

00000acc <ans_tbl>:
     acc:	a8 77 a6 e0 f7 43 5a 35 85 e2 72 97 8f b7 1a 62     .w...CZ5..r....b
     adc:	87 38 0d 67 c7 be 4f 3e 20 76 37 8f 68 b7 a9 26     .8.g..O> v7.h..&
     aec:	3f 2b 10 e3 30 7e 90 0e 85 0a                       ?+..0~....

00000af6 <__ctors_end>:
     af6:	11 24       	eor	r1, r1
     af8:	1f be       	out	0x3f, r1	; 63
     afa:	cf ef       	ldi	r28, 0xFF	; 255
     afc:	da e0       	ldi	r29, 0x0A	; 10
     afe:	de bf       	out	0x3e, r29	; 62
     b00:	cd bf       	out	0x3d, r28	; 61

00000b02 <__do_copy_data>:
     b02:	11 e0       	ldi	r17, 0x01	; 1
     b04:	a0 e0       	ldi	r26, 0x00	; 0
     b06:	b1 e0       	ldi	r27, 0x01	; 1
     b08:	e0 e9       	ldi	r30, 0x90	; 144
     b0a:	f5 e5       	ldi	r31, 0x55	; 85
     b0c:	02 c0       	rjmp	.+4      	; 0xb12 <__do_copy_data+0x10>
     b0e:	05 90       	lpm	r0, Z+
     b10:	0d 92       	st	X+, r0
     b12:	a8 3b       	cpi	r26, 0xB8	; 184
     b14:	b1 07       	cpc	r27, r17
     b16:	d9 f7       	brne	.-10     	; 0xb0e <__do_copy_data+0xc>

00000b18 <__do_clear_bss>:
     b18:	23 e0       	ldi	r18, 0x03	; 3
     b1a:	a8 eb       	ldi	r26, 0xB8	; 184
     b1c:	b1 e0       	ldi	r27, 0x01	; 1
     b1e:	01 c0       	rjmp	.+2      	; 0xb22 <.do_clear_bss_start>

00000b20 <.do_clear_bss_loop>:
     b20:	1d 92       	st	X+, r1

00000b22 <.do_clear_bss_start>:
     b22:	a0 3a       	cpi	r26, 0xA0	; 160
     b24:	b2 07       	cpc	r27, r18
     b26:	e1 f7       	brne	.-8      	; 0xb20 <.do_clear_bss_loop>
     b28:	52 d2       	rcall	.+1188   	; 0xfce <main>
     b2a:	0c 94 c6 2a 	jmp	0x558c	; 0x558c <_exit>

00000b2e <__bad_interrupt>:
     b2e:	68 ca       	rjmp	.-2864   	; 0x0 <__vectors>

00000b30 <__vector_17>:
int doMap; //using a time out sinnce a one time didnt work, TODO why??
Bridge_interface *getBridgeInterface(void);

//IRQ for consoles that get stuck or take a long time to poll, use as needed. 
ISR(TIMER1_COMPA_vect) 
{
     b30:	1f 92       	push	r1
     b32:	0f 92       	push	r0
     b34:	0f b6       	in	r0, 0x3f	; 63
     b36:	0f 92       	push	r0
     b38:	11 24       	eor	r1, r1
     b3a:	2f 93       	push	r18
     b3c:	3f 93       	push	r19
     b3e:	4f 93       	push	r20
     b40:	5f 93       	push	r21
     b42:	6f 93       	push	r22
     b44:	7f 93       	push	r23
     b46:	8f 93       	push	r24
     b48:	9f 93       	push	r25
     b4a:	af 93       	push	r26
     b4c:	bf 93       	push	r27
     b4e:	ef 93       	push	r30
     b50:	ff 93       	push	r31
	_CON_TIMER_EXP_FLAG = true;
     b52:	81 e0       	ldi	r24, 0x01	; 1
     b54:	80 93 42 03 	sts	0x0342, r24
	// 1, this will fire an int, so it may run this code twice?
	// 2, this should be clearned anyways, I think on match it clears this and this is how we got here. 
	// 3, I think removing is best and re test sega dn jag. 
	//TCNT1 = 0; 
	
	if (Console.Type == JAG) 
     b58:	80 91 65 03 	lds	r24, 0x0365
     b5c:	85 31       	cpi	r24, 0x15	; 21
     b5e:	51 f4       	brne	.+20     	; 0xb74 <__vector_17+0x44>
	{
		bridgeInterface->write(BRIDGE_CONTROLLER_POLL);//poll to keeo BB happy, without this we get left over payloads. 
     b60:	e0 91 87 03 	lds	r30, 0x0387
     b64:	f0 91 88 03 	lds	r31, 0x0388
     b68:	04 80       	ldd	r0, Z+4	; 0x04
     b6a:	f5 81       	ldd	r31, Z+5	; 0x05
     b6c:	e0 2d       	mov	r30, r0
     b6e:	80 e0       	ldi	r24, 0x00	; 0
     b70:	09 95       	icall
     b72:	08 c0       	rjmp	.+16     	; 0xb84 <__vector_17+0x54>
	}
	else if (Console.Type == GEN) 
     b74:	85 32       	cpi	r24, 0x25	; 37
     b76:	31 f4       	brne	.+12     	; 0xb84 <__vector_17+0x54>
	{
		//fake paulse so we stop waiting. 
		if (PINC & 0x40) PORTC &= ~0x40;
     b78:	36 9b       	sbis	0x06, 6	; 6
     b7a:	02 c0       	rjmp	.+4      	; 0xb80 <__vector_17+0x50>
     b7c:	46 98       	cbi	0x08, 6	; 8
     b7e:	01 c0       	rjmp	.+2      	; 0xb82 <__vector_17+0x52>
		else PORTC  |= 0x40;
     b80:	46 9a       	sbi	0x08, 6	; 8
		DDRC |= 0x40;//push out. 
     b82:	3e 9a       	sbi	0x07, 6	; 7
		//not thast this will end the loops in the Gen code thus making it chage the pins states. The only way to prevent this is a 
		//ISR in the gen code, or make the gen state global.
	}
	
	
}
     b84:	ff 91       	pop	r31
     b86:	ef 91       	pop	r30
     b88:	bf 91       	pop	r27
     b8a:	af 91       	pop	r26
     b8c:	9f 91       	pop	r25
     b8e:	8f 91       	pop	r24
     b90:	7f 91       	pop	r23
     b92:	6f 91       	pop	r22
     b94:	5f 91       	pop	r21
     b96:	4f 91       	pop	r20
     b98:	3f 91       	pop	r19
     b9a:	2f 91       	pop	r18
     b9c:	0f 90       	pop	r0
     b9e:	0f be       	out	0x3f, r0	; 63
     ba0:	0f 90       	pop	r0
     ba2:	1f 90       	pop	r1
     ba4:	18 95       	reti

00000ba6 <getInfo>:

void getInfo ( void )
{
     ba6:	cf 93       	push	r28

	unsigned char reply=GET_CONTROLLER_STATUS_ERROR_AP_NO_REPORT;
	while(reply >= ERROR_START_VALUE)
	{
		reply=bridgeInterface->write(MODE_READ); 
     ba8:	e0 91 87 03 	lds	r30, 0x0387
     bac:	f0 91 88 03 	lds	r31, 0x0388
     bb0:	04 80       	ldd	r0, Z+4	; 0x04
     bb2:	f5 81       	ldd	r31, Z+5	; 0x05
     bb4:	e0 2d       	mov	r30, r0
     bb6:	81 e2       	ldi	r24, 0x21	; 33
     bb8:	09 95       	icall
     bba:	c8 2f       	mov	r28, r24
		bridgeInterface->read(2);
     bbc:	e0 91 87 03 	lds	r30, 0x0387
     bc0:	f0 91 88 03 	lds	r31, 0x0388
     bc4:	02 80       	ldd	r0, Z+2	; 0x02
     bc6:	f3 81       	ldd	r31, Z+3	; 0x03
     bc8:	e0 2d       	mov	r30, r0
     bca:	82 e0       	ldi	r24, 0x02	; 2
     bcc:	09 95       	icall
		Controller.AutoPaused = (BB_ReadBuffer[1] & 0x01);//not reaslly needed. Err is 255 for AP, could  ues somethign else in its place. 
     bce:	90 91 44 03 	lds	r25, 0x0344
     bd2:	89 2f       	mov	r24, r25
     bd4:	81 70       	andi	r24, 0x01	; 1
     bd6:	80 93 80 03 	sts	0x0380, r24
		//
		//
		Controller.HotSwapDisabled = (BB_ReadBuffer[1] & 0x08)? true:false;
     bda:	93 fb       	bst	r25, 3
     bdc:	88 27       	eor	r24, r24
     bde:	80 f9       	bld	r24, 0
     be0:	80 93 85 03 	sts	0x0385, r24
		Controller.UDLR = (BB_ReadBuffer[1] & 0x10)? true:false;
     be4:	94 fb       	bst	r25, 4
     be6:	88 27       	eor	r24, r24
     be8:	80 f9       	bld	r24, 0
     bea:	80 93 84 03 	sts	0x0384, r24
		Controller.DisableAllCombos = (BB_ReadBuffer[1] & 0x20)? true:false;
     bee:	95 fb       	bst	r25, 5
     bf0:	88 27       	eor	r24, r24
     bf2:	80 f9       	bld	r24, 0
     bf4:	80 93 82 03 	sts	0x0382, r24
		Controller.AutoPausedDisabled = (BB_ReadBuffer[1] & 0x40) ?true:false;
     bf8:	96 fb       	bst	r25, 6
     bfa:	88 27       	eor	r24, r24
     bfc:	80 f9       	bld	r24, 0
     bfe:	80 93 81 03 	sts	0x0381, r24
		Controller.DpadOnly = (BB_ReadBuffer[1] & 0x80)? true:false;
     c02:	99 1f       	adc	r25, r25
     c04:	99 27       	eor	r25, r25
     c06:	99 1f       	adc	r25, r25
     c08:	90 93 83 03 	sts	0x0383, r25
		//_delay_ms(1);//if a wait here is going to be needed, it will kill 5200m, very short window. 
		if (reply==GET_CONTROLLER_STATUS_ERROR_AP_NO_REPORT) bridgeInterface->write(BRIDGE_CONTROLLER_POLL);//prevents getting stuck
     c0c:	cf 3f       	cpi	r28, 0xFF	; 255
     c0e:	51 f4       	brne	.+20     	; 0xc24 <getInfo+0x7e>
     c10:	e0 91 87 03 	lds	r30, 0x0387
     c14:	f0 91 88 03 	lds	r31, 0x0388
     c18:	04 80       	ldd	r0, Z+4	; 0x04
     c1a:	f5 81       	ldd	r31, Z+5	; 0x05
     c1c:	e0 2d       	mov	r30, r0
     c1e:	80 e0       	ldi	r24, 0x00	; 0
     c20:	09 95       	icall
     c22:	c2 cf       	rjmp	.-124    	; 0xba8 <getInfo+0x2>

void getInfo ( void )
{

	unsigned char reply=GET_CONTROLLER_STATUS_ERROR_AP_NO_REPORT;
	while(reply >= ERROR_START_VALUE)
     c24:	c0 3f       	cpi	r28, 0xF0	; 240
     c26:	08 f0       	brcs	.+2      	; 0xc2a <getInfo+0x84>
     c28:	bf cf       	rjmp	.-130    	; 0xba8 <getInfo+0x2>
		Controller.AutoPausedDisabled = (BB_ReadBuffer[1] & 0x40) ?true:false;
		Controller.DpadOnly = (BB_ReadBuffer[1] & 0x80)? true:false;
		//_delay_ms(1);//if a wait here is going to be needed, it will kill 5200m, very short window. 
		if (reply==GET_CONTROLLER_STATUS_ERROR_AP_NO_REPORT) bridgeInterface->write(BRIDGE_CONTROLLER_POLL);//prevents getting stuck
	}
}
     c2a:	cf 91       	pop	r28
     c2c:	08 95       	ret

00000c2e <checkControllerType>:


void checkControllerType(void ) 
{
	if (	Controller.Type == 121 || //ds2
     c2e:	80 91 86 03 	lds	r24, 0x0386
     c32:	89 37       	cpi	r24, 0x79	; 121
     c34:	21 f0       	breq	.+8      	; 0xc3e <checkControllerType+0x10>
     c36:	83 33       	cpi	r24, 0x33	; 51
     c38:	11 f0       	breq	.+4      	; 0xc3e <checkControllerType+0x10>
			Controller.Type == 51  || //PSX_NEGCON
     c3a:	8f 37       	cpi	r24, 0x7F	; 127
     c3c:	49 f4       	brne	.+18     	; 0xc50 <checkControllerType+0x22>
			Controller.Type == 127    // PSX_JOGCON
		) 
	Controller.Pressure=true;
     c3e:	91 e0       	ldi	r25, 0x01	; 1
     c40:	90 93 7f 03 	sts	0x037F, r25
	else Controller.Pressure=false;
	
	
	if (	Controller.Type == 115 || //ds
     c44:	89 37       	cpi	r24, 0x79	; 121
     c46:	59 f4       	brne	.+22     	; 0xc5e <checkControllerType+0x30>
			Controller.Type == 127 || // PSX_JOGCON
			Controller.Type == 9	  || //GC
			Controller.Type == 18  || //GC_WHEEL
			Controller.Type == 19  //N64
		) 		
	Controller.Rumble=true;
     c48:	81 e0       	ldi	r24, 0x01	; 1
     c4a:	80 93 7e 03 	sts	0x037E, r24
     c4e:	08 95       	ret
	if (	Controller.Type == 121 || //ds2
			Controller.Type == 51  || //PSX_NEGCON
			Controller.Type == 127    // PSX_JOGCON
		) 
	Controller.Pressure=true;
	else Controller.Pressure=false;
     c50:	10 92 7f 03 	sts	0x037F, r1
	
	
	if (	Controller.Type == 115 || //ds
     c54:	83 37       	cpi	r24, 0x73	; 115
     c56:	c1 f3       	breq	.-16     	; 0xc48 <checkControllerType+0x1a>
			Controller.Type == 121 || //ds2
			Controller.Type == 51  || //PSX_NEGCON
			Controller.Type == 127 || // PSX_JOGCON
     c58:	89 30       	cpi	r24, 0x09	; 9
     c5a:	41 f4       	brne	.+16     	; 0xc6c <checkControllerType+0x3e>
     c5c:	f5 cf       	rjmp	.-22     	; 0xc48 <checkControllerType+0x1a>
	Controller.Pressure=true;
	else Controller.Pressure=false;
	
	
	if (	Controller.Type == 115 || //ds
			Controller.Type == 121 || //ds2
     c5e:	98 2f       	mov	r25, r24
     c60:	9f 7b       	andi	r25, 0xBF	; 191
     c62:	93 33       	cpi	r25, 0x33	; 51
     c64:	89 f3       	breq	.-30     	; 0xc48 <checkControllerType+0x1a>
			Controller.Type == 51  || //PSX_NEGCON
     c66:	8f 37       	cpi	r24, 0x7F	; 127
     c68:	b9 f7       	brne	.-18     	; 0xc58 <checkControllerType+0x2a>
     c6a:	ee cf       	rjmp	.-36     	; 0xc48 <checkControllerType+0x1a>
			Controller.Type == 127 || // PSX_JOGCON
			Controller.Type == 9	  || //GC
     c6c:	82 51       	subi	r24, 0x12	; 18
     c6e:	82 30       	cpi	r24, 0x02	; 2
     c70:	58 f3       	brcs	.-42     	; 0xc48 <checkControllerType+0x1a>
			Controller.Type == 18  || //GC_WHEEL
			Controller.Type == 19  //N64
		) 		
	Controller.Rumble=true;
	else Controller.Rumble=false;
     c72:	10 92 7e 03 	sts	0x037E, r1
     c76:	08 95       	ret

00000c78 <do_LLAPI>:
// will return the first byte  //
// Typically controller iD, or //
// error                       //
/////////////////////////////////	
unsigned char do_LLAPI( void ) 
{
     c78:	cf 93       	push	r28
	unsigned char reply ;


	// in AP mode we will need a poll first or no detection takes place. Then we need to get the ID so a data read is needed. But normaly its best not to poll first
	if ( Controller.AutoPaused ) 
     c7a:	80 91 80 03 	lds	r24, 0x0380
     c7e:	81 11       	cpse	r24, r1
     c80:	05 c0       	rjmp	.+10     	; 0xc8c <do_LLAPI+0x14>
	}

	///////////////
	//  Pressure //
	///////////////
	if ( Controller.Pressure  )
     c82:	80 91 7f 03 	lds	r24, 0x037F
     c86:	81 11       	cpse	r24, r1
     c88:	0e c0       	rjmp	.+28     	; 0xca6 <do_LLAPI+0x2e>
     c8a:	32 c0       	rjmp	.+100    	; 0xcf0 <do_LLAPI+0x78>


	// in AP mode we will need a poll first or no detection takes place. Then we need to get the ID so a data read is needed. But normaly its best not to poll first
	if ( Controller.AutoPaused ) 
	{
		if ( bridgeInterface->write(BRIDGE_CONTROLLER_POLL) == -1) return GET_CONTROLLER_STATUS_ERROR_NOTREADY;//other wise proceed. 
     c8c:	e0 91 87 03 	lds	r30, 0x0387
     c90:	f0 91 88 03 	lds	r31, 0x0388
     c94:	04 80       	ldd	r0, Z+4	; 0x04
     c96:	f5 81       	ldd	r31, Z+5	; 0x05
     c98:	e0 2d       	mov	r30, r0
     c9a:	80 e0       	ldi	r24, 0x00	; 0
     c9c:	09 95       	icall
     c9e:	8f 3f       	cpi	r24, 0xFF	; 255
     ca0:	81 f7       	brne	.-32     	; 0xc82 <do_LLAPI+0xa>
     ca2:	8e ef       	ldi	r24, 0xFE	; 254
     ca4:	ef c0       	rjmp	.+478    	; 0xe84 <do_LLAPI+0x20c>
	///////////////
	if ( Controller.Pressure  )
	{

		reply = GET_CONTROLLER_STATUS_ERROR_NOTREADY;
		bridgeInterface->write(BRDIGE_GET_PRESSURE_STATUS);
     ca6:	e0 91 87 03 	lds	r30, 0x0387
     caa:	f0 91 88 03 	lds	r31, 0x0388
     cae:	04 80       	ldd	r0, Z+4	; 0x04
     cb0:	f5 81       	ldd	r31, Z+5	; 0x05
     cb2:	e0 2d       	mov	r30, r0
     cb4:	82 e0       	ldi	r24, 0x02	; 2
     cb6:	09 95       	icall
		reply =bridgeInterface->read(13);
     cb8:	e0 91 87 03 	lds	r30, 0x0387
     cbc:	f0 91 88 03 	lds	r31, 0x0388
     cc0:	02 80       	ldd	r0, Z+2	; 0x02
     cc2:	f3 81       	ldd	r31, Z+3	; 0x03
     cc4:	e0 2d       	mov	r30, r0
     cc6:	8d e0       	ldi	r24, 0x0D	; 13
     cc8:	09 95       	icall
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     cca:	ef ea       	ldi	r30, 0xAF	; 175
     ccc:	f4 e0       	ldi	r31, 0x04	; 4
     cce:	31 97       	sbiw	r30, 0x01	; 1
     cd0:	f1 f7       	brne	.-4      	; 0xcce <do_LLAPI+0x56>
     cd2:	00 c0       	rjmp	.+0      	; 0xcd4 <do_LLAPI+0x5c>
     cd4:	00 00       	nop

		_delay_us(300);//without this we will get bad read from pressure to payloads, seem not to happen in revers? This is not undertood
		
		if (reply < ERROR_START_VALUE)
     cd6:	80 3f       	cpi	r24, 0xF0	; 240
     cd8:	08 f0       	brcs	.+2      	; 0xcdc <do_LLAPI+0x64>
     cda:	d4 c0       	rjmp	.+424    	; 0xe84 <do_LLAPI+0x20c>
     cdc:	e4 e4       	ldi	r30, 0x44	; 68
     cde:	f3 e0       	ldi	r31, 0x03	; 3
     ce0:	a5 e3       	ldi	r26, 0x35	; 53
     ce2:	b3 e0       	ldi	r27, 0x03	; 3
		{
			for (char i=1; i<13;i++) {pressureData[i-1]=BB_ReadBuffer[i];}
     ce4:	81 91       	ld	r24, Z+
     ce6:	8d 93       	st	X+, r24
     ce8:	83 e0       	ldi	r24, 0x03	; 3
     cea:	e0 35       	cpi	r30, 0x50	; 80
     cec:	f8 07       	cpc	r31, r24
     cee:	d1 f7       	brne	.-12     	; 0xce4 <do_LLAPI+0x6c>
	///////////////
	//  Payload  //
	///////////////

	reply = GET_CONTROLLER_STATUS_ERROR_NOTREADY;
	bridgeInterface->write(BRIDGE_GET_CONTROLLER_STATUS);
     cf0:	e0 91 87 03 	lds	r30, 0x0387
     cf4:	f0 91 88 03 	lds	r31, 0x0388
     cf8:	04 80       	ldd	r0, Z+4	; 0x04
     cfa:	f5 81       	ldd	r31, Z+5	; 0x05
     cfc:	e0 2d       	mov	r30, r0
     cfe:	81 e0       	ldi	r24, 0x01	; 1
     d00:	09 95       	icall
	reply =bridgeInterface->read(BB_BUFFER_SIZE);
     d02:	e0 91 87 03 	lds	r30, 0x0387
     d06:	f0 91 88 03 	lds	r31, 0x0388
     d0a:	02 80       	ldd	r0, Z+2	; 0x02
     d0c:	f3 81       	ldd	r31, Z+3	; 0x03
     d0e:	e0 2d       	mov	r30, r0
     d10:	8d e0       	ldi	r24, 0x0D	; 13
     d12:	09 95       	icall
     d14:	c8 2f       	mov	r28, r24

	if ( reply < ERROR_START_VALUE && Controller.Type  !=  reply)
     d16:	80 3f       	cpi	r24, 0xF0	; 240
     d18:	08 f0       	brcs	.+2      	; 0xd1c <do_LLAPI+0xa4>
     d1a:	b3 c0       	rjmp	.+358    	; 0xe82 <do_LLAPI+0x20a>
     d1c:	80 91 86 03 	lds	r24, 0x0386
     d20:	8c 17       	cp	r24, r28
     d22:	31 f1       	breq	.+76     	; 0xd70 <do_LLAPI+0xf8>
	{
		//controller changed. 
		bridgeInterface->write(BRIDGE_CONTROLLER_POLL);//need to poll to get info updated.
     d24:	e0 91 87 03 	lds	r30, 0x0387
     d28:	f0 91 88 03 	lds	r31, 0x0388
     d2c:	04 80       	ldd	r0, Z+4	; 0x04
     d2e:	f5 81       	ldd	r31, Z+5	; 0x05
     d30:	e0 2d       	mov	r30, r0
     d32:	80 e0       	ldi	r24, 0x00	; 0
     d34:	09 95       	icall
		getInfo();
     d36:	37 df       	rcall	.-402    	; 0xba6 <getInfo>
     d38:	e0 91 87 03 	lds	r30, 0x0387
		
		//get fresh data ( note that in sega console mode this was causing a pressing of C button, the fix was to get fresh data)
		bridgeInterface->write(BRIDGE_GET_CONTROLLER_STATUS);
     d3c:	f0 91 88 03 	lds	r31, 0x0388
     d40:	04 80       	ldd	r0, Z+4	; 0x04
     d42:	f5 81       	ldd	r31, Z+5	; 0x05
     d44:	e0 2d       	mov	r30, r0
     d46:	81 e0       	ldi	r24, 0x01	; 1
     d48:	09 95       	icall
     d4a:	e0 91 87 03 	lds	r30, 0x0387
		reply =bridgeInterface->read(BB_BUFFER_SIZE);
     d4e:	f0 91 88 03 	lds	r31, 0x0388
     d52:	02 80       	ldd	r0, Z+2	; 0x02
     d54:	f3 81       	ldd	r31, Z+3	; 0x03
     d56:	e0 2d       	mov	r30, r0
     d58:	8d e0       	ldi	r24, 0x0D	; 13
     d5a:	09 95       	icall
     d5c:	c8 2f       	mov	r28, r24
     d5e:	8f ef       	ldi	r24, 0xFF	; 255
		
		doMap = 255;
     d60:	90 e0       	ldi	r25, 0x00	; 0
     d62:	90 93 55 03 	sts	0x0355, r25
     d66:	80 93 54 03 	sts	0x0354, r24
     d6a:	c0 3f       	cpi	r28, 0xF0	; 240

	}

	if (reply >= ERROR_START_VALUE)  return reply; //has errors so stop and return
     d6c:	08 f0       	brcs	.+2      	; 0xd70 <do_LLAPI+0xf8>
     d6e:	89 c0       	rjmp	.+274    	; 0xe82 <do_LLAPI+0x20a>
     d70:	80 91 63 03 	lds	r24, 0x0363

	///////////////
	//  Rumble   //
	///////////////

	if ( Console.Rumble && Controller.Rumble )
     d74:	88 23       	and	r24, r24
     d76:	09 f4       	brne	.+2      	; 0xd7a <do_LLAPI+0x102>
     d78:	6d c0       	rjmp	.+218    	; 0xe54 <do_LLAPI+0x1dc>
     d7a:	80 91 7e 03 	lds	r24, 0x037E
     d7e:	88 23       	and	r24, r24
     d80:	09 f4       	brne	.+2      	; 0xd84 <do_LLAPI+0x10c>
     d82:	68 c0       	rjmp	.+208    	; 0xe54 <do_LLAPI+0x1dc>
     d84:	90 91 41 03 	lds	r25, 0x0341
	//but only send an off when the value is first 0. Otherwise we just keep spamming the bus 
	//with off data. 
	
	 
	//if there is data or the state changed to off. 
	if (check || oldRumbleState != check )  
     d88:	80 91 50 03 	lds	r24, 0x0350
     d8c:	98 13       	cpse	r25, r24
     d8e:	05 c0       	rjmp	.+10     	; 0xd9a <do_LLAPI+0x122>
     d90:	80 91 b8 01 	lds	r24, 0x01B8
     d94:	88 23       	and	r24, r24
     d96:	09 f4       	brne	.+2      	; 0xd9a <do_LLAPI+0x122>
     d98:	5d c0       	rjmp	.+186    	; 0xe54 <do_LLAPI+0x1dc>
     d9a:	e0 91 87 03 	lds	r30, 0x0387
		//since setting a small motor will overright the large motor in the case of a single
		//motor, we need to use the small motor for this. Small motor will be set second so it 
		//overrights large. In the case of attached xbox controller, both will be used.
		//if we are running off 3v and we use a PSX controller simply using small is all we need. 
				 
			bridgeInterface->write(0x1c); //set effect parms
     d9e:	f0 91 88 03 	lds	r31, 0x0388
     da2:	04 80       	ldd	r0, Z+4	; 0x04
     da4:	f5 81       	ldd	r31, Z+5	; 0x05
     da6:	e0 2d       	mov	r30, r0
     da8:	8c e1       	ldi	r24, 0x1C	; 28
     daa:	09 95       	icall
     dac:	e0 91 87 03 	lds	r30, 0x0387
			bridgeInterface->write(RumbleLargeMotor);//level
     db0:	f0 91 88 03 	lds	r31, 0x0388
     db4:	04 80       	ldd	r0, Z+4	; 0x04
     db6:	f5 81       	ldd	r31, Z+5	; 0x05
     db8:	e0 2d       	mov	r30, r0
     dba:	80 91 50 03 	lds	r24, 0x0350
     dbe:	09 95       	icall
     dc0:	e0 91 87 03 	lds	r30, 0x0387
			bridgeInterface->write((RumbleLargeMotor)?255:0);//255 is 4 seconds max , 0 to stop
     dc4:	f0 91 88 03 	lds	r31, 0x0388
     dc8:	81 e0       	ldi	r24, 0x01	; 1
     dca:	90 91 50 03 	lds	r25, 0x0350
     dce:	91 11       	cpse	r25, r1
     dd0:	01 c0       	rjmp	.+2      	; 0xdd4 <do_LLAPI+0x15c>
     dd2:	80 e0       	ldi	r24, 0x00	; 0
     dd4:	04 80       	ldd	r0, Z+4	; 0x04
     dd6:	f5 81       	ldd	r31, Z+5	; 0x05
     dd8:	e0 2d       	mov	r30, r0
     dda:	81 95       	neg	r24
     ddc:	09 95       	icall
     dde:	e0 91 87 03 	lds	r30, 0x0387
			bridgeInterface->write(0x11);//play effect const
     de2:	f0 91 88 03 	lds	r31, 0x0388
     de6:	04 80       	ldd	r0, Z+4	; 0x04
     de8:	f5 81       	ldd	r31, Z+5	; 0x05
     dea:	e0 2d       	mov	r30, r0
     dec:	81 e1       	ldi	r24, 0x11	; 17
     dee:	09 95       	icall
     df0:	e0 91 87 03 	lds	r30, 0x0387

			bridgeInterface->write(0x1c); //set effect parms
     df4:	f0 91 88 03 	lds	r31, 0x0388
     df8:	04 80       	ldd	r0, Z+4	; 0x04
     dfa:	f5 81       	ldd	r31, Z+5	; 0x05
     dfc:	e0 2d       	mov	r30, r0
     dfe:	8c e1       	ldi	r24, 0x1C	; 28
     e00:	09 95       	icall
     e02:	e0 91 87 03 	lds	r30, 0x0387
			bridgeInterface->write(RumbleSmallMotor);//level
     e06:	f0 91 88 03 	lds	r31, 0x0388
     e0a:	04 80       	ldd	r0, Z+4	; 0x04
     e0c:	f5 81       	ldd	r31, Z+5	; 0x05
     e0e:	e0 2d       	mov	r30, r0
     e10:	80 91 41 03 	lds	r24, 0x0341
     e14:	09 95       	icall
     e16:	e0 91 87 03 	lds	r30, 0x0387
			bridgeInterface->write((RumbleSmallMotor)?255:0);//255 is 4 seconds max , 0 to stop
     e1a:	f0 91 88 03 	lds	r31, 0x0388
     e1e:	81 e0       	ldi	r24, 0x01	; 1
     e20:	90 91 41 03 	lds	r25, 0x0341
     e24:	91 11       	cpse	r25, r1
     e26:	01 c0       	rjmp	.+2      	; 0xe2a <do_LLAPI+0x1b2>
     e28:	80 e0       	ldi	r24, 0x00	; 0
     e2a:	04 80       	ldd	r0, Z+4	; 0x04
     e2c:	f5 81       	ldd	r31, Z+5	; 0x05
     e2e:	e0 2d       	mov	r30, r0
     e30:	81 95       	neg	r24
     e32:	09 95       	icall
     e34:	e0 91 87 03 	lds	r30, 0x0387
			bridgeInterface->write(0x14);//play effect sine
     e38:	f0 91 88 03 	lds	r31, 0x0388
     e3c:	04 80       	ldd	r0, Z+4	; 0x04
     e3e:	f5 81       	ldd	r31, Z+5	; 0x05
     e40:	e0 2d       	mov	r30, r0
     e42:	84 e1       	ldi	r24, 0x14	; 20
     e44:	09 95       	icall
     e46:	80 91 41 03 	lds	r24, 0x0341
			
			//save a combine state
			oldRumbleState = RumbleLargeMotor ^ RumbleSmallMotor; 
     e4a:	90 91 50 03 	lds	r25, 0x0350
     e4e:	89 27       	eor	r24, r25
     e50:	80 93 b8 01 	sts	0x01B8, r24
     e54:	20 91 54 03 	lds	r18, 0x0354
		}
	}

	if ( doMap )
     e58:	30 91 55 03 	lds	r19, 0x0355
     e5c:	21 15       	cp	r18, r1
     e5e:	31 05       	cpc	r19, r1
     e60:	39 f0       	breq	.+14     	; 0xe70 <do_LLAPI+0x1f8>
     e62:	21 50       	subi	r18, 0x01	; 1
	{
		doMap --;
     e64:	31 09       	sbc	r19, r1
     e66:	30 93 55 03 	sts	0x0355, r19
     e6a:	20 93 54 03 	sts	0x0354, r18
     e6e:	2f d1       	rcall	.+606    	; 0x10ce <con_autoMapper>
		con_autoMapper();
     e70:	e0 91 87 03 	lds	r30, 0x0387
	}
	bridgeInterface->write(BRIDGE_CONTROLLER_POLL);//poll later while consol does its thing. 
     e74:	f0 91 88 03 	lds	r31, 0x0388
     e78:	04 80       	ldd	r0, Z+4	; 0x04
     e7a:	f5 81       	ldd	r31, Z+5	; 0x05
     e7c:	e0 2d       	mov	r30, r0
     e7e:	80 e0       	ldi	r24, 0x00	; 0
     e80:	09 95       	icall
     e82:	8c 2f       	mov	r24, r28
     e84:	cf 91       	pop	r28
     e86:	08 95       	ret

00000e88 <main_update>:

	return reply;
}
     e88:	f7 de       	rcall	.-530    	; 0xc78 <do_LLAPI>
     e8a:	90 91 80 03 	lds	r25, 0x0380
void main_update(void)
{ 
	unsigned char type =  do_LLAPI();
 	
	//only report in normal operation. 
	if (! Controller.AutoPaused ) //normal operation
     e8e:	91 11       	cpse	r25, r1
     e90:	28 c0       	rjmp	.+80     	; 0xee2 <main_update+0x5a>
     e92:	80 3f       	cpi	r24, 0xF0	; 240
	{
		if (type >= ERROR_START_VALUE)  //if we get any error 
     e94:	d0 f0       	brcs	.+52     	; 0xeca <main_update+0x42>
     e96:	90 91 45 03 	lds	r25, 0x0345
		{
			if ( (type & BB_ReadBuffer[1] & BB_ReadBuffer[2] ) == 255 )  {} //all data is high case, this is not to be mistakin for AP, its bad data. 
     e9a:	20 91 44 03 	lds	r18, 0x0344
     e9e:	92 23       	and	r25, r18
     ea0:	98 23       	and	r25, r24
     ea2:	9f 3f       	cpi	r25, 0xFF	; 255
     ea4:	29 f0       	breq	.+10     	; 0xeb0 <main_update+0x28>
     ea6:	8f 3f       	cpi	r24, 0xFF	; 255
			else if ( type==  GET_CONTROLLER_STATUS_ERROR_AP_NO_REPORT || type == LLAPI_BUSY_ERROR ) Controller.AutoPaused=true;
     ea8:	19 f4       	brne	.+6      	; 0xeb0 <main_update+0x28>
     eaa:	81 e0       	ldi	r24, 0x01	; 1
     eac:	80 93 80 03 	sts	0x0380, r24
     eb0:	81 e0       	ldi	r24, 0x01	; 1
			else if ( type==GET_CONTROLLER_STATUS_ERROR_NOTREADY) {}//TODO do anythign here? or the same?
			
			Controller.DpadOnly = true; //this need to be reset here so that controller that always detect non digital , issue once dopad only first. (saturn code needs this)
     eb2:	80 93 83 03 	sts	0x0383, r24
     eb6:	8d e0       	ldi	r24, 0x0D	; 13
	
			memcpy (BB_ReadBuffer,BACKUP_ReadBuffer,BB_BUFFER_SIZE); //restore from backup as we were makred as dirty.
     eb8:	e6 e5       	ldi	r30, 0x56	; 86
     eba:	f3 e0       	ldi	r31, 0x03	; 3
     ebc:	a3 e4       	ldi	r26, 0x43	; 67
     ebe:	b3 e0       	ldi	r27, 0x03	; 3
     ec0:	01 90       	ld	r0, Z+
     ec2:	0d 92       	st	X+, r0
     ec4:	8a 95       	dec	r24
     ec6:	e1 f7       	brne	.-8      	; 0xec0 <main_update+0x38>
     ec8:	19 c0       	rjmp	.+50     	; 0xefc <main_update+0x74>
     eca:	9d e0       	ldi	r25, 0x0D	; 13
			type = Controller.Type;// restore from last good type, because putting errors in the type won;t make any sense to the console
		}
		else //no error
		{
		
			memcpy (BACKUP_ReadBuffer,BB_ReadBuffer,BB_BUFFER_SIZE); //make a backup.
     ecc:	e3 e4       	ldi	r30, 0x43	; 67
     ece:	f3 e0       	ldi	r31, 0x03	; 3
     ed0:	a6 e5       	ldi	r26, 0x56	; 86
     ed2:	b3 e0       	ldi	r27, 0x03	; 3
     ed4:	01 90       	ld	r0, Z+
     ed6:	0d 92       	st	X+, r0
     ed8:	9a 95       	dec	r25
     eda:	e1 f7       	brne	.-8      	; 0xed4 <main_update+0x4c>
     edc:	80 93 86 03 	sts	0x0386, r24
			Controller.Type = type; //type is good, set it and back it up.
     ee0:	0d c0       	rjmp	.+26     	; 0xefc <main_update+0x74>
     ee2:	9d e0       	ldi	r25, 0x0D	; 13
		}
	} 
	else  
	{
		memcpy (BB_ReadBuffer,BACKUP_ReadBuffer,BB_BUFFER_SIZE); //restore from backup.
     ee4:	e6 e5       	ldi	r30, 0x56	; 86
     ee6:	f3 e0       	ldi	r31, 0x03	; 3
     ee8:	a3 e4       	ldi	r26, 0x43	; 67
     eea:	b3 e0       	ldi	r27, 0x03	; 3
     eec:	01 90       	ld	r0, Z+
     eee:	0d 92       	st	X+, r0
     ef0:	9a 95       	dec	r25
     ef2:	e1 f7       	brne	.-8      	; 0xeec <main_update+0x64>
     ef4:	80 3f       	cpi	r24, 0xF0	; 240
		if ( type < ERROR_START_VALUE) Controller.AutoPaused = false; //good read so clear ap. 
     ef6:	10 f4       	brcc	.+4      	; 0xefc <main_update+0x74>
     ef8:	10 92 80 03 	sts	0x0380, r1
     efc:	90 91 80 03 	lds	r25, 0x0380
	}
	
	//auto pause
	if ( Controller.AutoPaused && !_autoPausePressed )
     f00:	80 91 52 03 	lds	r24, 0x0352
     f04:	99 23       	and	r25, r25
     f06:	69 f0       	breq	.+26     	; 0xf22 <main_update+0x9a>
     f08:	90 91 44 03 	lds	r25, 0x0344
     f0c:	81 11       	cpse	r24, r1
     f0e:	05 c0       	rjmp	.+10     	; 0xf1a <main_update+0x92>
     f10:	81 e0       	ldi	r24, 0x01	; 1
	{
		_autoPausePressed = true;
     f12:	80 93 52 03 	sts	0x0352, r24
     f16:	90 62       	ori	r25, 0x20	; 32
		BB_ReadBuffer[1] |= 0x20;//press start.  
     f18:	01 c0       	rjmp	.+2      	; 0xf1c <main_update+0x94>
     f1a:	9f 7d       	andi	r25, 0xDF	; 223
	}
	else if ( Controller.AutoPaused &&  _autoPausePressed ) BB_ReadBuffer[1] &= ~0x20;//release start.  			
     f1c:	90 93 44 03 	sts	0x0344, r25
     f20:	0b c0       	rjmp	.+22     	; 0xf38 <main_update+0xb0>
     f22:	88 23       	and	r24, r24
	else if( ! Controller.AutoPaused && _autoPausePressed) 
     f24:	49 f0       	breq	.+18     	; 0xf38 <main_update+0xb0>
     f26:	10 92 52 03 	sts	0x0352, r1
	{
		_autoPausePressed = false; //re-arm
     f2a:	3d de       	rcall	.-902    	; 0xba6 <getInfo>
		getInfo();
     f2c:	8f ef       	ldi	r24, 0xFF	; 255
     f2e:	90 e0       	ldi	r25, 0x00	; 0
		doMap = 255;
     f30:	90 93 55 03 	sts	0x0355, r25
     f34:	80 93 54 03 	sts	0x0354, r24
     f38:	07 d2       	rcall	.+1038   	; 0x1348 <con_clear>
     f3a:	80 91 44 03 	lds	r24, 0x0344
	}
		
	//add this only to where it is needed 
	//mapDefaltCalibration();//note gc does some kind of its own calabration. This seem to only make it worse
	//mapDefultDeadZone();
	con_clear();//not really needed but tidy.
     f3e:	80 93 68 03 	sts	0x0368, r24
			
	
	//global options and/or mappings here.
	reportBuffer[BUTTON_ROW_1]=BB_ReadBuffer[1];
     f42:	80 91 45 03 	lds	r24, 0x0345
     f46:	80 93 69 03 	sts	0x0369, r24
	reportBuffer[BUTTON_ROW_2]=BB_ReadBuffer[2];
     f4a:	80 91 46 03 	lds	r24, 0x0346
     f4e:	80 93 7b 03 	sts	0x037B, r24
	reportBuffer[BUTTON_ROW_3]=BB_ReadBuffer[3];
     f52:	80 91 47 03 	lds	r24, 0x0347
     f56:	80 93 6b 03 	sts	0x036B, r24

	reportBuffer[X_MAIN_STICK]	=BB_ReadBuffer[4];
     f5a:	80 91 48 03 	lds	r24, 0x0348
     f5e:	80 93 6c 03 	sts	0x036C, r24
	reportBuffer[Y_MAIN_STICK]	=BB_ReadBuffer[5];
     f62:	90 91 49 03 	lds	r25, 0x0349
     f66:	90 93 71 03 	sts	0x0371, r25
	
	reportBuffer[LEFT_TRIGGER]	=BB_ReadBuffer[6];
     f6a:	80 91 4a 03 	lds	r24, 0x034A
     f6e:	80 93 6d 03 	sts	0x036D, r24
	
	reportBuffer[X_SECONDARY_STICK]=BB_ReadBuffer[7];
     f72:	80 91 4b 03 	lds	r24, 0x034B
     f76:	80 93 6e 03 	sts	0x036E, r24
	reportBuffer[Y_SECONDARY_STICK]=BB_ReadBuffer[8];
     f7a:	80 91 4c 03 	lds	r24, 0x034C
     f7e:	80 93 72 03 	sts	0x0372, r24
	
	reportBuffer[RIGHT_TRIGGER]	=BB_ReadBuffer[9];
     f82:	20 91 86 03 	lds	r18, 0x0386
     f86:	29 37       	cpi	r18, 0x79	; 121
	
	if (Controller.Type != 121 ) //we do not want the DS2 dal and slider button support for bridge, it really messes up sbes mouse for one
     f88:	41 f0       	breq	.+16     	; 0xf9a <main_update+0x112>
     f8a:	20 91 4d 03 	lds	r18, 0x034D
     f8e:	20 93 70 03 	sts	0x0370, r18
	{
		reportBuffer[SLIDER]=BB_ReadBuffer[10];	
     f92:	20 91 4e 03 	lds	r18, 0x034E
     f96:	20 93 6f 03 	sts	0x036F, r18
		reportBuffer[DIAL]=BB_ReadBuffer[11];
     f9a:	20 91 7f 03 	lds	r18, 0x037F
     f9e:	21 11       	cpse	r18, r1
	}

	//TODO  -  need testing
	//says if the contrller is not a psx (not pressure) then fill in the press with analog triuggers
	//but looks like this is for  only.. so maybe put that in the ps2 code...
	if ( !Controller.Pressure ) //if not pressure data, check L and R 
     fa0:	04 c0       	rjmp	.+8      	; 0xfaa <main_update+0x122>
     fa2:	90 93 3f 03 	sts	0x033F, r25
     fa6:	80 93 40 03 	sts	0x0340, r24
	{
		pressureData[l2__pressure]=(BB_ReadBuffer[6]);
     faa:	80 91 4f 03 	lds	r24, 0x034F
		pressureData[r2__pressure]=(BB_ReadBuffer[9]);
     fae:	80 93 6a 03 	sts	0x036A, r24
	}
	
	reportBuffer[HAT] = BB_ReadBuffer[12] ;		
     fb2:	3d de       	rcall	.-902    	; 0xc2e <checkControllerType>
     fb4:	80 91 67 03 	lds	r24, 0x0367

	checkControllerType( ) ;
     fb8:	83 33       	cpi	r24, 0x33	; 51
     fba:	18 f0       	brcs	.+6      	; 0xfc2 <main_update+0x13a>
	if (modeTimer > 50) { modeTimer =0; getInfo();}//once every so often or if triggered from the above. 
     fbc:	10 92 67 03 	sts	0x0367, r1
     fc0:	f2 dd       	rcall	.-1052   	; 0xba6 <getInfo>
     fc2:	80 91 67 03 	lds	r24, 0x0367
     fc6:	8f 5f       	subi	r24, 0xFF	; 255
     fc8:	80 93 67 03 	sts	0x0367, r24
	modeTimer++;//Just loop over, can set a limit if needed
     fcc:	08 95       	ret

00000fce <main>:
     fce:	10 92 80 03 	sts	0x0380, r1
     fd2:	10 92 52 03 	sts	0x0352, r1
     fd6:	10 92 b8 01 	sts	0x01B8, r1
	unsigned char con=false;		

	Controller.AutoPaused=false;	
	_autoPausePressed = false;
	oldRumbleState =0;
	modeTimer = 0;
     fda:	10 92 67 03 	sts	0x0367, r1
	doMap = 255;
     fde:	8f ef       	ldi	r24, 0xFF	; 255
     fe0:	90 e0       	ldi	r25, 0x00	; 0
     fe2:	90 93 55 03 	sts	0x0355, r25
     fe6:	80 93 54 03 	sts	0x0354, r24

	INIT_HARDWARE();// do hardware init. 
     fea:	80 e8       	ldi	r24, 0x80	; 128
     fec:	80 93 61 00 	sts	0x0061, r24
     ff0:	10 92 61 00 	sts	0x0061, r1
     ff4:	85 b7       	in	r24, 0x35	; 53
     ff6:	80 68       	ori	r24, 0x80	; 128
     ff8:	85 bf       	out	0x35, r24	; 53
     ffa:	85 b7       	in	r24, 0x35	; 53
     ffc:	80 68       	ori	r24, 0x80	; 128
     ffe:	85 bf       	out	0x35, r24	; 53
    1000:	1a b8       	out	0x0a, r1	; 10
    1002:	17 b8       	out	0x07, r1	; 7
    1004:	14 b8       	out	0x04, r1	; 4
    1006:	8f ef       	ldi	r24, 0xFF	; 255
    1008:	8b b9       	out	0x0b, r24	; 11
    100a:	88 b9       	out	0x08, r24	; 8
    100c:	85 b9       	out	0x05, r24	; 5
	con_init();//do the consol init.
    100e:	ad d1       	rcall	.+858    	; 0x136a <con_init>
    1010:	0e 94 c0 29 	call	0x5380	; 0x5380 <USB_Disable>
	// current reducer			  //
	// it is not much but it does //
	// help. USB is the most 	  //
    // significant.		    	  //
	////////////////////////////////
	USB_Disable(); 				 //disable usb
    1014:	80 91 d8 00 	lds	r24, 0x00D8
	USBCON |= _BV(FRZCLK);  
    1018:	80 62       	ori	r24, 0x20	; 32
    101a:	80 93 d8 00 	sts	0x00D8, r24
    101e:	89 b5       	in	r24, 0x29	; 41
	PLLCSR &= ~_BV(PLLE);  
    1020:	8d 7f       	andi	r24, 0xFD	; 253
    1022:	89 bd       	out	0x29, r24	; 41
    1024:	80 91 d8 00 	lds	r24, 0x00D8
	USBCON &= ~_BV(USBE);  
    1028:	8f 77       	andi	r24, 0x7F	; 127
    102a:	80 93 d8 00 	sts	0x00D8, r24
    102e:	1c bc       	out	0x2c, r1	; 44
	 
	ADCSRA =    				 // disable ADC
	UCSR1B=UCSR1A=UCSR1C=		 //diable uart
	SPCR=0;		  				 //disable spi
    1030:	10 92 ca 00 	sts	0x00CA, r1
	USBCON |= _BV(FRZCLK);  
	PLLCSR &= ~_BV(PLLE);  
	USBCON &= ~_BV(USBE);  
	 
	ADCSRA =    				 // disable ADC
	UCSR1B=UCSR1A=UCSR1C=		 //diable uart
    1034:	10 92 c8 00 	sts	0x00C8, r1
    1038:	10 92 c9 00 	sts	0x00C9, r1
    103c:	10 92 7a 00 	sts	0x007A, r1
	USB_Disable(); 				 //disable usb
	USBCON |= _BV(FRZCLK);  
	PLLCSR &= ~_BV(PLLE);  
	USBCON &= ~_BV(USBE);  
	 
	ADCSRA =    				 // disable ADC
    1040:	80 91 bc 00 	lds	r24, 0x00BC
	UCSR1B=UCSR1A=UCSR1C=		 //diable uart
	SPCR=0;		  				 //disable spi
	TWCR &= 0xFF ^ _BV(TWEN);	 // disable I2C	
    1044:	8b 7f       	andi	r24, 0xFB	; 251
    1046:	80 93 bc 00 	sts	0x00BC, r24
    104a:	10 92 c0 00 	sts	0x00C0, r1
		
	TCCR1A =TCCR1B=
	TCCR0A =TCCR0B=
	TCCR3A =TCCR3B=
	TCCR4A =0;//disable all timers. 
    104e:	10 92 91 00 	sts	0x0091, r1
	SPCR=0;		  				 //disable spi
	TWCR &= 0xFF ^ _BV(TWEN);	 // disable I2C	
		
	TCCR1A =TCCR1B=
	TCCR0A =TCCR0B=
	TCCR3A =TCCR3B=
    1052:	10 92 90 00 	sts	0x0090, r1
    1056:	15 bc       	out	0x25, r1	; 37
	UCSR1B=UCSR1A=UCSR1C=		 //diable uart
	SPCR=0;		  				 //disable spi
	TWCR &= 0xFF ^ _BV(TWEN);	 // disable I2C	
		
	TCCR1A =TCCR1B=
	TCCR0A =TCCR0B=
    1058:	14 bc       	out	0x24, r1	; 36
    105a:	10 92 81 00 	sts	0x0081, r1
	ADCSRA =    				 // disable ADC
	UCSR1B=UCSR1A=UCSR1C=		 //diable uart
	SPCR=0;		  				 //disable spi
	TWCR &= 0xFF ^ _BV(TWEN);	 // disable I2C	
		
	TCCR1A =TCCR1B=
    105e:	10 92 80 00 	sts	0x0080, r1
    1062:	2f ef       	ldi	r18, 0xFF	; 255
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1064:	87 ea       	ldi	r24, 0xA7	; 167
    1066:	91 e6       	ldi	r25, 0x61	; 97
    1068:	21 50       	subi	r18, 0x01	; 1
    106a:	80 40       	sbci	r24, 0x00	; 0
    106c:	90 40       	sbci	r25, 0x00	; 0
    106e:	e1 f7       	brne	.-8      	; 0x1068 <main+0x9a>
    1070:	00 c0       	rjmp	.+0      	; 0x1072 <main+0xa4>
    1072:	00 00       	nop
    1074:	8e d1       	rcall	.+796    	; 0x1392 <con_probe>
 
	//list of start up times 
	//: sega needed 1.3 sec
	_delay_ms(2000);  
	
	while ( !con ) {con = con_probe(); } //wait for console to answer. 
    1076:	88 23       	and	r24, r24
    1078:	e9 f3       	breq	.-6      	; 0x1074 <main+0xa6>
    107a:	0e 94 88 29 	call	0x5310	; 0x5310 <getBridgeInterface>

	//set up brdige
	bridgeInterface = getBridgeInterface();
    107e:	90 93 88 03 	sts	0x0388, r25
    1082:	80 93 87 03 	sts	0x0387, r24
    1086:	dc 01       	movw	r26, r24
    1088:	ed 91       	ld	r30, X+
	bridgeInterface->init();
    108a:	fc 91       	ld	r31, X
    108c:	09 95       	icall
    108e:	10 92 b9 01 	sts	0x01B9, r1
	 calX_Main_Min=
	 calY_Main_Min=
	cal2X_Main_Max=
	cal2Y_Main_Max=
	cal2X_Main_Min=
	cal2Y_Main_Min=0;
    1092:	10 92 ba 01 	sts	0x01BA, r1
	 calY_Main_Max=
	 calX_Main_Min=
	 calY_Main_Min=
	cal2X_Main_Max=
	cal2Y_Main_Max=
	cal2X_Main_Min=
    1096:	10 92 bb 01 	sts	0x01BB, r1
	 calX_Main_Max=
	 calY_Main_Max=
	 calX_Main_Min=
	 calY_Main_Min=
	cal2X_Main_Max=
	cal2Y_Main_Max=
    109a:	10 92 bc 01 	sts	0x01BC, r1
{
	 calX_Main_Max=
	 calY_Main_Max=
	 calX_Main_Min=
	 calY_Main_Min=
	cal2X_Main_Max=
    109e:	10 92 bd 01 	sts	0x01BD, r1
static void mapReset( void )
{
	 calX_Main_Max=
	 calY_Main_Max=
	 calX_Main_Min=
	 calY_Main_Min=
    10a2:	10 92 be 01 	sts	0x01BE, r1
static unsigned char oldRumbleState;
static void mapReset( void )
{
	 calX_Main_Max=
	 calY_Main_Max=
	 calX_Main_Min=
    10a6:	10 92 bf 01 	sts	0x01BF, r1
static unsigned char cal2Y_Main_Min;
static unsigned char oldRumbleState;
static void mapReset( void )
{
	 calX_Main_Max=
	 calY_Main_Max=
    10aa:	10 92 c0 01 	sts	0x01C0, r1
static unsigned char cal2X_Main_Min;
static unsigned char cal2Y_Main_Min;
static unsigned char oldRumbleState;
static void mapReset( void )
{
	 calX_Main_Max=
    10ae:	4c d1       	rcall	.+664    	; 0x1348 <con_clear>
    10b0:	e0 91 87 03 	lds	r30, 0x0387
	
	mapReset();  //clear mappings 
	con_clear(); //and data. 
    10b4:	f0 91 88 03 	lds	r31, 0x0388

		
	//initialize the BB and test for controller connected now that we found a console and there are no more long waits. 
	unsigned char init=255;
	bridgeInterface->write(BRIDGE_CONTROLLER_POLL);//must poll
    10b8:	04 80       	ldd	r0, Z+4	; 0x04
    10ba:	f5 81       	ldd	r31, Z+5	; 0x05
    10bc:	e0 2d       	mov	r30, r0
    10be:	80 e0       	ldi	r24, 0x00	; 0
    10c0:	09 95       	icall
    10c2:	da dd       	rcall	.-1100   	; 0xc78 <do_LLAPI>
    10c4:	80 3f       	cpi	r24, 0xF0	; 240
    10c6:	e8 f7       	brcc	.-6      	; 0x10c2 <main+0xf4>
	while ( init >= ERROR_START_VALUE)
	{
		init = do_LLAPI( ) ;
    10c8:	df de       	rcall	.-578    	; 0xe88 <main_update>
    10ca:	5b d1       	rcall	.+694    	; 0x1382 <con_update>

		
	//initialize the BB and test for controller connected now that we found a console and there are no more long waits. 
	unsigned char init=255;
	bridgeInterface->write(BRIDGE_CONTROLLER_POLL);//must poll
	while ( init >= ERROR_START_VALUE)
    10cc:	fd cf       	rjmp	.-6      	; 0x10c8 <main+0xfa>

000010ce <con_autoMapper>:
{//swap code exmaple bridgeInterface->write(0x26);bridgeInterface->write(0x81);bridgeInterface->write(0x44); 

	//if we have a 3/6 button controller, it makes no sense on the diamond, so we map like 
	//L 3 R //La nd R on on top so add the 3 button
	//1 2 4 //these are on the bottom already. 
	if ( is3ButtonConsole(Console.Type) )
    10ce:	80 91 65 03 	lds	r24, 0x0365
    10d2:	98 2f       	mov	r25, r24
    10d4:	9d 7f       	andi	r25, 0xFD	; 253
    10d6:	21 e0       	ldi	r18, 0x01	; 1
    10d8:	99 32       	cpi	r25, 0x29	; 41
    10da:	09 f0       	breq	.+2      	; 0x10de <con_autoMapper+0x10>
    10dc:	20 e0       	ldi	r18, 0x00	; 0
    10de:	91 e0       	ldi	r25, 0x01	; 1
    10e0:	38 2f       	mov	r19, r24
    10e2:	3f 7e       	andi	r19, 0xEF	; 239
    10e4:	35 30       	cpi	r19, 0x05	; 5
    10e6:	09 f0       	breq	.+2      	; 0x10ea <con_autoMapper+0x1c>
    10e8:	90 e0       	ldi	r25, 0x00	; 0
    10ea:	92 2b       	or	r25, r18
    10ec:	e0 91 87 03 	lds	r30, 0x0387
    10f0:	f0 91 88 03 	lds	r31, 0x0388
    10f4:	91 11       	cpse	r25, r1
    10f6:	02 c0       	rjmp	.+4      	; 0x10fc <con_autoMapper+0x2e>
    10f8:	85 32       	cpi	r24, 0x25	; 37
    10fa:	c1 f5       	brne	.+112    	; 0x116c <con_autoMapper+0x9e>
	{
		if( isDiamondController(Controller.Type) 
    10fc:	80 91 86 03 	lds	r24, 0x0386
    1100:	31 e0       	ldi	r19, 0x01	; 1
    1102:	80 31       	cpi	r24, 0x10	; 16
    1104:	09 f0       	breq	.+2      	; 0x1108 <con_autoMapper+0x3a>
    1106:	30 e0       	ldi	r19, 0x00	; 0
    1108:	91 e0       	ldi	r25, 0x01	; 1
    110a:	83 32       	cpi	r24, 0x23	; 35
    110c:	09 f0       	breq	.+2      	; 0x1110 <con_autoMapper+0x42>
    110e:	90 e0       	ldi	r25, 0x00	; 0
    1110:	39 2b       	or	r19, r25
    1112:	91 e0       	ldi	r25, 0x01	; 1
    1114:	8f 31       	cpi	r24, 0x1F	; 31
    1116:	09 f0       	breq	.+2      	; 0x111a <con_autoMapper+0x4c>
    1118:	90 e0       	ldi	r25, 0x00	; 0
    111a:	93 2b       	or	r25, r19
    111c:	31 e0       	ldi	r19, 0x01	; 1
    111e:	8f 32       	cpi	r24, 0x2F	; 47
    1120:	09 f0       	breq	.+2      	; 0x1124 <con_autoMapper+0x56>
    1122:	30 e0       	ldi	r19, 0x00	; 0
    1124:	39 2b       	or	r19, r25
    1126:	21 e0       	ldi	r18, 0x01	; 1
    1128:	81 34       	cpi	r24, 0x41	; 65
    112a:	09 f0       	breq	.+2      	; 0x112e <con_autoMapper+0x60>
    112c:	20 e0       	ldi	r18, 0x00	; 0
    112e:	23 2b       	or	r18, r19
    1130:	91 e0       	ldi	r25, 0x01	; 1
    1132:	89 37       	cpi	r24, 0x79	; 121
    1134:	09 f0       	breq	.+2      	; 0x1138 <con_autoMapper+0x6a>
    1136:	90 e0       	ldi	r25, 0x00	; 0
    1138:	92 2b       	or	r25, r18
    113a:	51 f4       	brne	.+20     	; 0x1150 <con_autoMapper+0x82>
    113c:	98 2f       	mov	r25, r24
    113e:	9f 7d       	andi	r25, 0xDF	; 223
    1140:	93 35       	cpi	r25, 0x53	; 83
    1142:	31 f0       	breq	.+12     	; 0x1150 <con_autoMapper+0x82>
			|| Controller.Type == 9  //GC
    1144:	89 30       	cpi	r24, 0x09	; 9
    1146:	21 f0       	breq	.+8      	; 0x1150 <con_autoMapper+0x82>
			|| Controller.Type == 19  //n64
    1148:	87 7f       	andi	r24, 0xF7	; 247
    114a:	83 31       	cpi	r24, 0x13	; 19
    114c:	09 f0       	breq	.+2      	; 0x1150 <con_autoMapper+0x82>
    114e:	9b c0       	rjmp	.+310    	; 0x1286 <con_autoMapper+0x1b8>
		)
		{
			bridgeInterface->write(0x24); bridgeInterface->write(0x04); //alt mode
    1150:	04 80       	ldd	r0, Z+4	; 0x04
    1152:	f5 81       	ldd	r31, Z+5	; 0x05
    1154:	e0 2d       	mov	r30, r0
    1156:	84 e2       	ldi	r24, 0x24	; 36
    1158:	09 95       	icall
    115a:	e0 91 87 03 	lds	r30, 0x0387
    115e:	f0 91 88 03 	lds	r31, 0x0388
    1162:	04 80       	ldd	r0, Z+4	; 0x04
    1164:	f5 81       	ldd	r31, Z+5	; 0x05
    1166:	e0 2d       	mov	r30, r0
    1168:	84 e0       	ldi	r24, 0x04	; 4
    116a:	8c c0       	rjmp	.+280    	; 0x1284 <con_autoMapper+0x1b6>
			
		}
	}
	else if( isDiamondConsole(Console.Type) )
    116c:	21 e0       	ldi	r18, 0x01	; 1
    116e:	89 31       	cpi	r24, 0x19	; 25
    1170:	09 f0       	breq	.+2      	; 0x1174 <con_autoMapper+0xa6>
    1172:	20 e0       	ldi	r18, 0x00	; 0
    1174:	91 e0       	ldi	r25, 0x01	; 1
    1176:	8f 32       	cpi	r24, 0x2F	; 47
    1178:	09 f0       	breq	.+2      	; 0x117c <con_autoMapper+0xae>
    117a:	90 e0       	ldi	r25, 0x00	; 0
    117c:	29 2b       	or	r18, r25
    117e:	91 e0       	ldi	r25, 0x01	; 1
    1180:	8f 31       	cpi	r24, 0x1F	; 31
    1182:	09 f0       	breq	.+2      	; 0x1186 <con_autoMapper+0xb8>
    1184:	90 e0       	ldi	r25, 0x00	; 0
    1186:	92 2b       	or	r25, r18
    1188:	21 f4       	brne	.+8      	; 0x1192 <con_autoMapper+0xc4>
    118a:	98 2f       	mov	r25, r24
    118c:	9b 7f       	andi	r25, 0xFB	; 251
    118e:	93 31       	cpi	r25, 0x13	; 19
    1190:	61 f5       	brne	.+88     	; 0x11ea <con_autoMapper+0x11c>
	{
		if (is3ButtonController(Controller.Type) ||  Controller.Type == 9 || Controller.Type == 19) {bridgeInterface->write(0x25); bridgeInterface->write(0x03); }//n64, gc, 6 button rotate 3
    1192:	80 91 86 03 	lds	r24, 0x0386
    1196:	98 2f       	mov	r25, r24
    1198:	97 7f       	andi	r25, 0xF7	; 247
    119a:	31 e0       	ldi	r19, 0x01	; 1
    119c:	93 30       	cpi	r25, 0x03	; 3
    119e:	09 f0       	breq	.+2      	; 0x11a2 <con_autoMapper+0xd4>
    11a0:	30 e0       	ldi	r19, 0x00	; 0
    11a2:	98 2f       	mov	r25, r24
    11a4:	9f 7e       	andi	r25, 0xEF	; 239
    11a6:	98 50       	subi	r25, 0x08	; 8
    11a8:	21 e0       	ldi	r18, 0x01	; 1
    11aa:	92 30       	cpi	r25, 0x02	; 2
    11ac:	08 f0       	brcs	.+2      	; 0x11b0 <con_autoMapper+0xe2>
    11ae:	20 e0       	ldi	r18, 0x00	; 0
    11b0:	23 2b       	or	r18, r19
    11b2:	91 e0       	ldi	r25, 0x01	; 1
    11b4:	38 2f       	mov	r19, r24
    11b6:	3b 7f       	andi	r19, 0xFB	; 251
    11b8:	31 32       	cpi	r19, 0x21	; 33
    11ba:	09 f0       	breq	.+2      	; 0x11be <con_autoMapper+0xf0>
    11bc:	90 e0       	ldi	r25, 0x00	; 0
    11be:	92 2b       	or	r25, r18
    11c0:	31 f4       	brne	.+12     	; 0x11ce <con_autoMapper+0x100>
    11c2:	88 32       	cpi	r24, 0x28	; 40
    11c4:	21 f0       	breq	.+8      	; 0x11ce <con_autoMapper+0x100>
    11c6:	83 51       	subi	r24, 0x13	; 19
    11c8:	83 30       	cpi	r24, 0x03	; 3
    11ca:	08 f0       	brcs	.+2      	; 0x11ce <con_autoMapper+0x100>
    11cc:	5c c0       	rjmp	.+184    	; 0x1286 <con_autoMapper+0x1b8>
    11ce:	04 80       	ldd	r0, Z+4	; 0x04
    11d0:	f5 81       	ldd	r31, Z+5	; 0x05
    11d2:	e0 2d       	mov	r30, r0
    11d4:	85 e2       	ldi	r24, 0x25	; 37
    11d6:	09 95       	icall
    11d8:	e0 91 87 03 	lds	r30, 0x0387
    11dc:	f0 91 88 03 	lds	r31, 0x0388
    11e0:	04 80       	ldd	r0, Z+4	; 0x04
    11e2:	f5 81       	ldd	r31, Z+5	; 0x05
    11e4:	e0 2d       	mov	r30, r0
    11e6:	83 e0       	ldi	r24, 0x03	; 3
    11e8:	4d c0       	rjmp	.+154    	; 0x1284 <con_autoMapper+0x1b6>
	}
	
	else if ( Console.Type == N64)
    11ea:	83 32       	cpi	r24, 0x23	; 35
    11ec:	09 f0       	breq	.+2      	; 0x11f0 <con_autoMapper+0x122>
    11ee:	44 c0       	rjmp	.+136    	; 0x1278 <con_autoMapper+0x1aa>
	{
		// to make tg16 6 or pc-fx  work right we need to make a new map  as it already has a special one for down.
		// this seems like such an edge case that it is not worth it unless users compain. but who has a pc-fx? or a 6 button tg16 really?
		// If  we gfree up enough space on the BB we can do this.															||               ||
		if ( is3ButtonController(Controller.Type) || Controller.Type == 54 || Controller.Type == 26) //needs a  layout like the n64
    11f0:	80 91 86 03 	lds	r24, 0x0386
    11f4:	98 2f       	mov	r25, r24
    11f6:	97 7f       	andi	r25, 0xF7	; 247
    11f8:	21 e0       	ldi	r18, 0x01	; 1
    11fa:	93 30       	cpi	r25, 0x03	; 3
    11fc:	09 f0       	breq	.+2      	; 0x1200 <con_autoMapper+0x132>
    11fe:	20 e0       	ldi	r18, 0x00	; 0
    1200:	91 e0       	ldi	r25, 0x01	; 1
    1202:	38 2f       	mov	r19, r24
    1204:	3f 7d       	andi	r19, 0xDF	; 223
    1206:	38 30       	cpi	r19, 0x08	; 8
    1208:	09 f0       	breq	.+2      	; 0x120c <con_autoMapper+0x13e>
    120a:	90 e0       	ldi	r25, 0x00	; 0
    120c:	92 2b       	or	r25, r18
    120e:	21 e0       	ldi	r18, 0x01	; 1
    1210:	3c ee       	ldi	r19, 0xEC	; 236
    1212:	38 0f       	add	r19, r24
    1214:	32 30       	cpi	r19, 0x02	; 2
    1216:	08 f0       	brcs	.+2      	; 0x121a <con_autoMapper+0x14c>
    1218:	20 e0       	ldi	r18, 0x00	; 0
    121a:	29 2b       	or	r18, r25
    121c:	91 e0       	ldi	r25, 0x01	; 1
    121e:	38 ee       	ldi	r19, 0xE8	; 232
    1220:	38 0f       	add	r19, r24
    1222:	33 30       	cpi	r19, 0x03	; 3
    1224:	08 f0       	brcs	.+2      	; 0x1228 <con_autoMapper+0x15a>
    1226:	90 e0       	ldi	r25, 0x00	; 0
    1228:	92 2b       	or	r25, r18
    122a:	31 f4       	brne	.+12     	; 0x1238 <con_autoMapper+0x16a>
    122c:	98 2f       	mov	r25, r24
    122e:	9b 7f       	andi	r25, 0xFB	; 251
    1230:	91 32       	cpi	r25, 0x21	; 33
    1232:	11 f0       	breq	.+4      	; 0x1238 <con_autoMapper+0x16a>
    1234:	86 33       	cpi	r24, 0x36	; 54
    1236:	39 f5       	brne	.+78     	; 0x1286 <con_autoMapper+0x1b8>
		{
			bridgeInterface->write(ALT_MAP);bridgeInterface->write(0x04);  //alt mode to move X and Z to L and R	
    1238:	04 80       	ldd	r0, Z+4	; 0x04
    123a:	f5 81       	ldd	r31, Z+5	; 0x05
    123c:	e0 2d       	mov	r30, r0
    123e:	84 e2       	ldi	r24, 0x24	; 36
    1240:	09 95       	icall
    1242:	e0 91 87 03 	lds	r30, 0x0387
    1246:	f0 91 88 03 	lds	r31, 0x0388
    124a:	04 80       	ldd	r0, Z+4	; 0x04
    124c:	f5 81       	ldd	r31, Z+5	; 0x05
    124e:	e0 2d       	mov	r30, r0
    1250:	84 e0       	ldi	r24, 0x04	; 4
    1252:	09 95       	icall
			bridgeInterface->write(ROTATION);bridgeInterface->write(0x01); 	// buttton rotate 
    1254:	e0 91 87 03 	lds	r30, 0x0387
    1258:	f0 91 88 03 	lds	r31, 0x0388
    125c:	04 80       	ldd	r0, Z+4	; 0x04
    125e:	f5 81       	ldd	r31, Z+5	; 0x05
    1260:	e0 2d       	mov	r30, r0
    1262:	85 e2       	ldi	r24, 0x25	; 37
    1264:	09 95       	icall
    1266:	e0 91 87 03 	lds	r30, 0x0387
    126a:	f0 91 88 03 	lds	r31, 0x0388
    126e:	04 80       	ldd	r0, Z+4	; 0x04
    1270:	f5 81       	ldd	r31, Z+5	; 0x05
    1272:	e0 2d       	mov	r30, r0
    1274:	81 e0       	ldi	r24, 0x01	; 1
    1276:	06 c0       	rjmp	.+12     	; 0x1284 <con_autoMapper+0x1b6>
		}

	}
	
	//for any consoles that we want UDLR perminently. 
	else if (Console.Type == A5200) 	bridgeInterface->write(MODE_WRITE);bridgeInterface->write(MODE_UDLR); 
    1278:	8b 30       	cpi	r24, 0x0B	; 11
    127a:	29 f4       	brne	.+10     	; 0x1286 <con_autoMapper+0x1b8>
    127c:	04 80       	ldd	r0, Z+4	; 0x04
    127e:	f5 81       	ldd	r31, Z+5	; 0x05
    1280:	e0 2d       	mov	r30, r0
    1282:	80 e2       	ldi	r24, 0x20	; 32
    1284:	09 95       	icall
    1286:	e0 91 87 03 	lds	r30, 0x0387
    128a:	f0 91 88 03 	lds	r31, 0x0388
    128e:	04 80       	ldd	r0, Z+4	; 0x04
    1290:	f5 81       	ldd	r31, Z+5	; 0x05
    1292:	e0 2d       	mov	r30, r0
    1294:	80 e1       	ldi	r24, 0x10	; 16
    1296:	09 94       	ijmp

00001298 <con_anagloToDigital>:
}


void con_anagloToDigital( void)
{
	     if ( ANALOG_UP   && ANALOG_LEFT ) reportBuffer[HAT] = DPAD_UPLEFT; 
    1298:	40 91 6c 03 	lds	r20, 0x036C
    129c:	90 91 6e 03 	lds	r25, 0x036E
    12a0:	21 e0       	ldi	r18, 0x01	; 1
    12a2:	9e 34       	cpi	r25, 0x4E	; 78
    12a4:	08 f0       	brcs	.+2      	; 0x12a8 <con_anagloToDigital+0x10>
    12a6:	20 e0       	ldi	r18, 0x00	; 0
    12a8:	81 e0       	ldi	r24, 0x01	; 1
    12aa:	4e 34       	cpi	r20, 0x4E	; 78
    12ac:	08 f0       	brcs	.+2      	; 0x12b0 <con_anagloToDigital+0x18>
    12ae:	80 e0       	ldi	r24, 0x00	; 0
    12b0:	28 2b       	or	r18, r24
    12b2:	80 91 6d 03 	lds	r24, 0x036D
    12b6:	22 23       	and	r18, r18
    12b8:	41 f0       	breq	.+16     	; 0x12ca <con_anagloToDigital+0x32>
    12ba:	8e 34       	cpi	r24, 0x4E	; 78
    12bc:	20 f0       	brcs	.+8      	; 0x12c6 <con_anagloToDigital+0x2e>
    12be:	30 91 6b 03 	lds	r19, 0x036B
    12c2:	3e 34       	cpi	r19, 0x4E	; 78
    12c4:	10 f4       	brcc	.+4      	; 0x12ca <con_anagloToDigital+0x32>
    12c6:	87 e0       	ldi	r24, 0x07	; 7
    12c8:	3c c0       	rjmp	.+120    	; 0x1342 <con_anagloToDigital+0xaa>
	else if ( ANALOG_DOWN && ANALOG_LEFT ) reportBuffer[HAT] = DPAD_DOWNLEFT; 
    12ca:	31 e0       	ldi	r19, 0x01	; 1
    12cc:	93 3b       	cpi	r25, 0xB3	; 179
    12ce:	08 f4       	brcc	.+2      	; 0x12d2 <con_anagloToDigital+0x3a>
    12d0:	30 e0       	ldi	r19, 0x00	; 0
    12d2:	91 e0       	ldi	r25, 0x01	; 1
    12d4:	43 3b       	cpi	r20, 0xB3	; 179
    12d6:	08 f4       	brcc	.+2      	; 0x12da <con_anagloToDigital+0x42>
    12d8:	90 e0       	ldi	r25, 0x00	; 0
    12da:	93 2b       	or	r25, r19
    12dc:	41 f0       	breq	.+16     	; 0x12ee <con_anagloToDigital+0x56>
    12de:	8e 34       	cpi	r24, 0x4E	; 78
    12e0:	20 f0       	brcs	.+8      	; 0x12ea <con_anagloToDigital+0x52>
    12e2:	30 91 6b 03 	lds	r19, 0x036B
    12e6:	3e 34       	cpi	r19, 0x4E	; 78
    12e8:	10 f4       	brcc	.+4      	; 0x12ee <con_anagloToDigital+0x56>
    12ea:	85 e0       	ldi	r24, 0x05	; 5
    12ec:	2a c0       	rjmp	.+84     	; 0x1342 <con_anagloToDigital+0xaa>
	else if ( ANALOG_UP   && ANALOG_RIGHT) reportBuffer[HAT] = DPAD_UPRIGHT; 
    12ee:	22 23       	and	r18, r18
    12f0:	41 f0       	breq	.+16     	; 0x1302 <con_anagloToDigital+0x6a>
    12f2:	83 3b       	cpi	r24, 0xB3	; 179
    12f4:	20 f4       	brcc	.+8      	; 0x12fe <con_anagloToDigital+0x66>
    12f6:	30 91 6b 03 	lds	r19, 0x036B
    12fa:	33 3b       	cpi	r19, 0xB3	; 179
    12fc:	10 f0       	brcs	.+4      	; 0x1302 <con_anagloToDigital+0x6a>
    12fe:	81 e0       	ldi	r24, 0x01	; 1
    1300:	20 c0       	rjmp	.+64     	; 0x1342 <con_anagloToDigital+0xaa>
	else if ( ANALOG_DOWN && ANALOG_RIGHT) reportBuffer[HAT] = DPAD_DOWNRIGHT; 
    1302:	99 23       	and	r25, r25
    1304:	41 f0       	breq	.+16     	; 0x1316 <con_anagloToDigital+0x7e>
    1306:	83 3b       	cpi	r24, 0xB3	; 179
    1308:	20 f4       	brcc	.+8      	; 0x1312 <con_anagloToDigital+0x7a>
    130a:	30 91 6b 03 	lds	r19, 0x036B
    130e:	33 3b       	cpi	r19, 0xB3	; 179
    1310:	10 f0       	brcs	.+4      	; 0x1316 <con_anagloToDigital+0x7e>
    1312:	83 e0       	ldi	r24, 0x03	; 3
    1314:	16 c0       	rjmp	.+44     	; 0x1342 <con_anagloToDigital+0xaa>
	else if	( ANALOG_LEFT 				)  reportBuffer[HAT] = DPAD_LEFT;
    1316:	30 91 6b 03 	lds	r19, 0x036B
    131a:	8e 34       	cpi	r24, 0x4E	; 78
    131c:	10 f0       	brcs	.+4      	; 0x1322 <con_anagloToDigital+0x8a>
    131e:	3e 34       	cpi	r19, 0x4E	; 78
    1320:	10 f4       	brcc	.+4      	; 0x1326 <con_anagloToDigital+0x8e>
    1322:	86 e0       	ldi	r24, 0x06	; 6
    1324:	0e c0       	rjmp	.+28     	; 0x1342 <con_anagloToDigital+0xaa>
	else if ( ANALOG_RIGHT 				)  reportBuffer[HAT] = DPAD_RIGHT;
    1326:	83 3b       	cpi	r24, 0xB3	; 179
    1328:	10 f4       	brcc	.+4      	; 0x132e <con_anagloToDigital+0x96>
    132a:	33 3b       	cpi	r19, 0xB3	; 179
    132c:	10 f0       	brcs	.+4      	; 0x1332 <con_anagloToDigital+0x9a>
    132e:	82 e0       	ldi	r24, 0x02	; 2
    1330:	08 c0       	rjmp	.+16     	; 0x1342 <con_anagloToDigital+0xaa>
	else if ( ANALOG_UP 				)  reportBuffer[HAT] = DPAD_UP;
    1332:	22 23       	and	r18, r18
    1334:	19 f0       	breq	.+6      	; 0x133c <con_anagloToDigital+0xa4>
    1336:	10 92 6a 03 	sts	0x036A, r1
    133a:	08 95       	ret
	else if ( ANALOG_DOWN 				)  reportBuffer[HAT] = DPAD_DOWN;
    133c:	99 23       	and	r25, r25
    133e:	19 f0       	breq	.+6      	; 0x1346 <con_anagloToDigital+0xae>
    1340:	84 e0       	ldi	r24, 0x04	; 4
    1342:	80 93 6a 03 	sts	0x036A, r24
    1346:	08 95       	ret

00001348 <con_clear>:

void con_clear() 
{
	//buttons
	reportBuffer[BUTTON_ROW_1]=
	reportBuffer[BUTTON_ROW_2]=0;
    1348:	10 92 69 03 	sts	0x0369, r1


void con_clear() 
{
	//buttons
	reportBuffer[BUTTON_ROW_1]=
    134c:	10 92 68 03 	sts	0x0368, r1
	reportBuffer[BUTTON_ROW_2]=0;

	//hat
	reportBuffer[HAT]=0x0f;//this is 0xff in Bliss-Box code.
    1350:	8f e0       	ldi	r24, 0x0F	; 15
    1352:	80 93 6a 03 	sts	0x036A, r24

	reportBuffer[X_MAIN_STICK]=
	reportBuffer[Y_MAIN_STICK]= 
	reportBuffer[X_SECONDARY_STICK]=
	reportBuffer[Y_SECONDARY_STICK]=128;
    1356:	80 e8       	ldi	r24, 0x80	; 128
    1358:	80 93 6e 03 	sts	0x036E, r24
	//hat
	reportBuffer[HAT]=0x0f;//this is 0xff in Bliss-Box code.

	reportBuffer[X_MAIN_STICK]=
	reportBuffer[Y_MAIN_STICK]= 
	reportBuffer[X_SECONDARY_STICK]=
    135c:	80 93 6d 03 	sts	0x036D, r24

	//hat
	reportBuffer[HAT]=0x0f;//this is 0xff in Bliss-Box code.

	reportBuffer[X_MAIN_STICK]=
	reportBuffer[Y_MAIN_STICK]= 
    1360:	80 93 6c 03 	sts	0x036C, r24
	reportBuffer[BUTTON_ROW_2]=0;

	//hat
	reportBuffer[HAT]=0x0f;//this is 0xff in Bliss-Box code.

	reportBuffer[X_MAIN_STICK]=
    1364:	80 93 6b 03 	sts	0x036B, r24
    1368:	08 95       	ret

0000136a <con_init>:
}

void con_init() 
{
	//kill WD states
	MCUSR =0;
    136a:	14 be       	out	0x34, r1	; 52
	wdt_reset();
    136c:	a8 95       	wdr
	wdt_disable();
    136e:	88 e1       	ldi	r24, 0x18	; 24
    1370:	0f b6       	in	r0, 0x3f	; 63
    1372:	f8 94       	cli
    1374:	80 93 60 00 	sts	0x0060, r24
    1378:	10 92 60 00 	sts	0x0060, r1
    137c:	0f be       	out	0x3f, r0	; 63
	cli();
    137e:	f8 94       	cli
    1380:	08 95       	ret

00001382 <con_update>:
}

void con_update()
{
	curConsole->update();
    1382:	e0 91 7c 03 	lds	r30, 0x037C
    1386:	f0 91 7d 03 	lds	r31, 0x037D
    138a:	02 80       	ldd	r0, Z+2	; 0x02
    138c:	f3 81       	ldd	r31, Z+3	; 0x03
    138e:	e0 2d       	mov	r30, r0
    1390:	09 94       	ijmp

00001392 <con_probe>:
}


unsigned char con_probe()
{
    1392:	0f 93       	push	r16
    1394:	1f 93       	push	r17
    1396:	cf 93       	push	r28
    1398:	df 93       	push	r29
    139a:	1f 92       	push	r1
    139c:	cd b7       	in	r28, 0x3d	; 61
    139e:	de b7       	in	r29, 0x3e	; 62
 
	//a WTD can never be good as a reset while a button is held down will go to false detectoin. Better to use our own timers.
	Console.Pressure = Console.Rumble = false;
    13a0:	10 92 63 03 	sts	0x0363, r1
    13a4:	10 92 64 03 	sts	0x0364, r1
	//5200 - does not use a key but one of the B port will be high. Also the D 1,2 are going up and down. So must be here.
	//also seem PSX gets stuck. 
	RESET_PORTS();
    13a8:	1a b8       	out	0x0a, r1	; 10
    13aa:	17 b8       	out	0x07, r1	; 7
    13ac:	14 b8       	out	0x04, r1	; 4
    13ae:	0f ef       	ldi	r16, 0xFF	; 255
    13b0:	0b b9       	out	0x0b, r16	; 11
    13b2:	08 b9       	out	0x08, r16	; 8
    13b4:	05 b9       	out	0x05, r16	; 5
	curConsole = a5200GetConsole();  curConsole->init();
    13b6:	0e 94 5c 28 	call	0x50b8	; 0x50b8 <a5200GetConsole>
    13ba:	90 93 7d 03 	sts	0x037D, r25
    13be:	80 93 7c 03 	sts	0x037C, r24
    13c2:	dc 01       	movw	r26, r24
    13c4:	ed 91       	ld	r30, X+
    13c6:	fc 91       	ld	r31, X
    13c8:	09 95       	icall
	if (Console.Type = curConsole->probe() )   { return true; }
    13ca:	e0 91 7c 03 	lds	r30, 0x037C
    13ce:	f0 91 7d 03 	lds	r31, 0x037D
    13d2:	04 80       	ldd	r0, Z+4	; 0x04
    13d4:	f5 81       	ldd	r31, Z+5	; 0x05
    13d6:	e0 2d       	mov	r30, r0
    13d8:	09 95       	icall
    13da:	80 93 65 03 	sts	0x0365, r24
    13de:	81 11       	cpse	r24, r1
    13e0:	5a c0       	rjmp	.+180    	; 0x1496 <con_probe+0x104>
	else curConsole->cleanUp() ;
    13e2:	e0 91 7c 03 	lds	r30, 0x037C
    13e6:	f0 91 7d 03 	lds	r31, 0x037D
    13ea:	00 84       	ldd	r0, Z+8	; 0x08
    13ec:	f1 85       	ldd	r31, Z+9	; 0x09
    13ee:	e0 2d       	mov	r30, r0
    13f0:	09 95       	icall
	
	//controller that use lines on pinB can not check for key, the sate of the wires is unknown.
	{
		//psx 
		curConsole = psxGetConsole();  curConsole->init();	
    13f2:	85 d4       	rcall	.+2314   	; 0x1cfe <psxGetConsole>
    13f4:	90 93 7d 03 	sts	0x037D, r25
    13f8:	80 93 7c 03 	sts	0x037C, r24
    13fc:	dc 01       	movw	r26, r24
    13fe:	ed 91       	ld	r30, X+
    1400:	fc 91       	ld	r31, X
    1402:	09 95       	icall
    1404:	e0 91 7c 03 	lds	r30, 0x037C
		if ( (Console.Type = curConsole->probe() ) )   { Console.Pressure = Console.Rumble = true; return true;}
    1408:	f0 91 7d 03 	lds	r31, 0x037D
    140c:	04 80       	ldd	r0, Z+4	; 0x04
    140e:	f5 81       	ldd	r31, Z+5	; 0x05
    1410:	e0 2d       	mov	r30, r0
    1412:	09 95       	icall
    1414:	80 93 65 03 	sts	0x0365, r24
    1418:	88 23       	and	r24, r24
    141a:	31 f0       	breq	.+12     	; 0x1428 <con_probe+0x96>
    141c:	81 e0       	ldi	r24, 0x01	; 1
    141e:	80 93 63 03 	sts	0x0363, r24
    1422:	80 93 64 03 	sts	0x0364, r24
    1426:	4e c1       	rjmp	.+668    	; 0x16c4 <con_probe+0x332>
    1428:	1a b8       	out	0x0a, r1	; 10

 
		//jaguar in some menues holds down pin8 but opther times not. Also it will go  low on 9,10,11 when polling. 
		RESET_PORTS();	
    142a:	17 b8       	out	0x07, r1	; 7
    142c:	14 b8       	out	0x04, r1	; 4
    142e:	0b b9       	out	0x0b, r16	; 11
    1430:	08 b9       	out	0x08, r16	; 8
    1432:	05 b9       	out	0x05, r16	; 5
    1434:	0e 94 b3 24 	call	0x4966	; 0x4966 <jagGetConsole>
		curConsole = jagGetConsole();  curConsole->init();
    1438:	90 93 7d 03 	sts	0x037D, r25
    143c:	80 93 7c 03 	sts	0x037C, r24
    1440:	dc 01       	movw	r26, r24
    1442:	ed 91       	ld	r30, X+
    1444:	fc 91       	ld	r31, X
    1446:	09 95       	icall
    1448:	e0 91 7c 03 	lds	r30, 0x037C
		if (Console.Type = curConsole->probe() )   {return true; }		  
    144c:	f0 91 7d 03 	lds	r31, 0x037D
    1450:	04 80       	ldd	r0, Z+4	; 0x04
    1452:	f5 81       	ldd	r31, Z+5	; 0x05
    1454:	e0 2d       	mov	r30, r0
    1456:	09 95       	icall
    1458:	80 93 65 03 	sts	0x0365, r24
    145c:	81 11       	cpse	r24, r1
    145e:	1b c0       	rjmp	.+54     	; 0x1496 <con_probe+0x104>
    1460:	e0 91 7c 03 	lds	r30, 0x037C
		else curConsole->cleanUp() ;		
    1464:	f0 91 7d 03 	lds	r31, 0x037D
    1468:	00 84       	ldd	r0, Z+8	; 0x08
    146a:	f1 85       	ldd	r31, Z+9	; 0x09
    146c:	e0 2d       	mov	r30, r0
    146e:	09 95       	icall
    1470:	89 b1       	in	r24, 0x09	; 9
	}
 	
		 
 	if ( (unsigned char )(~PIND)  ==  (unsigned char )0x03 )   // no pins free on B port so key is on D (pd0,pd1)
    1472:	8c 3f       	cpi	r24, 0xFC	; 252
    1474:	91 f4       	brne	.+36     	; 0x149a <con_probe+0x108>
    1476:	1a b8       	out	0x0a, r1	; 10
	{
		//int
		RESET_PORTS();	
    1478:	17 b8       	out	0x07, r1	; 7
    147a:	14 b8       	out	0x04, r1	; 4
    147c:	0b b9       	out	0x0b, r16	; 11
    147e:	08 b9       	out	0x08, r16	; 8
    1480:	05 b9       	out	0x05, r16	; 5
    1482:	0e 94 85 26 	call	0x4d0a	; 0x4d0a <intlGetConsole>
		curConsole = intlGetConsole();  curConsole->init();  return true; //nothing to detect. 
    1486:	90 93 7d 03 	sts	0x037D, r25
    148a:	80 93 7c 03 	sts	0x037C, r24
    148e:	dc 01       	movw	r26, r24
    1490:	ed 91       	ld	r30, X+
    1492:	fc 91       	ld	r31, X
    1494:	09 95       	icall
    1496:	81 e0       	ldi	r24, 0x01	; 1
    1498:	15 c1       	rjmp	.+554    	; 0x16c4 <con_probe+0x332>
    149a:	13 b1       	in	r17, 0x03	; 3
		//if (Console.Type = curConsole->probe() )   { return true; }
		//else curConsole->cleanUp() ;
	}

 	if ((unsigned char )(~PINB)  ==  (unsigned char )0x00) //no key section.  NOTE!!! check debug as that will prevent  going in here. 
    149c:	1f 3f       	cpi	r17, 0xFF	; 255
    149e:	09 f0       	breq	.+2      	; 0x14a2 <con_probe+0x110>
    14a0:	e6 c0       	rjmp	.+460    	; 0x166e <con_probe+0x2dc>
    14a2:	1a b8       	out	0x0a, r1	; 10
	{

		//(s)nes
		RESET_PORTS();
    14a4:	17 b8       	out	0x07, r1	; 7
    14a6:	14 b8       	out	0x04, r1	; 4
    14a8:	1b b9       	out	0x0b, r17	; 11
    14aa:	18 b9       	out	0x08, r17	; 8
    14ac:	15 b9       	out	0x05, r17	; 5
    14ae:	0e 94 ba 1e 	call	0x3d74	; 0x3d74 <nesGetConsole>
		curConsole = nesGetConsole();  curConsole->init();
    14b2:	90 93 7d 03 	sts	0x037D, r25
    14b6:	80 93 7c 03 	sts	0x037C, r24
    14ba:	dc 01       	movw	r26, r24
    14bc:	ed 91       	ld	r30, X+
    14be:	fc 91       	ld	r31, X
    14c0:	09 95       	icall
    14c2:	e0 91 7c 03 	lds	r30, 0x037C
		if ( Console.Type =  curConsole->probe() )   {return true; }
    14c6:	f0 91 7d 03 	lds	r31, 0x037D
    14ca:	04 80       	ldd	r0, Z+4	; 0x04
    14cc:	f5 81       	ldd	r31, Z+5	; 0x05
    14ce:	e0 2d       	mov	r30, r0
    14d0:	09 95       	icall
    14d2:	80 93 65 03 	sts	0x0365, r24
    14d6:	81 11       	cpse	r24, r1
    14d8:	de cf       	rjmp	.-68     	; 0x1496 <con_probe+0x104>
    14da:	e0 91 7c 03 	lds	r30, 0x037C
		else curConsole->cleanUp() ;
    14de:	f0 91 7d 03 	lds	r31, 0x037D
    14e2:	00 84       	ldd	r0, Z+8	; 0x08
    14e4:	f1 85       	ldd	r31, Z+9	; 0x09
    14e6:	e0 2d       	mov	r30, r0
    14e8:	09 95       	icall
    14ea:	1a b8       	out	0x0a, r1	; 10

		//gc
		RESET_PORTS();
    14ec:	17 b8       	out	0x07, r1	; 7
    14ee:	14 b8       	out	0x04, r1	; 4
    14f0:	1b b9       	out	0x0b, r17	; 11
    14f2:	18 b9       	out	0x08, r17	; 8
    14f4:	15 b9       	out	0x05, r17	; 5
    14f6:	0e 94 16 16 	call	0x2c2c	; 0x2c2c <gcGetConsole>
		curConsole = gcGetConsole();  curConsole->init();
    14fa:	90 93 7d 03 	sts	0x037D, r25
    14fe:	80 93 7c 03 	sts	0x037C, r24
    1502:	dc 01       	movw	r26, r24
    1504:	ed 91       	ld	r30, X+
    1506:	fc 91       	ld	r31, X
    1508:	09 95       	icall
    150a:	e0 91 7c 03 	lds	r30, 0x037C
		if (Console.Type = curConsole->probe() )   {Console.Rumble = true; return true; }
    150e:	f0 91 7d 03 	lds	r31, 0x037D
    1512:	04 80       	ldd	r0, Z+4	; 0x04
    1514:	f5 81       	ldd	r31, Z+5	; 0x05
    1516:	e0 2d       	mov	r30, r0
    1518:	09 95       	icall
    151a:	80 93 65 03 	sts	0x0365, r24
    151e:	81 11       	cpse	r24, r1
    1520:	24 c0       	rjmp	.+72     	; 0x156a <con_probe+0x1d8>
    1522:	e0 91 7c 03 	lds	r30, 0x037C
		else curConsole->cleanUp() ;
    1526:	f0 91 7d 03 	lds	r31, 0x037D
    152a:	00 84       	ldd	r0, Z+8	; 0x08
    152c:	f1 85       	ldd	r31, Z+9	; 0x09
    152e:	e0 2d       	mov	r30, r0
    1530:	09 95       	icall
    1532:	1a b8       	out	0x0a, r1	; 10

		//n64
		RESET_PORTS();
    1534:	17 b8       	out	0x07, r1	; 7
    1536:	14 b8       	out	0x04, r1	; 4
    1538:	1b b9       	out	0x0b, r17	; 11
    153a:	18 b9       	out	0x08, r17	; 8
    153c:	15 b9       	out	0x05, r17	; 5
    153e:	0e 94 e1 19 	call	0x33c2	; 0x33c2 <n64GetConsole>
		curConsole = n64GetConsole();  curConsole->init();
    1542:	90 93 7d 03 	sts	0x037D, r25
    1546:	80 93 7c 03 	sts	0x037C, r24
    154a:	dc 01       	movw	r26, r24
    154c:	ed 91       	ld	r30, X+
    154e:	fc 91       	ld	r31, X
    1550:	09 95       	icall
    1552:	e0 91 7c 03 	lds	r30, 0x037C
		if (Console.Type = curConsole->probe() )   {Console.Rumble = true;  return true; }
    1556:	f0 91 7d 03 	lds	r31, 0x037D
    155a:	04 80       	ldd	r0, Z+4	; 0x04
    155c:	f5 81       	ldd	r31, Z+5	; 0x05
    155e:	e0 2d       	mov	r30, r0
    1560:	09 95       	icall
    1562:	80 93 65 03 	sts	0x0365, r24
    1566:	88 23       	and	r24, r24
    1568:	21 f0       	breq	.+8      	; 0x1572 <con_probe+0x1e0>
    156a:	81 e0       	ldi	r24, 0x01	; 1
    156c:	80 93 63 03 	sts	0x0363, r24
    1570:	a9 c0       	rjmp	.+338    	; 0x16c4 <con_probe+0x332>
    1572:	e0 91 7c 03 	lds	r30, 0x037C
		else curConsole->cleanUp() ;
    1576:	f0 91 7d 03 	lds	r31, 0x037D
    157a:	00 84       	ldd	r0, Z+8	; 0x08
    157c:	f1 85       	ldd	r31, Z+9	; 0x09
    157e:	e0 2d       	mov	r30, r0
    1580:	09 95       	icall
    1582:	1a b8       	out	0x0a, r1	; 10

		//gen
		RESET_PORTS();
    1584:	17 b8       	out	0x07, r1	; 7
    1586:	14 b8       	out	0x04, r1	; 4
    1588:	1b b9       	out	0x0b, r17	; 11
    158a:	18 b9       	out	0x08, r17	; 8
    158c:	15 b9       	out	0x05, r17	; 5
    158e:	0e 94 30 1b 	call	0x3660	; 0x3660 <genGetConsole>
		curConsole = genGetConsole();  curConsole->init();
    1592:	90 93 7d 03 	sts	0x037D, r25
    1596:	80 93 7c 03 	sts	0x037C, r24
    159a:	dc 01       	movw	r26, r24
    159c:	ed 91       	ld	r30, X+
    159e:	fc 91       	ld	r31, X
    15a0:	09 95       	icall
    15a2:	e0 91 7c 03 	lds	r30, 0x037C
		if (Console.Type = curConsole->probe() )   {return true; }
    15a6:	f0 91 7d 03 	lds	r31, 0x037D
    15aa:	04 80       	ldd	r0, Z+4	; 0x04
    15ac:	f5 81       	ldd	r31, Z+5	; 0x05
    15ae:	e0 2d       	mov	r30, r0
    15b0:	09 95       	icall
    15b2:	80 93 65 03 	sts	0x0365, r24
    15b6:	81 11       	cpse	r24, r1
    15b8:	6e cf       	rjmp	.-292    	; 0x1496 <con_probe+0x104>
    15ba:	e0 91 7c 03 	lds	r30, 0x037C
		else curConsole->cleanUp() ;
    15be:	f0 91 7d 03 	lds	r31, 0x037D
    15c2:	00 84       	ldd	r0, Z+8	; 0x08
    15c4:	f1 85       	ldd	r31, Z+9	; 0x09
    15c6:	e0 2d       	mov	r30, r0
    15c8:	09 95       	icall
    15ca:	1a b8       	out	0x0a, r1	; 10


		//3d0
		RESET_PORTS();
    15cc:	17 b8       	out	0x07, r1	; 7
    15ce:	14 b8       	out	0x04, r1	; 4
    15d0:	1b b9       	out	0x0b, r17	; 11
    15d2:	18 b9       	out	0x08, r17	; 8
    15d4:	15 b9       	out	0x05, r17	; 5
    15d6:	0e 94 a6 20 	call	0x414c	; 0x414c <tdoGetConsole>
		curConsole = tdoGetConsole();  curConsole->init();
    15da:	90 93 7d 03 	sts	0x037D, r25
    15de:	80 93 7c 03 	sts	0x037C, r24
    15e2:	dc 01       	movw	r26, r24
    15e4:	ed 91       	ld	r30, X+
    15e6:	fc 91       	ld	r31, X
    15e8:	09 95       	icall
    15ea:	e0 91 7c 03 	lds	r30, 0x037C
		if (Console.Type = curConsole->probe() )   {return true; }
    15ee:	f0 91 7d 03 	lds	r31, 0x037D
    15f2:	04 80       	ldd	r0, Z+4	; 0x04
    15f4:	f5 81       	ldd	r31, Z+5	; 0x05
    15f6:	e0 2d       	mov	r30, r0
    15f8:	09 95       	icall
    15fa:	80 93 65 03 	sts	0x0365, r24
    15fe:	81 11       	cpse	r24, r1
    1600:	4a cf       	rjmp	.-364    	; 0x1496 <con_probe+0x104>
    1602:	e0 91 7c 03 	lds	r30, 0x037C
		else curConsole->cleanUp() ;
    1606:	f0 91 7d 03 	lds	r31, 0x037D
    160a:	00 84       	ldd	r0, Z+8	; 0x08
    160c:	f1 85       	ldd	r31, Z+9	; 0x09
    160e:	e0 2d       	mov	r30, r0
    1610:	09 95       	icall
    1612:	1a b8       	out	0x0a, r1	; 10
	
		//saturn
		RESET_PORTS();
    1614:	17 b8       	out	0x07, r1	; 7
    1616:	14 b8       	out	0x04, r1	; 4
    1618:	1f ef       	ldi	r17, 0xFF	; 255
    161a:	1b b9       	out	0x0b, r17	; 11
    161c:	18 b9       	out	0x08, r17	; 8
    161e:	15 b9       	out	0x05, r17	; 5
    1620:	0e 94 95 23 	call	0x472a	; 0x472a <saturnGetConsole>
		curConsole = saturnGetConsole();  curConsole->init();
    1624:	90 93 7d 03 	sts	0x037D, r25
    1628:	80 93 7c 03 	sts	0x037C, r24
    162c:	dc 01       	movw	r26, r24
    162e:	ed 91       	ld	r30, X+
    1630:	fc 91       	ld	r31, X
    1632:	09 95       	icall
    1634:	e0 91 7c 03 	lds	r30, 0x037C
		if (Console.Type = curConsole->probe() )   {return true; }
    1638:	f0 91 7d 03 	lds	r31, 0x037D
    163c:	04 80       	ldd	r0, Z+4	; 0x04
    163e:	f5 81       	ldd	r31, Z+5	; 0x05
    1640:	e0 2d       	mov	r30, r0
    1642:	09 95       	icall
    1644:	80 93 65 03 	sts	0x0365, r24
    1648:	81 11       	cpse	r24, r1
    164a:	25 cf       	rjmp	.-438    	; 0x1496 <con_probe+0x104>
    164c:	e0 91 7c 03 	lds	r30, 0x037C
		else curConsole->cleanUp() ;
    1650:	f0 91 7d 03 	lds	r31, 0x037D
    1654:	00 84       	ldd	r0, Z+8	; 0x08
    1656:	f1 85       	ldd	r31, Z+9	; 0x09
    1658:	e0 2d       	mov	r30, r0
    165a:	09 95       	icall
    165c:	1a b8       	out	0x0a, r1	; 10

			
		//tg16
		RESET_PORTS();
    165e:	17 b8       	out	0x07, r1	; 7
    1660:	14 b8       	out	0x04, r1	; 4
    1662:	1b b9       	out	0x0b, r17	; 11
    1664:	18 b9       	out	0x08, r17	; 8
    1666:	15 b9       	out	0x05, r17	; 5
    1668:	0e 94 6f 25 	call	0x4ade	; 0x4ade <tg16GetConsole>
		curConsole = tg16GetConsole();  curConsole->init();
    166c:	0d c0       	rjmp	.+26     	; 0x1688 <con_probe+0x2f6>
    166e:	83 b1       	in	r24, 0x03	; 3
	//atari 2600
	//wii
	//then moe on to paddle for sms
	
	// key pins 8,10 wii
	else if ( (unsigned char )(~PINB)  ==  (unsigned char )0xA0 ) //negate promotion using casting
    1670:	1a b8       	out	0x0a, r1	; 10
	{
		
		//wii
		RESET_PORTS();	//was just assed is this ok?
    1672:	17 b8       	out	0x07, r1	; 7
    1674:	14 b8       	out	0x04, r1	; 4
    1676:	0b b9       	out	0x0b, r16	; 11
    1678:	08 b9       	out	0x08, r16	; 8
    167a:	05 b9       	out	0x05, r16	; 5
    167c:	8f 35       	cpi	r24, 0x5F	; 95
	//atari 2600
	//wii
	//then moe on to paddle for sms
	
	// key pins 8,10 wii
	else if ( (unsigned char )(~PINB)  ==  (unsigned char )0xA0 ) //negate promotion using casting
    167e:	11 f4       	brne	.+4      	; 0x1684 <con_probe+0x2f2>
    1680:	6f d4       	rcall	.+2270   	; 0x1f60 <wiiGetConsole>
	{
		
		//wii
		RESET_PORTS();	//was just assed is this ok?
		curConsole = wiiGetConsole();  curConsole->init();
    1682:	02 c0       	rjmp	.+4      	; 0x1688 <con_probe+0x2f6>
    1684:	0e 94 d0 21 	call	0x43a0	; 0x43a0 <standardGetConsole>
	else  // multiple keys (15, 14) see in code. 
	{
		 
		//standard
		RESET_PORTS();
		curConsole = standardGetConsole();  curConsole->init();
    1688:	90 93 7d 03 	sts	0x037D, r25
    168c:	80 93 7c 03 	sts	0x037C, r24
    1690:	dc 01       	movw	r26, r24
    1692:	ed 91       	ld	r30, X+
    1694:	fc 91       	ld	r31, X
    1696:	09 95       	icall
    1698:	e0 91 7c 03 	lds	r30, 0x037C
		if (Console.Type = curConsole->probe() )   {return true; }
    169c:	f0 91 7d 03 	lds	r31, 0x037D
    16a0:	04 80       	ldd	r0, Z+4	; 0x04
    16a2:	f5 81       	ldd	r31, Z+5	; 0x05
    16a4:	e0 2d       	mov	r30, r0
    16a6:	09 95       	icall
    16a8:	80 93 65 03 	sts	0x0365, r24
    16ac:	81 11       	cpse	r24, r1
    16ae:	f3 ce       	rjmp	.-538    	; 0x1496 <con_probe+0x104>
    16b0:	e0 91 7c 03 	lds	r30, 0x037C
		else curConsole->cleanUp() ;
    16b4:	f0 91 7d 03 	lds	r31, 0x037D
    16b8:	00 84       	ldd	r0, Z+8	; 0x08
    16ba:	f1 85       	ldd	r31, Z+9	; 0x09
    16bc:	e0 2d       	mov	r30, r0
    16be:	89 83       	std	Y+1, r24	; 0x01
    16c0:	09 95       	icall
    16c2:	89 81       	ldd	r24, Y+1	; 0x01
    16c4:	0f 90       	pop	r0
    16c6:	df 91       	pop	r29
	}
 	
	return 0; //force loop again.
}
    16c8:	cf 91       	pop	r28
    16ca:	1f 91       	pop	r17
    16cc:	0f 91       	pop	r16
    16ce:	08 95       	ret

000016d0 <DoWork>:

/*********** prototypes *************/
static void Init(void);
static void Update(void);
static unsigned char Probe(void);
static void DoWork(void){};
    16d0:	08 95       	ret

000016d2 <Init>:
	else return SPDR; 
}

void Init(void)
{
	internal_DPAD_mode = Controller.DpadOnly;
    16d2:	80 91 83 03 	lds	r24, 0x0383
    16d6:	80 93 c3 01 	sts	0x01C3, r24
	controller_mode = 
	pre_controller_mode  = controller_mode_digital;
    16da:	10 92 c8 01 	sts	0x01C8, r1
}

void Init(void)
{
	internal_DPAD_mode = Controller.DpadOnly;
	controller_mode = 
    16de:	10 92 c9 01 	sts	0x01C9, r1
	pre_controller_mode  = controller_mode_digital;
	mode=NORMAL;
    16e2:	10 92 c7 01 	sts	0x01C7, r1
	watchDog1=0;	
    16e6:	10 92 c6 01 	sts	0x01C6, r1
	DDRB = 0x18;//PB0,1,2,3,4  in,in,in, out, out(enable_ss,CLK,MOSI,MISO,ack) 
    16ea:	88 e1       	ldi	r24, 0x18	; 24
    16ec:	84 b9       	out	0x04, r24	; 4
	PORTB = 0xff;//all pull up
    16ee:	8f ef       	ldi	r24, 0xFF	; 255
    16f0:	85 b9       	out	0x05, r24	; 5
   
   SPCR = (1<<SPE)|(1<<SPR1)|(1<<SPR0)|(1<<DORD)|(1<<CPHA)|(1<<CPOL);   
    16f2:	8f e6       	ldi	r24, 0x6F	; 111
    16f4:	8c bd       	out	0x2c, r24	; 44
    16f6:	08 95       	ret

000016f8 <CleanUp>:
}
void CleanUp(void)
{
 
   SPCR = 0;
    16f8:	1c bc       	out	0x2c, r1	; 44
    16fa:	08 95       	ret

000016fc <Spi_read>:


unsigned char Spi_read(char ack, unsigned char data)
{
	//note we will see comm on another port for psx, the psx shares the lines, we can not watch for this low when we enter here because we do this in advance but its ok the SPI will handel it.
	SPDR = data;
    16fc:	6e bd       	out	0x2e, r22	; 46

    while(!(SPSR & (1<<SPIF)));
    16fe:	0d b4       	in	r0, 0x2d	; 45
    1700:	07 fe       	sbrs	r0, 7
    1702:	fd cf       	rjmp	.-6      	; 0x16fe <Spi_read+0x2>
	if (ack)
    1704:	88 23       	and	r24, r24
    1706:	71 f0       	breq	.+28     	; 0x1724 <Spi_read+0x28>
	{	//very picky!! suggeted not to add or modify this code. will change acking for psx biose, psx normal operation, and ps2
		
		if ( controller_mode == controller_mode_digital) _delay_us(8);//we need to delay the the ack, 1 was not enough seen on psx bios screen. but analog on ps2 needs to be fast. 
    1708:	80 91 c9 01 	lds	r24, 0x01C9
    170c:	81 11       	cpse	r24, r1
    170e:	04 c0       	rjmp	.+8      	; 0x1718 <Spi_read+0x1c>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1710:	8a e2       	ldi	r24, 0x2A	; 42
    1712:	8a 95       	dec	r24
    1714:	f1 f7       	brne	.-4      	; 0x1712 <Spi_read+0x16>
    1716:	00 c0       	rjmp	.+0      	; 0x1718 <Spi_read+0x1c>
		ATT_ON();//PS ack
    1718:	2c 98       	cbi	0x05, 4	; 5
    171a:	85 e0       	ldi	r24, 0x05	; 5
    171c:	8a 95       	dec	r24
    171e:	f1 f7       	brne	.-4      	; 0x171c <Spi_read+0x20>
    1720:	00 00       	nop
		_delay_us(1);
		ATT_OFF();
    1722:	2c 9a       	sbi	0x05, 4	; 5
	}
	if ( PINB & 1)  return 0; //this prevents a return 1 when there is no activity. 
    1724:	18 99       	sbic	0x03, 0	; 3
    1726:	02 c0       	rjmp	.+4      	; 0x172c <Spi_read+0x30>
	else return SPDR; 
    1728:	8e b5       	in	r24, 0x2e	; 46
    172a:	08 95       	ret
		if ( controller_mode == controller_mode_digital) _delay_us(8);//we need to delay the the ack, 1 was not enough seen on psx bios screen. but analog on ps2 needs to be fast. 
		ATT_ON();//PS ack
		_delay_us(1);
		ATT_OFF();
	}
	if ( PINB & 1)  return 0; //this prevents a return 1 when there is no activity. 
    172c:	80 e0       	ldi	r24, 0x00	; 0
	else return SPDR; 
}
    172e:	08 95       	ret

00001730 <sendAnalogPayload>:
	}
	

}
void sendAnalogPayload( char end)
{
    1730:	cf 93       	push	r28
    1732:	c8 2f       	mov	r28, r24
	unsigned char check = 
    1734:	60 91 6d 03 	lds	r22, 0x036D
    1738:	81 e0       	ldi	r24, 0x01	; 1
    173a:	e0 df       	rcall	.-64     	; 0x16fc <Spi_read>
    173c:	81 50       	subi	r24, 0x01	; 1
	Spi_read(1, reportBuffer[X_SECONDARY_STICK]); //Rx
	if ( check != 0x00 && check != 0xFF )
    173e:	8e 3f       	cpi	r24, 0xFE	; 254
    1740:	38 f4       	brcc	.+14     	; 0x1750 <sendAnalogPayload+0x20>
    1742:	8f ea       	ldi	r24, 0xAF	; 175
    1744:	94 e0       	ldi	r25, 0x04	; 4
    1746:	01 97       	sbiw	r24, 0x01	; 1
    1748:	f1 f7       	brne	.-4      	; 0x1746 <sendAnalogPayload+0x16>
    174a:	00 c0       	rjmp	.+0      	; 0x174c <sendAnalogPayload+0x1c>
    174c:	00 00       	nop
    174e:	c1 df       	rcall	.-126    	; 0x16d2 <Init>
	{
		//if we didnt not get back the 00, its posible the host stopped sending full data and we clobbered with the next packet. 
		//reset out interneal data back to digital, and wait 300us
		_delay_us(300);
		Init();
    1750:	60 91 6e 03 	lds	r22, 0x036E
	}
	Spi_read(1, reportBuffer[Y_SECONDARY_STICK]);//Ry
    1754:	81 e0       	ldi	r24, 0x01	; 1
    1756:	d2 df       	rcall	.-92     	; 0x16fc <Spi_read>
    1758:	60 91 6b 03 	lds	r22, 0x036B
    175c:	81 e0       	ldi	r24, 0x01	; 1
	Spi_read(1, reportBuffer[X_MAIN_STICK]);//Lx
    175e:	ce df       	rcall	.-100    	; 0x16fc <Spi_read>
    1760:	60 91 6c 03 	lds	r22, 0x036C
    1764:	8c 2f       	mov	r24, r28
    1766:	cf 91       	pop	r28
	Spi_read(end, reportBuffer[Y_MAIN_STICK]);//Ly
    1768:	c9 cf       	rjmp	.-110    	; 0x16fc <Spi_read>

0000176a <Probe>:
    176a:	cf 93       	push	r28
    176c:	80 e1       	ldi	r24, 0x10	; 16

}
    176e:	94 ea       	ldi	r25, 0xA4	; 164
		_delay_us(300);
		Init();
	}
	Spi_read(1, reportBuffer[Y_SECONDARY_STICK]);//Ry
	Spi_read(1, reportBuffer[X_MAIN_STICK]);//Lx
	Spi_read(end, reportBuffer[Y_MAIN_STICK]);//Ly
    1770:	18 9b       	sbis	0x03, 0	; 3
    1772:	07 c0       	rjmp	.+14     	; 0x1782 <Probe+0x18>
    1774:	25 e8       	ldi	r18, 0x85	; 133
    1776:	2a 95       	dec	r18
    1778:	f1 f7       	brne	.-4      	; 0x1776 <Probe+0xc>
    177a:	00 00       	nop
    177c:	01 97       	sbiw	r24, 0x01	; 1
	unsigned int MAX_TIME =42000;
	unsigned int timer = 0;
	unsigned char command=0;

	//check for a SPI command. extened the wait up to 1sec this way we do not havce to keep probing and looping
	while ( timer < MAX_TIME && (PINB & 1)  ) { timer++; _delay_us(25);  }
    177e:	00 97       	sbiw	r24, 0x00	; 0
    1780:	b9 f7       	brne	.-18     	; 0x1770 <Probe+0x6>
    1782:	87 ec       	ldi	r24, 0xC7	; 199
    1784:	90 e0       	ldi	r25, 0x00	; 0
    1786:	01 97       	sbiw	r24, 0x01	; 1
    1788:	f1 f7       	brne	.-4      	; 0x1786 <Probe+0x1c>
    178a:	00 c0       	rjmp	.+0      	; 0x178c <Probe+0x22>
    178c:	00 00       	nop

	//sega check
	_delay_us(50); 
	if ( PINB & 1) { SPCR=0; return 0; }// ps2 will not be high after 50 us, must be sega7
    178e:	83 b1       	in	r24, 0x03	; 3
    1790:	c8 2f       	mov	r28, r24
    1792:	c1 70       	andi	r28, 0x01	; 1
    1794:	80 fd       	sbrc	r24, 0
    1796:	0e c0       	rjmp	.+28     	; 0x17b4 <Probe+0x4a>
    1798:	8f e8       	ldi	r24, 0x8F	; 143
    179a:	91 e0       	ldi	r25, 0x01	; 1
    179c:	01 97       	sbiw	r24, 0x01	; 1
    179e:	f1 f7       	brne	.-4      	; 0x179c <Probe+0x32>
    17a0:	00 c0       	rjmp	.+0      	; 0x17a2 <Probe+0x38>
    17a2:	00 00       	nop
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    17a4:	8f e9       	ldi	r24, 0x9F	; 159
    17a6:	9f e0       	ldi	r25, 0x0F	; 15
    17a8:	01 97       	sbiw	r24, 0x01	; 1
    17aa:	f1 f7       	brne	.-4      	; 0x17a8 <Probe+0x3e>
    17ac:	00 c0       	rjmp	.+0      	; 0x17ae <Probe+0x44>
    17ae:	00 00       	nop
	}
	_delay_ms(1); //move past spi poll.	 
	 
	//make sure its not just a low condition, because SPI will freeze up for certain pin states. 
	timer = 0;
	if (timer == MAX_TIME || (PINB & 1) == 0x00 ) {SPCR=0; return 0;} //if still low, this is not psx. -could add a check for command pb2.
    17b0:	18 99       	sbic	0x03, 0	; 3
    17b2:	03 c0       	rjmp	.+6      	; 0x17ba <Probe+0x50>
    17b4:	1c bc       	out	0x2c, r1	; 44
    17b6:	c0 e0       	ldi	r28, 0x00	; 0
    17b8:	23 c0       	rjmp	.+70     	; 0x1800 <Probe+0x96>
	//a dummy is needed. - the first has a enable blip in it causing a bad command return, once this is sent all other commands work,
	Spi_read(0, 0);
    17ba:	60 e0       	ldi	r22, 0x00	; 0
    17bc:	80 e0       	ldi	r24, 0x00	; 0
    17be:	9e df       	rcall	.-196    	; 0x16fc <Spi_read>
    17c0:	6f ef       	ldi	r22, 0xFF	; 255
	//looks for the psx command 0xff. 
	command=Spi_read(0, 0xff); //the console always sends a 0x01 and waits for ack. So first look for the FF and do not ack.
    17c2:	80 e0       	ldi	r24, 0x00	; 0
    17c4:	9b df       	rcall	.-202    	; 0x16fc <Spi_read>
    17c6:	81 30       	cpi	r24, 0x01	; 1
    17c8:	d1 f4       	brne	.+52     	; 0x17fe <Probe+0x94>
	
	if (command==1) 
    17ca:	6f ef       	ldi	r22, 0xFF	; 255
    17cc:	97 df       	rcall	.-210    	; 0x16fc <Spi_read>
	{
		Spi_read(1, 0xff); //now ack.
    17ce:	61 e4       	ldi	r22, 0x41	; 65
    17d0:	81 e0       	ldi	r24, 0x01	; 1
    17d2:	94 df       	rcall	.-216    	; 0x16fc <Spi_read>
		Spi_read(1, pad_digitial);//always pad_digitial here. PSX needs to know we are attached. 
    17d4:	6a e5       	ldi	r22, 0x5A	; 90
    17d6:	81 e0       	ldi	r24, 0x01	; 1
    17d8:	91 df       	rcall	.-222    	; 0x16fc <Spi_read>
    17da:	6f ef       	ldi	r22, 0xFF	; 255
		Spi_read(1, 0x5a); //init with ff,ff 
    17dc:	81 e0       	ldi	r24, 0x01	; 1
    17de:	8e df       	rcall	.-228    	; 0x16fc <Spi_read>
    17e0:	6f ef       	ldi	r22, 0xFF	; 255
    17e2:	81 e0       	ldi	r24, 0x01	; 1
		Spi_read(1, 0xFF); 
    17e4:	8b df       	rcall	.-234    	; 0x16fc <Spi_read>
    17e6:	95 e3       	ldi	r25, 0x35	; 53
    17e8:	9a 95       	dec	r25
    17ea:	f1 f7       	brne	.-4      	; 0x17e8 <Probe+0x7e>
		Spi_read(1, 0xFF); 
    17ec:	00 00       	nop
    17ee:	8c b5       	in	r24, 0x2c	; 44
    17f0:	8f 7b       	andi	r24, 0xBF	; 191
    17f2:	8c bd       	out	0x2c, r24	; 44
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    17f4:	84 b1       	in	r24, 0x04	; 4
    17f6:	87 7e       	andi	r24, 0xE7	; 231
    17f8:	84 b9       	out	0x04, r24	; 4
    17fa:	c7 e1       	ldi	r28, 0x17	; 23
		
		_delay_us(10);//clear  spi.
		SPCR &= ~(1<<SPE);
    17fc:	01 c0       	rjmp	.+2      	; 0x1800 <Probe+0x96>
    17fe:	1c bc       	out	0x2c, r1	; 44
    1800:	8c 2f       	mov	r24, r28
		DDRB &= ~0x18; //free line for port 2 to talk.
    1802:	cf 91       	pop	r28
    1804:	08 95       	ret

00001806 <Update>:
    1806:	1f 93       	push	r17
		return PSX;
    1808:	cf 93       	push	r28
    180a:	df 93       	push	r29
	}
	
	SPCR=0;
    180c:	18 9b       	sbis	0x03, 0	; 3
	return 0;
}
    180e:	fe cf       	rjmp	.-4      	; 0x180c <Update+0x6>
    1810:	8a eb       	ldi	r24, 0xBA	; 186
    1812:	98 e8       	ldi	r25, 0x88	; 136
	unsigned char buttons2=0xff;	

	while(! (PINB & 1)); //If its talking this is wrong...  wait it out. 
	
	unsigned int count=0;	
	while( (PINB & 1)) //we also need to wait for the begine of talk, or the other port may be in use. If you pull on the lines, that port is going to fail.
    1814:	18 9b       	sbis	0x03, 0	; 3
    1816:	06 c0       	rjmp	.+12     	; 0x1824 <Update+0x1e>
    1818:	01 97       	sbiw	r24, 0x01	; 1
	{
		if (count++ > 35000) //17.5 ms
    181a:	00 97       	sbiw	r24, 0x00	; 0
    181c:	d9 f7       	brne	.-10     	; 0x1814 <Update+0xe>
		{
			watchDog1 = 200;// trigger WD
    181e:	88 ec       	ldi	r24, 0xC8	; 200
    1820:	80 93 c6 01 	sts	0x01C6, r24
		} 
	} 

	//Select 	L3 (jush push) 	R3 	Start 	Up 	Right 	Down 	Left 	L2 	R2 	L1 	R1 	Triangle 	O 	X 	Square
	//byte.bit 	4.0 	4.1 	4.2 	4.3 	4.4 	4.5 	4.6 	4.7 	5.0 	5.1 	5.2 	5.3 	5.4 	5.5 	5.6 	5.7
	if ( reportBuffer[HAT] == 0) buttons1 &= ~0x10;// up
    1824:	80 91 6a 03 	lds	r24, 0x036A
    1828:	88 23       	and	r24, r24
    182a:	09 f4       	brne	.+2      	; 0x182e <Update+0x28>
    182c:	64 c2       	rjmp	.+1224   	; 0x1cf6 <Update+0x4f0>
	if ( reportBuffer[HAT] == 2) buttons1 &= ~0x20;// right
    182e:	82 30       	cpi	r24, 0x02	; 2
    1830:	09 f4       	brne	.+2      	; 0x1834 <Update+0x2e>
    1832:	63 c2       	rjmp	.+1222   	; 0x1cfa <Update+0x4f4>
	if ( reportBuffer[HAT] == 4) buttons1 &= ~0x40;// DOWN
    1834:	84 30       	cpi	r24, 0x04	; 4
    1836:	49 f0       	breq	.+18     	; 0x184a <Update+0x44>
	if ( reportBuffer[HAT] == 6) buttons1 &= ~0x80;// LEFT
    1838:	86 30       	cpi	r24, 0x06	; 6
    183a:	89 f0       	breq	.+34     	; 0x185e <Update+0x58>
					
	if ( reportBuffer[HAT] == 1) buttons1 &= ~0x30;// up right
    183c:	81 30       	cpi	r24, 0x01	; 1
    183e:	89 f0       	breq	.+34     	; 0x1862 <Update+0x5c>

void Update(void)
{	

	//buttons are inverted so logic is backwards. 
	unsigned char buttons1=0xff;
    1840:	df ef       	ldi	r29, 0xFF	; 255
	if ( reportBuffer[HAT] == 2) buttons1 &= ~0x20;// right
	if ( reportBuffer[HAT] == 4) buttons1 &= ~0x40;// DOWN
	if ( reportBuffer[HAT] == 6) buttons1 &= ~0x80;// LEFT
					
	if ( reportBuffer[HAT] == 1) buttons1 &= ~0x30;// up right
	if ( reportBuffer[HAT] == 3) buttons1 &= ~0x60;// down right
    1842:	83 30       	cpi	r24, 0x03	; 3
    1844:	21 f4       	brne	.+8      	; 0x184e <Update+0x48>
    1846:	df e9       	ldi	r29, 0x9F	; 159
    1848:	0d c0       	rjmp	.+26     	; 0x1864 <Update+0x5e>

	//Select 	L3 (jush push) 	R3 	Start 	Up 	Right 	Down 	Left 	L2 	R2 	L1 	R1 	Triangle 	O 	X 	Square
	//byte.bit 	4.0 	4.1 	4.2 	4.3 	4.4 	4.5 	4.6 	4.7 	5.0 	5.1 	5.2 	5.3 	5.4 	5.5 	5.6 	5.7
	if ( reportBuffer[HAT] == 0) buttons1 &= ~0x10;// up
	if ( reportBuffer[HAT] == 2) buttons1 &= ~0x20;// right
	if ( reportBuffer[HAT] == 4) buttons1 &= ~0x40;// DOWN
    184a:	df eb       	ldi	r29, 0xBF	; 191
    184c:	0b c0       	rjmp	.+22     	; 0x1864 <Update+0x5e>
	if ( reportBuffer[HAT] == 6) buttons1 &= ~0x80;// LEFT
					
	if ( reportBuffer[HAT] == 1) buttons1 &= ~0x30;// up right
	if ( reportBuffer[HAT] == 3) buttons1 &= ~0x60;// down right
	if ( reportBuffer[HAT] == 5) buttons1 &= ~0xc0;// down left
    184e:	85 30       	cpi	r24, 0x05	; 5
    1850:	11 f4       	brne	.+4      	; 0x1856 <Update+0x50>
    1852:	df e3       	ldi	r29, 0x3F	; 63
    1854:	07 c0       	rjmp	.+14     	; 0x1864 <Update+0x5e>
	if ( reportBuffer[HAT] == 7) buttons1 &= ~0x90;// up left
    1856:	87 30       	cpi	r24, 0x07	; 7
    1858:	29 f4       	brne	.+10     	; 0x1864 <Update+0x5e>
    185a:	df e6       	ldi	r29, 0x6F	; 111
    185c:	03 c0       	rjmp	.+6      	; 0x1864 <Update+0x5e>
	//Select 	L3 (jush push) 	R3 	Start 	Up 	Right 	Down 	Left 	L2 	R2 	L1 	R1 	Triangle 	O 	X 	Square
	//byte.bit 	4.0 	4.1 	4.2 	4.3 	4.4 	4.5 	4.6 	4.7 	5.0 	5.1 	5.2 	5.3 	5.4 	5.5 	5.6 	5.7
	if ( reportBuffer[HAT] == 0) buttons1 &= ~0x10;// up
	if ( reportBuffer[HAT] == 2) buttons1 &= ~0x20;// right
	if ( reportBuffer[HAT] == 4) buttons1 &= ~0x40;// DOWN
	if ( reportBuffer[HAT] == 6) buttons1 &= ~0x80;// LEFT
    185e:	df e7       	ldi	r29, 0x7F	; 127
    1860:	01 c0       	rjmp	.+2      	; 0x1864 <Update+0x5e>
					
	if ( reportBuffer[HAT] == 1) buttons1 &= ~0x30;// up right
    1862:	df ec       	ldi	r29, 0xCF	; 207
	if ( reportBuffer[HAT] == 3) buttons1 &= ~0x60;// down right
	if ( reportBuffer[HAT] == 5) buttons1 &= ~0xc0;// down left
	if ( reportBuffer[HAT] == 7) buttons1 &= ~0x90;// up left

	if ( reportBuffer[BUTTON_ROW_1] & 0x10) buttons1 &= ~Select;//select
    1864:	80 91 68 03 	lds	r24, 0x0368
    1868:	84 fd       	sbrc	r24, 4
    186a:	de 7f       	andi	r29, 0xFE	; 254
	if ( reportBuffer[BUTTON_ROW_1] & 0x20) buttons1 &= ~Start;//start
    186c:	85 fd       	sbrc	r24, 5
    186e:	d7 7f       	andi	r29, 0xF7	; 247
	if ( reportBuffer[BUTTON_ROW_2] & 0x40) buttons1 &= ~L3;//l3
    1870:	90 91 69 03 	lds	r25, 0x0369
    1874:	96 fd       	sbrc	r25, 6
    1876:	dd 7f       	andi	r29, 0xFD	; 253
	if ( reportBuffer[BUTTON_ROW_2] & 0x80) buttons1 &= ~R3;//r3
    1878:	97 fd       	sbrc	r25, 7
    187a:	db 7f       	andi	r29, 0xFB	; 251
                                                       
	if ( reportBuffer[BUTTON_ROW_1] & 0x01) buttons2 &= ~Cross;
    187c:	80 fd       	sbrc	r24, 0
    187e:	02 c0       	rjmp	.+4      	; 0x1884 <Update+0x7e>
void Update(void)
{	

	//buttons are inverted so logic is backwards. 
	unsigned char buttons1=0xff;
	unsigned char buttons2=0xff;	
    1880:	cf ef       	ldi	r28, 0xFF	; 255
    1882:	01 c0       	rjmp	.+2      	; 0x1886 <Update+0x80>
	if ( reportBuffer[BUTTON_ROW_1] & 0x10) buttons1 &= ~Select;//select
	if ( reportBuffer[BUTTON_ROW_1] & 0x20) buttons1 &= ~Start;//start
	if ( reportBuffer[BUTTON_ROW_2] & 0x40) buttons1 &= ~L3;//l3
	if ( reportBuffer[BUTTON_ROW_2] & 0x80) buttons1 &= ~R3;//r3
                                                       
	if ( reportBuffer[BUTTON_ROW_1] & 0x01) buttons2 &= ~Cross;
    1884:	cf eb       	ldi	r28, 0xBF	; 191
	if ( reportBuffer[BUTTON_ROW_1] & 0x02) buttons2 &= ~Circle;
    1886:	81 fd       	sbrc	r24, 1
    1888:	cf 7d       	andi	r28, 0xDF	; 223
	if ( reportBuffer[BUTTON_ROW_1] & 0x04) buttons2 &= ~Square;
    188a:	82 fd       	sbrc	r24, 2
    188c:	cf 77       	andi	r28, 0x7F	; 127
	if ( reportBuffer[BUTTON_ROW_1] & 0x08) buttons2 &= ~Triangle;
    188e:	83 fd       	sbrc	r24, 3
    1890:	cf 7e       	andi	r28, 0xEF	; 239
	                                                   
	if ( reportBuffer[BUTTON_ROW_1] & 0x40) buttons2 &= ~L2;
    1892:	86 fd       	sbrc	r24, 6
    1894:	cb 7f       	andi	r28, 0xFB	; 251
	if ( reportBuffer[BUTTON_ROW_1] & 0x80) buttons2 &= ~R2;
    1896:	87 fd       	sbrc	r24, 7
    1898:	c7 7f       	andi	r28, 0xF7	; 247
	if ( reportBuffer[BUTTON_ROW_2] & 0x01) buttons2 &= ~L1;
    189a:	90 fd       	sbrc	r25, 0
    189c:	ce 7f       	andi	r28, 0xFE	; 254
	if ( reportBuffer[BUTTON_ROW_2] & 0x02) buttons2 &= ~R1;
    189e:	91 fd       	sbrc	r25, 1
    18a0:	cd 7f       	andi	r28, 0xFD	; 253
	
	SPCR |= (1<<SPE);//now start up spi.
    18a2:	8c b5       	in	r24, 0x2c	; 44
    18a4:	80 64       	ori	r24, 0x40	; 64
    18a6:	8c bd       	out	0x2c, r24	; 44
	DDRB |= 0x18; //re anable ports. 
    18a8:	84 b1       	in	r24, 0x04	; 4
    18aa:	88 61       	ori	r24, 0x18	; 24
    18ac:	84 b9       	out	0x04, r24	; 4

	if (watchDog1 > 127) Init(); 
    18ae:	80 91 c6 01 	lds	r24, 0x01C6
    18b2:	87 fd       	sbrc	r24, 7
    18b4:	0e df       	rcall	.-484    	; 0x16d2 <Init>
    18b6:	80 91 c6 01 	lds	r24, 0x01C6
	
	watchDog1++;
    18ba:	8f 5f       	subi	r24, 0xFF	; 255
    18bc:	80 93 c6 01 	sts	0x01C6, r24
    18c0:	6f ef       	ldi	r22, 0xFF	; 255

	unsigned char checkData = Spi_read(1, 0xff);
    18c2:	81 e0       	ldi	r24, 0x01	; 1
    18c4:	1b df       	rcall	.-458    	; 0x16fc <Spi_read>
    18c6:	81 30       	cpi	r24, 0x01	; 1
    18c8:	09 f0       	breq	.+2      	; 0x18cc <Update+0xc6>

	if (checkData == 1)//first command is always a 1.
    18ca:	07 c2       	rjmp	.+1038   	; 0x1cda <Update+0x4d4>
    18cc:	10 92 c6 01 	sts	0x01C6, r1
	{	
		watchDog1=0;//taim the dog.	
    18d0:	80 91 c7 01 	lds	r24, 0x01C7
		if (mode == CONFIG)
    18d4:	81 30       	cpi	r24, 0x01	; 1
    18d6:	09 f0       	breq	.+2      	; 0x18da <Update+0xd4>
    18d8:	4a c1       	rjmp	.+660    	; 0x1b6e <Update+0x368>
    18da:	63 ef       	ldi	r22, 0xF3	; 243
    18dc:	0f df       	rcall	.-482    	; 0x16fc <Spi_read>
		{
			unsigned char command=0;
			unsigned char out;		
			
  command = Spi_read(1, 0xf3);//in config mode
    18de:	18 2f       	mov	r17, r24
    18e0:	6a e5       	ldi	r22, 0x5A	; 90
    18e2:	81 e0       	ldi	r24, 0x01	; 1
    18e4:	0b df       	rcall	.-490    	; 0x16fc <Spi_read>
			
			Spi_read(1, 0x5a);//always get a 0 here.
    18e6:	81 2f       	mov	r24, r17
    18e8:	90 e0       	ldi	r25, 0x00	; 0
    18ea:	fc 01       	movw	r30, r24
    18ec:	e0 54       	subi	r30, 0x40	; 64
			switch (command)
    18ee:	f1 09       	sbc	r31, r1
    18f0:	e0 31       	cpi	r30, 0x10	; 16
    18f2:	f1 05       	cpc	r31, r1
    18f4:	08 f0       	brcs	.+2      	; 0x18f8 <Update+0xf2>
    18f6:	f1 c1       	rjmp	.+994    	; 0x1cda <Update+0x4d4>
    18f8:	ea 5a       	subi	r30, 0xAA	; 170
    18fa:	ff 4f       	sbci	r31, 0xFF	; 255
    18fc:	0c 94 aa 2a 	jmp	0x5554	; 0x5554 <__tablejump2__>
    1900:	6d 2f       	mov	r22, r29
    1902:	81 e0       	ldi	r24, 0x01	; 1
    1904:	fb de       	rcall	.-522    	; 0x16fc <Spi_read>
    1906:	80 93 41 03 	sts	0x0341, r24
			{
				case main_poll: //42 - can also be pulled in config mode. but at times gets stuck, so we need a watch dog.
				RumbleSmallMotor = Spi_read(1, buttons1);//b1
    190a:	80 91 c1 01 	lds	r24, 0x01C1
    190e:	88 23       	and	r24, r24
    1910:	31 f0       	breq	.+12     	; 0x191e <Update+0x118>
    1912:	81 50       	subi	r24, 0x01	; 1
	// type as soon as our code does. The console expects the old  //
	// type to still be reporting for a few polls. TRying to fake  //
	// this is hard so we just leep track of the changes and adapt.// 
	/////////////////////////////////////////////////////////////////
	
	if (  _pressure_timer > 0 ) //something like the config timer only for pressure, I see a 79 run as analog only then a 79 as a config timer.
    1914:	80 93 c1 01 	sts	0x01C1, r24
    1918:	6c 2f       	mov	r22, r28
    191a:	81 e0       	ldi	r24, 0x01	; 1
	{
		_pressure_timer--;
    191c:	2a c0       	rjmp	.+84     	; 0x1972 <Update+0x16c>
    191e:	80 91 c2 01 	lds	r24, 0x01C2
		RumbleLargeMotor = Spi_read(1, buttons2);//b2
    1922:	88 23       	and	r24, r24
    1924:	31 f0       	breq	.+12     	; 0x1932 <Update+0x12c>
    1926:	81 50       	subi	r24, 0x01	; 1
		sendAnalogPayload(0);
		return;
	}

	if ( _config_timer > 0 ) //once a config mode is ran it will pull and eventualy send a 1 in buttons1 to indicate its accepted, wait for this.
    1928:	80 93 c2 01 	sts	0x01C2, r24
    192c:	6c 2f       	mov	r22, r28
    192e:	80 e0       	ldi	r24, 0x00	; 0
	{
		_config_timer--;
    1930:	29 c0       	rjmp	.+82     	; 0x1984 <Update+0x17e>
    1932:	80 91 c9 01 	lds	r24, 0x01C9
		RumbleLargeMotor = Spi_read(0, buttons2);//b2
    1936:	82 30       	cpi	r24, 0x02	; 2
    1938:	c9 f4       	brne	.+50     	; 0x196c <Update+0x166>
    193a:	6c 2f       	mov	r22, r28
	}
	////
	///
	//

	if (controller_mode == controller_mode_full)
    193c:	81 e0       	ldi	r24, 0x01	; 1
    193e:	de de       	rcall	.-580    	; 0x16fc <Spi_read>
    1940:	80 93 50 03 	sts	0x0350, r24
	{ 
		RumbleLargeMotor = Spi_read(1, buttons2);//b2	 
    1944:	81 e0       	ldi	r24, 0x01	; 1
    1946:	f4 de       	rcall	.-536    	; 0x1730 <sendAnalogPayload>
    1948:	80 91 c9 01 	lds	r24, 0x01C9
    194c:	82 30       	cpi	r24, 0x02	; 2
    194e:	e9 f4       	brne	.+58     	; 0x198a <Update+0x184>
		sendAnalogPayload(1);
    1950:	c5 e3       	ldi	r28, 0x35	; 53
    1952:	d3 e0       	ldi	r29, 0x03	; 3
    1954:	69 91       	ld	r22, Y+
		if (controller_mode == controller_mode_full)//this second check is needed, as it may have been reset in sendAnalogPayload
    1956:	81 e0       	ldi	r24, 0x01	; 1
    1958:	d1 de       	rcall	.-606    	; 0x16fc <Spi_read>
    195a:	83 e0       	ldi	r24, 0x03	; 3
    195c:	c0 34       	cpi	r28, 0x40	; 64
    195e:	d8 07       	cpc	r29, r24
    1960:	c9 f7       	brne	.-14     	; 0x1954 <Update+0x14e>
		{
			for(char p=0;p<11;p++) Spi_read(1, pressureData[p]);
    1962:	60 91 40 03 	lds	r22, 0x0340
    1966:	80 e0       	ldi	r24, 0x00	; 0
    1968:	c9 de       	rcall	.-622    	; 0x16fc <Spi_read>
    196a:	0f c0       	rjmp	.+30     	; 0x198a <Update+0x184>
    196c:	81 30       	cpi	r24, 0x01	; 1
    196e:	39 f4       	brne	.+14     	; 0x197e <Update+0x178>
    1970:	6c 2f       	mov	r22, r28
			Spi_read(0, pressureData[11]);
    1972:	c4 de       	rcall	.-632    	; 0x16fc <Spi_read>
    1974:	80 93 50 03 	sts	0x0350, r24
    1978:	80 e0       	ldi	r24, 0x00	; 0
    197a:	da de       	rcall	.-588    	; 0x1730 <sendAnalogPayload>
    197c:	06 c0       	rjmp	.+12     	; 0x198a <Update+0x184>
		}
	}
	
	else if (controller_mode == controller_mode_analog )
    197e:	81 11       	cpse	r24, r1
    1980:	04 c0       	rjmp	.+8      	; 0x198a <Update+0x184>
	{ 	

		RumbleLargeMotor = Spi_read(1, buttons2);//b2
    1982:	6c 2f       	mov	r22, r28
    1984:	bb de       	rcall	.-650    	; 0x16fc <Spi_read>
    1986:	80 93 50 03 	sts	0x0350, r24
    198a:	80 91 c5 01 	lds	r24, 0x01C5
		sendAnalogPayload(0);
    198e:	8f 5f       	subi	r24, 0xFF	; 255
    1990:	80 93 c5 01 	sts	0x01C5, r24
	}
	
	else if (controller_mode == controller_mode_digital)
    1994:	8b 30       	cpi	r24, 0x0B	; 11
    1996:	08 f4       	brcc	.+2      	; 0x199a <Update+0x194>
	{
		RumbleLargeMotor = Spi_read(0, buttons2);//b2
    1998:	a0 c1       	rjmp	.+832    	; 0x1cda <Update+0x4d4>
    199a:	10 92 c5 01 	sts	0x01C5, r1
    199e:	10 92 c7 01 	sts	0x01C7, r1
				case main_poll: //42 - can also be pulled in config mode. but at times gets stuck, so we need a watch dog.
				RumbleSmallMotor = Spi_read(1, buttons1);//b1
				//mainPollReply(buttons2); doc says pressure is not supported here? so best to not do it unless there are issues	
				mainPollReply(buttons2);
				
				watchDog2++;
    19a2:	9b c1       	rjmp	.+822    	; 0x1cda <Update+0x4d4>
    19a4:	60 e0       	ldi	r22, 0x00	; 0
    19a6:	81 e0       	ldi	r24, 0x01	; 1
    19a8:	a9 de       	rcall	.-686    	; 0x16fc <Spi_read>
    19aa:	80 93 c7 01 	sts	0x01C7, r24
				if (watchDog2 > 10)
    19ae:	81 30       	cpi	r24, 0x01	; 1
    19b0:	99 f4       	brne	.+38     	; 0x19d8 <Update+0x1d2>
				{	//its pulling too many times, exit config mode. 
					watchDog2=0;
    19b2:	80 91 c9 01 	lds	r24, 0x01C9
					mode = NORMAL;
    19b6:	82 30       	cpi	r24, 0x02	; 2
    19b8:	11 f0       	breq	.+4      	; 0x19be <Update+0x1b8>
    19ba:	c4 e0       	ldi	r28, 0x04	; 4
				}
				break;
			 
				case config_mode: //43
				//remainder bytes
				mode = Spi_read(1, 0x00);
    19bc:	07 c0       	rjmp	.+14     	; 0x19cc <Update+0x1c6>
    19be:	cc e0       	ldi	r28, 0x0C	; 12
    19c0:	60 e0       	ldi	r22, 0x00	; 0
    19c2:	81 e0       	ldi	r24, 0x01	; 1
    19c4:	9b de       	rcall	.-714    	; 0x16fc <Spi_read>
    19c6:	c1 50       	subi	r28, 0x01	; 1
				if (mode == 1) //told to enter but we already are.
    19c8:	d9 f7       	brne	.-10     	; 0x19c0 <Update+0x1ba>
    19ca:	f7 cf       	rjmp	.-18     	; 0x19ba <Update+0x1b4>
				{
					//we need to add 12 more for pressure mode or it does not enter the config mode. 
					if (controller_mode == controller_mode_full) { for (char p = 0; p < 12; p++)  Spi_read(1, 0x00); }
    19cc:	60 e0       	ldi	r22, 0x00	; 0
    19ce:	81 e0       	ldi	r24, 0x01	; 1
    19d0:	95 de       	rcall	.-726    	; 0x16fc <Spi_read>
    19d2:	c1 50       	subi	r28, 0x01	; 1
    19d4:	d9 f7       	brne	.-10     	; 0x19cc <Update+0x1c6>
    19d6:	a6 c0       	rjmp	.+332    	; 0x1b24 <Update+0x31e>
    19d8:	60 e0       	ldi	r22, 0x00	; 0
    19da:	81 e0       	ldi	r24, 0x01	; 1
    19dc:	8f de       	rcall	.-738    	; 0x16fc <Spi_read>
    19de:	8a 35       	cpi	r24, 0x5A	; 90
    19e0:	61 f4       	brne	.+24     	; 0x19fa <Update+0x1f4>
    19e2:	60 e0       	ldi	r22, 0x00	; 0
    19e4:	81 e0       	ldi	r24, 0x01	; 1
    19e6:	8a de       	rcall	.-748    	; 0x16fc <Spi_read>
					for(char p=0;p<4;p++) Spi_read(1, 0x00);  
    19e8:	60 e0       	ldi	r22, 0x00	; 0
    19ea:	81 e0       	ldi	r24, 0x01	; 1
    19ec:	87 de       	rcall	.-754    	; 0x16fc <Spi_read>
    19ee:	60 e0       	ldi	r22, 0x00	; 0
    19f0:	81 e0       	ldi	r24, 0x01	; 1
    19f2:	84 de       	rcall	.-760    	; 0x16fc <Spi_read>
    19f4:	60 e0       	ldi	r22, 0x00	; 0
					Spi_read(0, 0x00); 				
					break;
					
				} 		

				unsigned char reply = Spi_read(1, 0x00); //if 0 send 1 0.  if 5a send 4 0's
    19f6:	80 e0       	ldi	r24, 0x00	; 0
    19f8:	81 de       	rcall	.-766    	; 0x16fc <Spi_read>
    19fa:	80 91 c8 01 	lds	r24, 0x01C8

				if ( reply == 0x5a)
    19fe:	80 93 c9 01 	sts	0x01C9, r24
				{			
					for(char p=0;p<3;p++) Spi_read(1, 0x00); 
    1a02:	6b c1       	rjmp	.+726    	; 0x1cda <Update+0x4d4>
    1a04:	60 e0       	ldi	r22, 0x00	; 0
    1a06:	81 e0       	ldi	r24, 0x01	; 1
    1a08:	79 de       	rcall	.-782    	; 0x16fc <Spi_read>
    1a0a:	60 e0       	ldi	r22, 0x00	; 0
    1a0c:	81 e0       	ldi	r24, 0x01	; 1
    1a0e:	76 de       	rcall	.-788    	; 0x16fc <Spi_read>
    1a10:	62 e0       	ldi	r22, 0x02	; 2
    1a12:	10 c0       	rjmp	.+32     	; 0x1a34 <Update+0x22e>
    1a14:	81 e0       	ldi	r24, 0x01	; 1
    1a16:	80 93 c2 01 	sts	0x01C2, r24
					Spi_read(0, 0x00); 
    1a1a:	90 91 c8 01 	lds	r25, 0x01C8
    1a1e:	91 11       	cpse	r25, r1
    1a20:	02 c0       	rjmp	.+4      	; 0x1a26 <Update+0x220>
				}

				//move pre to actual. We do not want to set this stuff in config mode or byte replies are caculate wrong. 
				controller_mode = pre_controller_mode; 
    1a22:	80 93 c8 01 	sts	0x01C8, r24
    1a26:	6f ef       	ldi	r22, 0xFF	; 255
    1a28:	81 e0       	ldi	r24, 0x01	; 1
				break;
    1a2a:	68 de       	rcall	.-816    	; 0x16fc <Spi_read>
				
				case config_analog_buttons: // 40 - Not needed but could be used, so atleast reply corretly. 
				Spi_read(1, 0x00);//you will get one of these 0x40's for each button and this is the button ID 0-12
    1a2c:	6f ef       	ldi	r22, 0xFF	; 255
    1a2e:	81 e0       	ldi	r24, 0x01	; 1
    1a30:	65 de       	rcall	.-822    	; 0x16fc <Spi_read>
    1a32:	63 e0       	ldi	r22, 0x03	; 3
				Spi_read(1, 0x00);//assuming a 2 means button is actvie on the pressure status
    1a34:	81 e0       	ldi	r24, 0x01	; 1
    1a36:	62 de       	rcall	.-828    	; 0x16fc <Spi_read>
    1a38:	60 e0       	ldi	r22, 0x00	; 0
    1a3a:	81 e0       	ldi	r24, 0x01	; 1
				Spi_read(1, 0x02);//always a 2 I guess. 
    1a3c:	5f de       	rcall	.-834    	; 0x16fc <Spi_read>
    1a3e:	60 e0       	ldi	r22, 0x00	; 0
				Spi_read(1, 0x00);
				Spi_read(0, 0x5a);
				break;
				
				case config_buttons: //41 - always report the payload for analog, not supporting digital.
				_config_timer=1;
    1a40:	81 e0       	ldi	r24, 0x01	; 1
    1a42:	5c de       	rcall	.-840    	; 0x16fc <Spi_read>
    1a44:	6a e5       	ldi	r22, 0x5A	; 90
				if (pre_controller_mode == controller_mode_digital) pre_controller_mode=1;//should be analog if the psx is asking for this. 
    1a46:	6f c0       	rjmp	.+222    	; 0x1b26 <Update+0x320>
    1a48:	60 e0       	ldi	r22, 0x00	; 0
    1a4a:	81 e0       	ldi	r24, 0x01	; 1
    1a4c:	57 de       	rcall	.-850    	; 0x16fc <Spi_read>
    1a4e:	80 93 c8 01 	sts	0x01C8, r24
				Spi_read(1, 0xff);// each of the 18 bits tells the main pull what button to read (not sure why 0xfe here?)
    1a52:	80 91 c3 01 	lds	r24, 0x01C3
    1a56:	81 11       	cpse	r24, r1
    1a58:	10 92 c8 01 	sts	0x01C8, r1
				Spi_read(1, 0xff);// I see no reason to remove any
    1a5c:	c4 e0       	ldi	r28, 0x04	; 4
    1a5e:	60 e0       	ldi	r22, 0x00	; 0
    1a60:	81 e0       	ldi	r24, 0x01	; 1
				Spi_read(1, 0x03);// maybe some controllers will send button always on this will allow that to be masked out.
    1a62:	4c de       	rcall	.-872    	; 0x16fc <Spi_read>
    1a64:	c1 50       	subi	r28, 0x01	; 1
    1a66:	d9 f7       	brne	.-10     	; 0x1a5e <Update+0x258>
    1a68:	5d c0       	rjmp	.+186    	; 0x1b24 <Update+0x31e>
				Spi_read(1, 0x00);
    1a6a:	81 e0       	ldi	r24, 0x01	; 1
    1a6c:	80 93 c2 01 	sts	0x01C2, r24
    1a70:	80 91 c3 01 	lds	r24, 0x01C3
				Spi_read(1, 0x00);
    1a74:	88 23       	and	r24, r24
    1a76:	11 f0       	breq	.+4      	; 0x1a7c <Update+0x276>
    1a78:	60 e0       	ldi	r22, 0x00	; 0
				Spi_read(0, 0x5a);
    1a7a:	07 c0       	rjmp	.+14     	; 0x1a8a <Update+0x284>
    1a7c:	80 91 7f 03 	lds	r24, 0x037F
			break;

				case config_controller_mode: // 44
				pre_controller_mode = 
			    Spi_read(1, 0x00);//this will be 1 for analog 0 for digital
    1a80:	88 23       	and	r24, r24
    1a82:	11 f0       	breq	.+4      	; 0x1a88 <Update+0x282>
    1a84:	63 e0       	ldi	r22, 0x03	; 3
				Spi_read(1, 0x00);
				Spi_read(0, 0x5a);
			break;

				case config_controller_mode: // 44
				pre_controller_mode = 
    1a86:	01 c0       	rjmp	.+2      	; 0x1a8a <Update+0x284>
    1a88:	61 e0       	ldi	r22, 0x01	; 1
			    Spi_read(1, 0x00);//this will be 1 for analog 0 for digital
				if ( internal_DPAD_mode ) pre_controller_mode=controller_mode_digital;//override
    1a8a:	81 e0       	ldi	r24, 0x01	; 1
    1a8c:	37 de       	rcall	.-914    	; 0x16fc <Spi_read>
    1a8e:	62 e0       	ldi	r22, 0x02	; 2
    1a90:	81 e0       	ldi	r24, 0x01	; 1
    1a92:	34 de       	rcall	.-920    	; 0x16fc <Spi_read>
				//remainder bytes
				mode = Spi_read(1, 0x00);
				if (mode == 1) //told to enter but we already are.
				{
					//we need to add 12 more for pressure mode or it does not enter the config mode. 
					if (controller_mode == controller_mode_full) { for (char p = 0; p < 12; p++)  Spi_read(1, 0x00); }
    1a94:	61 e0       	ldi	r22, 0x01	; 1

				case config_controller_mode: // 44
				pre_controller_mode = 
			    Spi_read(1, 0x00);//this will be 1 for analog 0 for digital
				if ( internal_DPAD_mode ) pre_controller_mode=controller_mode_digital;//override
				for(char p=0;p<4;p++) Spi_read(1, 0x00); //3 if locked 0 normally
    1a96:	80 91 c3 01 	lds	r24, 0x01C3
    1a9a:	81 11       	cpse	r24, r1
    1a9c:	60 e0       	ldi	r22, 0x00	; 0
    1a9e:	81 e0       	ldi	r24, 0x01	; 1
    1aa0:	2d de       	rcall	.-934    	; 0x16fc <Spi_read>
    1aa2:	62 e0       	ldi	r22, 0x02	; 2
				Spi_read(0, 0x00);
				break;
				
				case config_status: // 45
			 	_config_timer=1; 
    1aa4:	27 c0       	rjmp	.+78     	; 0x1af4 <Update+0x2ee>
    1aa6:	60 e0       	ldi	r22, 0x00	; 0
    1aa8:	81 e0       	ldi	r24, 0x01	; 1
				//tell both slave and master what we are now. 
				if ( internal_DPAD_mode ) Spi_read(1, 0 ); //digitial
    1aaa:	28 de       	rcall	.-944    	; 0x16fc <Spi_read>
    1aac:	81 11       	cpse	r24, r1
    1aae:	02 c0       	rjmp	.+4      	; 0x1ab4 <Update+0x2ae>
    1ab0:	ca e0       	ldi	r28, 0x0A	; 10
    1ab2:	01 c0       	rjmp	.+2      	; 0x1ab6 <Update+0x2b0>
    1ab4:	c4 e1       	ldi	r28, 0x14	; 20
				else if ( Controller.Pressure )Spi_read(1, 3 ); //DS2
    1ab6:	60 e0       	ldi	r22, 0x00	; 0
    1ab8:	81 e0       	ldi	r24, 0x01	; 1
    1aba:	20 de       	rcall	.-960    	; 0x16fc <Spi_read>
    1abc:	61 e0       	ldi	r22, 0x01	; 1
    1abe:	81 e0       	ldi	r24, 0x01	; 1
    1ac0:	1d de       	rcall	.-966    	; 0x16fc <Spi_read>
				else  Spi_read(1, 1 ); //DS or GH
    1ac2:	ca 30       	cpi	r28, 0x0A	; 10
    1ac4:	11 f4       	brne	.+4      	; 0x1aca <Update+0x2c4>
    1ac6:	62 e0       	ldi	r22, 0x02	; 2
    1ac8:	01 c0       	rjmp	.+2      	; 0x1acc <Update+0x2c6>
				
				
				Spi_read(1, 0x02);//unknown.
    1aca:	61 e0       	ldi	r22, 0x01	; 1
    1acc:	81 e0       	ldi	r24, 0x01	; 1
    1ace:	16 de       	rcall	.-980    	; 0x16fc <Spi_read>
    1ad0:	61 e0       	ldi	r22, 0x01	; 1
				Spi_read(1, ( internal_DPAD_mode ) ? 0:1);//1 LED on 0 off : must start off
    1ad2:	ca 30       	cpi	r28, 0x0A	; 10
    1ad4:	09 f4       	brne	.+2      	; 0x1ad8 <Update+0x2d2>
    1ad6:	60 e0       	ldi	r22, 0x00	; 0
    1ad8:	81 e0       	ldi	r24, 0x01	; 1
    1ada:	10 de       	rcall	.-992    	; 0x16fc <Spi_read>
    1adc:	6c 2f       	mov	r22, r28
    1ade:	23 c0       	rjmp	.+70     	; 0x1b26 <Update+0x320>
    1ae0:	60 e0       	ldi	r22, 0x00	; 0
				Spi_read(1, 0x02);//unknown.
    1ae2:	81 e0       	ldi	r24, 0x01	; 1
    1ae4:	0b de       	rcall	.-1002   	; 0x16fc <Spi_read>
				Spi_read(0, 0x00); 
				break;
				
				case config_unknown1: // 46
				out = 0x0a;
				if ( Spi_read(1, 0x00) ) out=0x14;
    1ae6:	60 e0       	ldi	r22, 0x00	; 0
    1ae8:	81 e0       	ldi	r24, 0x01	; 1
    1aea:	08 de       	rcall	.-1008   	; 0x16fc <Spi_read>
    1aec:	62 e0       	ldi	r22, 0x02	; 2
    1aee:	81 e0       	ldi	r24, 0x01	; 1
    1af0:	05 de       	rcall	.-1014   	; 0x16fc <Spi_read>
				Spi_read(1, 0x01);  
				Spi_read(0, 0x00); 
				break;
				
				case config_unknown1: // 46
				out = 0x0a;
    1af2:	60 e0       	ldi	r22, 0x00	; 0
    1af4:	81 e0       	ldi	r24, 0x01	; 1
				if ( Spi_read(1, 0x00) ) out=0x14;
    1af6:	02 de       	rcall	.-1020   	; 0x16fc <Spi_read>
				//0,1,2,0,a 
				//0,1,1,1,14
				Spi_read(1, 0x00);
    1af8:	61 e0       	ldi	r22, 0x01	; 1
    1afa:	12 c0       	rjmp	.+36     	; 0x1b20 <Update+0x31a>
    1afc:	60 e0       	ldi	r22, 0x00	; 0
    1afe:	81 e0       	ldi	r24, 0x01	; 1
				Spi_read(1, (out==0x0a) ? 0x01:0x01 );
    1b00:	fd dd       	rcall	.-1030   	; 0x16fc <Spi_read>
    1b02:	81 11       	cpse	r24, r1
    1b04:	02 c0       	rjmp	.+4      	; 0x1b0a <Update+0x304>
    1b06:	c4 e0       	ldi	r28, 0x04	; 4
				Spi_read(1, (out==0x0a) ? 0x02:0x01 );
    1b08:	01 c0       	rjmp	.+2      	; 0x1b0c <Update+0x306>
    1b0a:	c7 e0       	ldi	r28, 0x07	; 7
    1b0c:	60 e0       	ldi	r22, 0x00	; 0
    1b0e:	81 e0       	ldi	r24, 0x01	; 1
    1b10:	f5 dd       	rcall	.-1046   	; 0x16fc <Spi_read>
    1b12:	60 e0       	ldi	r22, 0x00	; 0
    1b14:	81 e0       	ldi	r24, 0x01	; 1
    1b16:	f2 dd       	rcall	.-1052   	; 0x16fc <Spi_read>
				Spi_read(1, (out==0x0a) ? 0x00:0x01 );
    1b18:	6c 2f       	mov	r22, r28
    1b1a:	81 e0       	ldi	r24, 0x01	; 1
    1b1c:	ef dd       	rcall	.-1058   	; 0x16fc <Spi_read>
    1b1e:	60 e0       	ldi	r22, 0x00	; 0
    1b20:	81 e0       	ldi	r24, 0x01	; 1
    1b22:	ec dd       	rcall	.-1064   	; 0x16fc <Spi_read>
    1b24:	60 e0       	ldi	r22, 0x00	; 0
				Spi_read(0, out );
    1b26:	80 e0       	ldi	r24, 0x00	; 0
    1b28:	e9 dd       	rcall	.-1070   	; 0x16fc <Spi_read>
				break;
				
				case config_unknown2: // 47
				Spi_read(1, 0x00);
    1b2a:	d7 c0       	rjmp	.+430    	; 0x1cda <Update+0x4d4>
    1b2c:	60 e0       	ldi	r22, 0x00	; 0
    1b2e:	81 e0       	ldi	r24, 0x01	; 1
    1b30:	e5 dd       	rcall	.-1078   	; 0x16fc <Spi_read>
				Spi_read(1, 0x00);
    1b32:	61 e0       	ldi	r22, 0x01	; 1
    1b34:	81 e0       	ldi	r24, 0x01	; 1
    1b36:	e2 dd       	rcall	.-1084   	; 0x16fc <Spi_read>
    1b38:	6f ef       	ldi	r22, 0xFF	; 255
				Spi_read(1, 0x02);
    1b3a:	81 e0       	ldi	r24, 0x01	; 1
    1b3c:	df dd       	rcall	.-1090   	; 0x16fc <Spi_read>
    1b3e:	6f ef       	ldi	r22, 0xFF	; 255
    1b40:	81 e0       	ldi	r24, 0x01	; 1
				Spi_read(1, 0x00);
    1b42:	dc dd       	rcall	.-1096   	; 0x16fc <Spi_read>
    1b44:	6f ef       	ldi	r22, 0xFF	; 255
    1b46:	81 e0       	ldi	r24, 0x01	; 1
    1b48:	d9 dd       	rcall	.-1102   	; 0x16fc <Spi_read>
				Spi_read(1, 0x01);//1 for DS 0 for GH
    1b4a:	6f ef       	ldi	r22, 0xFF	; 255
    1b4c:	ec cf       	rjmp	.-40     	; 0x1b26 <Update+0x320>
				Spi_read(0, 0x00);
				break;
				
				case config_unknown3: // 4c
				out =0x04;
				if ( Spi_read(1, 0x00) ) out=0x07;//seen 6 and 7 here. 
    1b4e:	81 e0       	ldi	r24, 0x01	; 1
    1b50:	80 93 c1 01 	sts	0x01C1, r24
    1b54:	82 e0       	ldi	r24, 0x02	; 2
    1b56:	80 93 c8 01 	sts	0x01C8, r24
				Spi_read(1, 0x01);//1 for DS 0 for GH
				Spi_read(0, 0x00);
				break;
				
				case config_unknown3: // 4c
				out =0x04;
    1b5a:	60 e0       	ldi	r22, 0x00	; 0
    1b5c:	81 e0       	ldi	r24, 0x01	; 1
				if ( Spi_read(1, 0x00) ) out=0x07;//seen 6 and 7 here. 
    1b5e:	ce dd       	rcall	.-1124   	; 0x16fc <Spi_read>
				Spi_read(1, 0x00);
    1b60:	c4 e0       	ldi	r28, 0x04	; 4
    1b62:	60 e0       	ldi	r22, 0x00	; 0
    1b64:	81 e0       	ldi	r24, 0x01	; 1
    1b66:	ca dd       	rcall	.-1132   	; 0x16fc <Spi_read>
				Spi_read(1, 0x00);
    1b68:	c1 50       	subi	r28, 0x01	; 1
    1b6a:	d9 f7       	brne	.-10     	; 0x1b62 <Update+0x35c>
    1b6c:	db cf       	rjmp	.-74     	; 0x1b24 <Update+0x31e>
    1b6e:	81 11       	cpse	r24, r1
				Spi_read(1, out );
    1b70:	b4 c0       	rjmp	.+360    	; 0x1cda <Update+0x4d4>
    1b72:	80 91 c9 01 	lds	r24, 0x01C9
    1b76:	88 23       	and	r24, r24
				Spi_read(1, 0x00);
    1b78:	81 f0       	breq	.+32     	; 0x1b9a <Update+0x394>
    1b7a:	90 91 86 03 	lds	r25, 0x0386
    1b7e:	99 37       	cpi	r25, 0x79	; 121
				Spi_read(0, 0x00);
    1b80:	21 f4       	brne	.+8      	; 0x1b8a <Update+0x384>
    1b82:	82 30       	cpi	r24, 0x02	; 2
    1b84:	61 f0       	breq	.+24     	; 0x1b9e <Update+0x398>
    1b86:	63 e7       	ldi	r22, 0x73	; 115
				break;
    1b88:	0f c0       	rjmp	.+30     	; 0x1ba8 <Update+0x3a2>
				
				case config_vibration: // 4d 
				//both master and slave send the 0,1 I think this is always the same, not sure I get how this would work.
				Spi_read(1, 0x00);//00 means small right
    1b8a:	93 33       	cpi	r25, 0x33	; 51
    1b8c:	51 f0       	breq	.+20     	; 0x1ba2 <Update+0x39c>
    1b8e:	9f 37       	cpi	r25, 0x7F	; 127
    1b90:	51 f0       	breq	.+20     	; 0x1ba6 <Update+0x3a0>
				Spi_read(1, 0x01);//01 means large left
    1b92:	93 35       	cpi	r25, 0x53	; 83
    1b94:	c1 f7       	brne	.-16     	; 0x1b86 <Update+0x380>
    1b96:	63 e5       	ldi	r22, 0x53	; 83
    1b98:	07 c0       	rjmp	.+14     	; 0x1ba8 <Update+0x3a2>
				for(char p=0;p<3;p++) Spi_read(1, 0xff); 
    1b9a:	61 e4       	ldi	r22, 0x41	; 65
    1b9c:	05 c0       	rjmp	.+10     	; 0x1ba8 <Update+0x3a2>
    1b9e:	69 e7       	ldi	r22, 0x79	; 121
    1ba0:	03 c0       	rjmp	.+6      	; 0x1ba8 <Update+0x3a2>
    1ba2:	63 e2       	ldi	r22, 0x23	; 35
    1ba4:	01 c0       	rjmp	.+2      	; 0x1ba8 <Update+0x3a2>
    1ba6:	63 ee       	ldi	r22, 0xE3	; 227
    1ba8:	90 91 c4 01 	lds	r25, 0x01C4
    1bac:	89 17       	cp	r24, r25
    1bae:	29 f0       	breq	.+10     	; 0x1bba <Update+0x3b4>
    1bb0:	90 91 c2 01 	lds	r25, 0x01C2
				Spi_read(0, 0xff);
    1bb4:	9e 5f       	subi	r25, 0xFE	; 254
				break;
								
				case config_analog_responce: // 4f
				_pressure_timer =1;
    1bb6:	90 93 c2 01 	sts	0x01C2, r25
    1bba:	80 93 c4 01 	sts	0x01C4, r24
				 pre_controller_mode = controller_mode_full;
    1bbe:	81 e0       	ldi	r24, 0x01	; 1
    1bc0:	9d dd       	rcall	.-1222   	; 0x16fc <Spi_read>
				unsigned char bits_ToRead =// nots sure if this is a mask for the console asking from controller or telling the controller
    1bc2:	18 2f       	mov	r17, r24
    1bc4:	6a e5       	ldi	r22, 0x5A	; 90
    1bc6:	81 e0       	ldi	r24, 0x01	; 1
    1bc8:	99 dd       	rcall	.-1230   	; 0x16fc <Spi_read>
    1bca:	6d 2f       	mov	r22, r29
				Spi_read(1, 0x00);
				for(char p=0;p<4;p++) Spi_read(1, 0x00); //ff - 18 bits [11] digital [1112] analg [111111111111] pressure
    1bcc:	81 e0       	ldi	r24, 0x01	; 1
    1bce:	13 34       	cpi	r17, 0x43	; 67
    1bd0:	71 f5       	brne	.+92     	; 0x1c2e <Update+0x428>
    1bd2:	94 dd       	rcall	.-1240   	; 0x16fc <Spi_read>
    1bd4:	80 93 c7 01 	sts	0x01C7, r24
    1bd8:	81 11       	cpse	r24, r1
				Spi_read(0, 0x00);
				//we could calculate what pressure bits to enable, but why? Maybe later on... but if we get here, it was ds2 in command 45
				break;
			}			
		}
		else if (mode == NORMAL)
    1bda:	02 c0       	rjmp	.+4      	; 0x1be0 <Update+0x3da>
    1bdc:	60 e0       	ldi	r22, 0x00	; 0
			//the startup condition is analog controller but in digital mode. The psx must go thrue its own init startup
			//so we can not just test for that and change modes. The ps2 controller seems to skip a beeat forcing
			//the psx to do its init anyways but other conrolleer do not. 

			unsigned char type= pad_digitial;
			if (controller_mode ) //not digital 
    1bde:	25 c0       	rjmp	.+74     	; 0x1c2a <Update+0x424>
    1be0:	80 91 c1 01 	lds	r24, 0x01C1
    1be4:	81 11       	cpse	r24, r1
			{
				if ( Controller.Type == 121 && controller_mode == controller_mode_full ) type = pad_pressure;//must wait for full mode!
    1be6:	2a c0       	rjmp	.+84     	; 0x1c3c <Update+0x436>
    1be8:	80 91 c2 01 	lds	r24, 0x01C2
    1bec:	81 11       	cpse	r24, r1
    1bee:	30 c0       	rjmp	.+96     	; 0x1c50 <Update+0x44a>
    1bf0:	80 91 c9 01 	lds	r24, 0x01C9
				else if ( Controller.Type == 51 ) type = pad_negcon;//not lining up with ID's above.
				else if ( Controller.Type == 127 ) type = pad_jogcon;//uses two pressures and does not send all 12.
				else if ( Controller.Type == 83 ) type = pad_flight;//will show motors but has none in psx system, think that is ok.
				//default
				//else if ( Controller.Type == 115 ) type = pad_analog;
				else type = pad_analog;
    1bf4:	82 30       	cpi	r24, 0x02	; 2

			unsigned char type= pad_digitial;
			if (controller_mode ) //not digital 
			{
				if ( Controller.Type == 121 && controller_mode == controller_mode_full ) type = pad_pressure;//must wait for full mode!
				else if ( Controller.Type == 51 ) type = pad_negcon;//not lining up with ID's above.
    1bf6:	09 f0       	breq	.+2      	; 0x1bfa <Update+0x3f4>
    1bf8:	4a c0       	rjmp	.+148    	; 0x1c8e <Update+0x488>
				else if ( Controller.Type == 127 ) type = pad_jogcon;//uses two pressures and does not send all 12.
    1bfa:	6c 2f       	mov	r22, r28
    1bfc:	81 e0       	ldi	r24, 0x01	; 1
				else if ( Controller.Type == 83 ) type = pad_flight;//will show motors but has none in psx system, think that is ok.
    1bfe:	7e dd       	rcall	.-1284   	; 0x16fc <Spi_read>
    1c00:	80 93 50 03 	sts	0x0350, r24
    1c04:	81 e0       	ldi	r24, 0x01	; 1
			//note we can not make the code see digital to analog change because that would cause an endless loop.
			//the startup condition is analog controller but in digital mode. The psx must go thrue its own init startup
			//so we can not just test for that and change modes. The ps2 controller seems to skip a beeat forcing
			//the psx to do its init anyways but other conrolleer do not. 

			unsigned char type= pad_digitial;
    1c06:	94 dd       	rcall	.-1240   	; 0x1730 <sendAnalogPayload>
    1c08:	80 91 c9 01 	lds	r24, 0x01C9
			if (controller_mode ) //not digital 
			{
				if ( Controller.Type == 121 && controller_mode == controller_mode_full ) type = pad_pressure;//must wait for full mode!
    1c0c:	82 30       	cpi	r24, 0x02	; 2
				else if ( Controller.Type == 51 ) type = pad_negcon;//not lining up with ID's above.
    1c0e:	09 f0       	breq	.+2      	; 0x1c12 <Update+0x40c>
    1c10:	4d c0       	rjmp	.+154    	; 0x1cac <Update+0x4a6>
				else if ( Controller.Type == 127 ) type = pad_jogcon;//uses two pressures and does not send all 12.
    1c12:	c5 e3       	ldi	r28, 0x35	; 53
				//else if ( Controller.Type == 115 ) type = pad_analog;
				else type = pad_analog;
			} 

			//watch for a pad change so the timer take effect. 
			if (controller_mode != prev_mode) _config_timer += 2;
    1c14:	d3 e0       	ldi	r29, 0x03	; 3
    1c16:	69 91       	ld	r22, Y+
    1c18:	81 e0       	ldi	r24, 0x01	; 1
    1c1a:	70 dd       	rcall	.-1312   	; 0x16fc <Spi_read>
    1c1c:	83 e0       	ldi	r24, 0x03	; 3
    1c1e:	c0 34       	cpi	r28, 0x40	; 64
    1c20:	d8 07       	cpc	r29, r24
    1c22:	c9 f7       	brne	.-14     	; 0x1c16 <Update+0x410>
    1c24:	60 91 40 03 	lds	r22, 0x0340
			prev_mode	=controller_mode;
    1c28:	80 e0       	ldi	r24, 0x00	; 0
					
			
			unsigned char modeCheck = Spi_read(1, type);//check for config mode
    1c2a:	68 dd       	rcall	.-1328   	; 0x16fc <Spi_read>
    1c2c:	3f c0       	rjmp	.+126    	; 0x1cac <Update+0x4a6>
    1c2e:	66 dd       	rcall	.-1332   	; 0x16fc <Spi_read>
    1c30:	80 93 41 03 	sts	0x0341, r24
			Spi_read(1, 0x5a);//idle
    1c34:	80 91 c1 01 	lds	r24, 0x01C1
    1c38:	88 23       	and	r24, r24

			if (modeCheck==config_mode)
			{	 
				mode=Spi_read(1, buttons1);//b1 
    1c3a:	31 f0       	breq	.+12     	; 0x1c48 <Update+0x442>
    1c3c:	81 50       	subi	r24, 0x01	; 1
					
			
			unsigned char modeCheck = Spi_read(1, type);//check for config mode
			Spi_read(1, 0x5a);//idle

			if (modeCheck==config_mode)
    1c3e:	80 93 c1 01 	sts	0x01C1, r24
			{	 
				mode=Spi_read(1, buttons1);//b1 
    1c42:	6c 2f       	mov	r22, r28
    1c44:	81 e0       	ldi	r24, 0x01	; 1
    1c46:	26 c0       	rjmp	.+76     	; 0x1c94 <Update+0x48e>
    1c48:	80 91 c2 01 	lds	r24, 0x01C2

				if (mode == 0 ) //told to exit but we already are. should send a 0. Not sure this is right. 
    1c4c:	88 23       	and	r24, r24
				{
					Spi_read(0, 0x00);
    1c4e:	31 f0       	breq	.+12     	; 0x1c5c <Update+0x456>
    1c50:	81 50       	subi	r24, 0x01	; 1
	// type as soon as our code does. The console expects the old  //
	// type to still be reporting for a few polls. TRying to fake  //
	// this is hard so we just leep track of the changes and adapt.// 
	/////////////////////////////////////////////////////////////////
	
	if (  _pressure_timer > 0 ) //something like the config timer only for pressure, I see a 79 run as analog only then a 79 as a config timer.
    1c52:	80 93 c2 01 	sts	0x01C2, r24
    1c56:	6c 2f       	mov	r22, r28
    1c58:	80 e0       	ldi	r24, 0x00	; 0
		RumbleLargeMotor = Spi_read(1, buttons2);//b2
		sendAnalogPayload(0);
		return;
	}

	if ( _config_timer > 0 ) //once a config mode is ran it will pull and eventualy send a 1 in buttons1 to indicate its accepted, wait for this.
    1c5a:	25 c0       	rjmp	.+74     	; 0x1ca6 <Update+0x4a0>
    1c5c:	80 91 c9 01 	lds	r24, 0x01C9
    1c60:	82 30       	cpi	r24, 0x02	; 2
	}
	////
	///
	//

	if (controller_mode == controller_mode_full)
    1c62:	a9 f4       	brne	.+42     	; 0x1c8e <Update+0x488>
    1c64:	6c 2f       	mov	r22, r28
    1c66:	81 e0       	ldi	r24, 0x01	; 1
    1c68:	49 dd       	rcall	.-1390   	; 0x16fc <Spi_read>
    1c6a:	80 93 50 03 	sts	0x0350, r24
	{ 
		RumbleLargeMotor = Spi_read(1, buttons2);//b2	 
    1c6e:	81 e0       	ldi	r24, 0x01	; 1
    1c70:	5f dd       	rcall	.-1346   	; 0x1730 <sendAnalogPayload>
    1c72:	80 91 c9 01 	lds	r24, 0x01C9
    1c76:	82 30       	cpi	r24, 0x02	; 2
		sendAnalogPayload(1);
    1c78:	c9 f4       	brne	.+50     	; 0x1cac <Update+0x4a6>
    1c7a:	c5 e3       	ldi	r28, 0x35	; 53
    1c7c:	d3 e0       	ldi	r29, 0x03	; 3
		if (controller_mode == controller_mode_full)//this second check is needed, as it may have been reset in sendAnalogPayload
    1c7e:	69 91       	ld	r22, Y+
    1c80:	81 e0       	ldi	r24, 0x01	; 1
    1c82:	3c dd       	rcall	.-1416   	; 0x16fc <Spi_read>
    1c84:	83 e0       	ldi	r24, 0x03	; 3
    1c86:	c0 34       	cpi	r28, 0x40	; 64
    1c88:	d8 07       	cpc	r29, r24
    1c8a:	c9 f7       	brne	.-14     	; 0x1c7e <Update+0x478>
		{
			for(char p=0;p<11;p++) Spi_read(1, pressureData[p]);
    1c8c:	cb cf       	rjmp	.-106    	; 0x1c24 <Update+0x41e>
    1c8e:	81 30       	cpi	r24, 0x01	; 1
    1c90:	39 f4       	brne	.+14     	; 0x1ca0 <Update+0x49a>
    1c92:	6c 2f       	mov	r22, r28
    1c94:	33 dd       	rcall	.-1434   	; 0x16fc <Spi_read>
    1c96:	80 93 50 03 	sts	0x0350, r24
    1c9a:	80 e0       	ldi	r24, 0x00	; 0
			Spi_read(0, pressureData[11]);
    1c9c:	49 dd       	rcall	.-1390   	; 0x1730 <sendAnalogPayload>
    1c9e:	06 c0       	rjmp	.+12     	; 0x1cac <Update+0x4a6>
    1ca0:	81 11       	cpse	r24, r1
    1ca2:	04 c0       	rjmp	.+8      	; 0x1cac <Update+0x4a6>
    1ca4:	6c 2f       	mov	r22, r28
    1ca6:	2a dd       	rcall	.-1452   	; 0x16fc <Spi_read>
				
				
			}
			else //normal
			{
				RumbleSmallMotor = Spi_read(1, buttons1);//b1 
    1ca8:	80 93 50 03 	sts	0x0350, r24
    1cac:	40 91 83 03 	lds	r20, 0x0383
	// type as soon as our code does. The console expects the old  //
	// type to still be reporting for a few polls. TRying to fake  //
	// this is hard so we just leep track of the changes and adapt.// 
	/////////////////////////////////////////////////////////////////
	
	if (  _pressure_timer > 0 ) //something like the config timer only for pressure, I see a 79 run as analog only then a 79 as a config timer.
    1cb0:	24 2f       	mov	r18, r20
    1cb2:	30 e0       	ldi	r19, 0x00	; 0
    1cb4:	80 91 c3 01 	lds	r24, 0x01C3
	{
		_pressure_timer--;
    1cb8:	90 e0       	ldi	r25, 0x00	; 0
    1cba:	28 17       	cp	r18, r24
    1cbc:	39 07       	cpc	r19, r25
		RumbleLargeMotor = Spi_read(1, buttons2);//b2
    1cbe:	69 f0       	breq	.+26     	; 0x1cda <Update+0x4d4>
    1cc0:	40 93 c3 01 	sts	0x01C3, r20
		sendAnalogPayload(0);
		return;
	}

	if ( _config_timer > 0 ) //once a config mode is ran it will pull and eventualy send a 1 in buttons1 to indicate its accepted, wait for this.
    1cc4:	81 e0       	ldi	r24, 0x01	; 1
    1cc6:	90 91 c9 01 	lds	r25, 0x01C9
    1cca:	91 11       	cpse	r25, r1
	{
		_config_timer--;
    1ccc:	80 e0       	ldi	r24, 0x00	; 0
    1cce:	80 93 c9 01 	sts	0x01C9, r24
		RumbleLargeMotor = Spi_read(0, buttons2);//b2
    1cd2:	80 93 c4 01 	sts	0x01C4, r24
    1cd6:	80 93 c8 01 	sts	0x01C8, r24
	}
	////
	///
	//

	if (controller_mode == controller_mode_full)
    1cda:	85 e3       	ldi	r24, 0x35	; 53
    1cdc:	8a 95       	dec	r24
    1cde:	f1 f7       	brne	.-4      	; 0x1cdc <Update+0x4d6>
	{ 
		RumbleLargeMotor = Spi_read(1, buttons2);//b2	 
    1ce0:	00 00       	nop
    1ce2:	8c b5       	in	r24, 0x2c	; 44
    1ce4:	8f 7b       	andi	r24, 0xBF	; 191
    1ce6:	8c bd       	out	0x2c, r24	; 44
    1ce8:	84 b1       	in	r24, 0x04	; 4
    1cea:	87 7e       	andi	r24, 0xE7	; 231
		sendAnalogPayload(1);
    1cec:	84 b9       	out	0x04, r24	; 4
    1cee:	df 91       	pop	r29
    1cf0:	cf 91       	pop	r28
		if (controller_mode == controller_mode_full)//this second check is needed, as it may have been reset in sendAnalogPayload
    1cf2:	1f 91       	pop	r17
    1cf4:	08 95       	ret
    1cf6:	df ee       	ldi	r29, 0xEF	; 239
    1cf8:	b5 cd       	rjmp	.-1174   	; 0x1864 <Update+0x5e>
    1cfa:	df ed       	ldi	r29, 0xDF	; 223
    1cfc:	b3 cd       	rjmp	.-1178   	; 0x1864 <Update+0x5e>

00001cfe <psxGetConsole>:
		{
			for(char p=0;p<11;p++) Spi_read(1, pressureData[p]);
    1cfe:	80 e0       	ldi	r24, 0x00	; 0
    1d00:	91 e0       	ldi	r25, 0x01	; 1
    1d02:	08 95       	ret

00001d04 <doWork>:

/*********** prototypes *************/
static void Init(void);
static void Update(void);
static unsigned char Probe(void);
static void doWork(void){};
    1d04:	08 95       	ret

00001d06 <pollfunc>:
};
static volatile char performupdate;

static void pollfunc(void)
{
	performupdate = 1;
    1d06:	81 e0       	ldi	r24, 0x01	; 1
    1d08:	80 93 ca 01 	sts	0x01CA, r24
    1d0c:	08 95       	ret

00001d0e <CleanUp>:
}

void CleanUp(void)
{
 
  TWCR &= 0xFF ^ _BV(TWEN);	
    1d0e:	ec eb       	ldi	r30, 0xBC	; 188
    1d10:	f0 e0       	ldi	r31, 0x00	; 0
    1d12:	80 81       	ld	r24, Z
    1d14:	8b 7f       	andi	r24, 0xFB	; 251
    1d16:	80 83       	st	Z, r24
    1d18:	08 95       	ret

00001d1a <Probe>:

 unsigned char Probe(void)
{

	//this is an endless wait. The i2c Ninendo made has a 3.5 second paulse. The slave must answer and we can;t wait around that long. 
	performupdate=0;
    1d1a:	10 92 ca 01 	sts	0x01CA, r1

	while (1)
	{
		if (performupdate) return WII;
    1d1e:	80 91 ca 01 	lds	r24, 0x01CA
    1d22:	88 23       	and	r24, r24
    1d24:	e1 f3       	breq	.-8      	; 0x1d1e <Probe+0x4>
	}

	
	wm_stop();
	return 0;
} 
    1d26:	89 e1       	ldi	r24, 0x19	; 25
    1d28:	08 95       	ret

00001d2a <Update>:
// 3 LT<2:0> RT<4:0>
// 4 BDR BDD BLT B- BH B+ BRT 1
// 5 BZL BB BY BA BX BZR BDL BDU
//
				
	performupdate = 0;
    1d2a:	10 92 ca 01 	sts	0x01CA, r1
	while(!performupdate)  {} //wait for update. and then pass the 1ms communicatin. 
    1d2e:	80 91 ca 01 	lds	r24, 0x01CA
    1d32:	88 23       	and	r24, r24
    1d34:	e1 f3       	breq	.-8      	; 0x1d2e <Update+0x4>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1d36:	8f e9       	ldi	r24, 0x9F	; 159
    1d38:	9f e0       	ldi	r25, 0x0F	; 15
    1d3a:	01 97       	sbiw	r24, 0x01	; 1
    1d3c:	f1 f7       	brne	.-4      	; 0x1d3a <Update+0x10>
    1d3e:	00 c0       	rjmp	.+0      	; 0x1d40 <Update+0x16>
    1d40:	00 00       	nop
	_delay_ms(1);

	memset(wii_buffer,0,PACKED_CLASSIC_DATA_SIZE);
    1d42:	85 e1       	ldi	r24, 0x15	; 21
    1d44:	eb ec       	ldi	r30, 0xCB	; 203
    1d46:	f1 e0       	ldi	r31, 0x01	; 1
    1d48:	df 01       	movw	r26, r30
    1d4a:	1d 92       	st	X+, r1
    1d4c:	8a 95       	dec	r24
    1d4e:	e9 f7       	brne	.-6      	; 0x1d4a <Update+0x20>
	

	//bit if drift with psx, and nes mini nor snees mini use analogs
	wii_buffer[0] = wii_buffer[1] = wii_buffer[2]=wii_buffer[3] =128;
    1d50:	80 e8       	ldi	r24, 0x80	; 128
    1d52:	80 93 ce 01 	sts	0x01CE, r24
    1d56:	80 93 cd 01 	sts	0x01CD, r24
    1d5a:	80 93 cc 01 	sts	0x01CC, r24
    1d5e:	80 93 cb 01 	sts	0x01CB, r24
	//not sure if analog data is use (arkanoid?) maybe test this and if not just use 0 / 0xff 
	if ( reportBuffer[X_MAIN_STICK] 	 < 110 || reportBuffer[X_MAIN_STICK] 	  > 145 ) wii_buffer[0]=reportBuffer[X_MAIN_STICK] ;
    1d62:	80 91 6b 03 	lds	r24, 0x036B
    1d66:	92 e9       	ldi	r25, 0x92	; 146
    1d68:	98 0f       	add	r25, r24
    1d6a:	94 32       	cpi	r25, 0x24	; 36
    1d6c:	10 f0       	brcs	.+4      	; 0x1d72 <Update+0x48>
    1d6e:	80 93 cb 01 	sts	0x01CB, r24
	if ( reportBuffer[X_SECONDARY_STICK] < 110 || reportBuffer[X_SECONDARY_STICK] > 145 ) wii_buffer[1]=reportBuffer[X_SECONDARY_STICK] ;
    1d72:	80 91 6d 03 	lds	r24, 0x036D
    1d76:	92 e9       	ldi	r25, 0x92	; 146
    1d78:	98 0f       	add	r25, r24
    1d7a:	94 32       	cpi	r25, 0x24	; 36
    1d7c:	10 f0       	brcs	.+4      	; 0x1d82 <Update+0x58>
    1d7e:	80 93 cc 01 	sts	0x01CC, r24
	if ( reportBuffer[Y_MAIN_STICK] 	 < 110 || reportBuffer[Y_MAIN_STICK] 	  > 145 ) wii_buffer[2]=reportBuffer[Y_MAIN_STICK] ^ 0xff;
    1d82:	80 91 6c 03 	lds	r24, 0x036C
    1d86:	92 e9       	ldi	r25, 0x92	; 146
    1d88:	98 0f       	add	r25, r24
    1d8a:	94 32       	cpi	r25, 0x24	; 36
    1d8c:	18 f0       	brcs	.+6      	; 0x1d94 <Update+0x6a>
    1d8e:	80 95       	com	r24
    1d90:	80 93 cd 01 	sts	0x01CD, r24
	if ( reportBuffer[Y_SECONDARY_STICK] < 110 || reportBuffer[Y_SECONDARY_STICK] > 145 ) wii_buffer[3]=reportBuffer[Y_SECONDARY_STICK] ^ 0xff;
    1d94:	80 91 6e 03 	lds	r24, 0x036E
    1d98:	92 e9       	ldi	r25, 0x92	; 146
    1d9a:	98 0f       	add	r25, r24
    1d9c:	94 32       	cpi	r25, 0x24	; 36
    1d9e:	18 f0       	brcs	.+6      	; 0x1da6 <Update+0x7c>
    1da0:	80 95       	com	r24
    1da2:	80 93 ce 01 	sts	0x01CE, r24
	
	wii_buffer[4] = 0x0c; //maybe an ID?
    1da6:	8c e0       	ldi	r24, 0x0C	; 12
    1da8:	80 93 cf 01 	sts	0x01CF, r24
	wii_buffer[5] = 0x08;
    1dac:	88 e0       	ldi	r24, 0x08	; 8
    1dae:	80 93 d0 01 	sts	0x01D0, r24
	//seconday x,y, no action
	//l/r/zl/zr - no action
	
	//  4    | BDR   |  BDD  |  BLT  |  B- | BH | B+  | BRT | 1   |
	//  5    | BZL   |   BB  |  BY   | BA  | BX | BZR | BDL | BDU |
	wii_buffer[6] = 0xff; //normaly high
    1db2:	8f ef       	ldi	r24, 0xFF	; 255
    1db4:	80 93 d1 01 	sts	0x01D1, r24
	wii_buffer[7] = 0xff; //normaly high
    1db8:	80 93 d2 01 	sts	0x01D2, r24
	if (reportBuffer[BUTTON_ROW_1] & 0x80) wii_buffer[6] &= ~0x02; //right trigger
    1dbc:	80 91 68 03 	lds	r24, 0x0368
    1dc0:	87 ff       	sbrs	r24, 7
    1dc2:	03 c0       	rjmp	.+6      	; 0x1dca <Update+0xa0>
    1dc4:	9d ef       	ldi	r25, 0xFD	; 253
    1dc6:	90 93 d1 01 	sts	0x01D1, r25
	if (reportBuffer[BUTTON_ROW_1] & 0x20) wii_buffer[6] &= ~0x04; //start ( + )
    1dca:	85 ff       	sbrs	r24, 5
    1dcc:	05 c0       	rjmp	.+10     	; 0x1dd8 <Update+0xae>
    1dce:	90 91 d1 01 	lds	r25, 0x01D1
    1dd2:	9b 7f       	andi	r25, 0xFB	; 251
    1dd4:	90 93 d1 01 	sts	0x01D1, r25
	if (reportBuffer[BUTTON_ROW_3] & 0x04) wii_buffer[6] &= ~0x08; //home
    1dd8:	90 91 7b 03 	lds	r25, 0x037B
    1ddc:	92 ff       	sbrs	r25, 2
    1dde:	05 c0       	rjmp	.+10     	; 0x1dea <Update+0xc0>
    1de0:	90 91 d1 01 	lds	r25, 0x01D1
    1de4:	97 7f       	andi	r25, 0xF7	; 247
    1de6:	90 93 d1 01 	sts	0x01D1, r25
	if (reportBuffer[BUTTON_ROW_1] & 0x10) wii_buffer[6] &= ~0x10; //select (-)
    1dea:	84 ff       	sbrs	r24, 4
    1dec:	05 c0       	rjmp	.+10     	; 0x1df8 <Update+0xce>
    1dee:	90 91 d1 01 	lds	r25, 0x01D1
    1df2:	9f 7e       	andi	r25, 0xEF	; 239
    1df4:	90 93 d1 01 	sts	0x01D1, r25
	if (reportBuffer[BUTTON_ROW_1] & 0x40) wii_buffer[6] &= ~0x20; //left trigger
    1df8:	86 ff       	sbrs	r24, 6
    1dfa:	05 c0       	rjmp	.+10     	; 0x1e06 <Update+0xdc>
    1dfc:	90 91 d1 01 	lds	r25, 0x01D1
    1e00:	9f 7d       	andi	r25, 0xDF	; 223
    1e02:	90 93 d1 01 	sts	0x01D1, r25
	if (reportBuffer[HAT] == DPAD_DOWN)    wii_buffer[6] &= ~0x40; //down
    1e06:	90 91 6a 03 	lds	r25, 0x036A
    1e0a:	94 30       	cpi	r25, 0x04	; 4
    1e0c:	21 f4       	brne	.+8      	; 0x1e16 <Update+0xec>
    1e0e:	90 91 d1 01 	lds	r25, 0x01D1
    1e12:	9f 7b       	andi	r25, 0xBF	; 191
    1e14:	05 c0       	rjmp	.+10     	; 0x1e20 <Update+0xf6>
	if (reportBuffer[HAT] == DPAD_RIGHT)   wii_buffer[6] &= ~0x80; //right
    1e16:	92 30       	cpi	r25, 0x02	; 2
    1e18:	31 f4       	brne	.+12     	; 0x1e26 <Update+0xfc>
    1e1a:	90 91 d1 01 	lds	r25, 0x01D1
    1e1e:	9f 77       	andi	r25, 0x7F	; 127
    1e20:	90 93 d1 01 	sts	0x01D1, r25
    1e24:	09 c0       	rjmp	.+18     	; 0x1e38 <Update+0x10e>
 
	if (reportBuffer[HAT] == DPAD_UP)      wii_buffer[7] &= ~0x01; //up
    1e26:	91 11       	cpse	r25, r1
    1e28:	02 c0       	rjmp	.+4      	; 0x1e2e <Update+0x104>
    1e2a:	9e ef       	ldi	r25, 0xFE	; 254
    1e2c:	03 c0       	rjmp	.+6      	; 0x1e34 <Update+0x10a>
	if (reportBuffer[HAT] == DPAD_LEFT)    wii_buffer[7] &= ~0x02; //down
    1e2e:	96 30       	cpi	r25, 0x06	; 6
    1e30:	19 f4       	brne	.+6      	; 0x1e38 <Update+0x10e>
    1e32:	9d ef       	ldi	r25, 0xFD	; 253
    1e34:	90 93 d2 01 	sts	0x01D2, r25
	if (reportBuffer[BUTTON_ROW_2] & 0x02) wii_buffer[7] &= ~0x04; //zr 
    1e38:	20 91 69 03 	lds	r18, 0x0369
    1e3c:	21 ff       	sbrs	r18, 1
    1e3e:	05 c0       	rjmp	.+10     	; 0x1e4a <Update+0x120>
    1e40:	90 91 d2 01 	lds	r25, 0x01D2
    1e44:	9b 7f       	andi	r25, 0xFB	; 251
    1e46:	90 93 d2 01 	sts	0x01D2, r25
	if (reportBuffer[BUTTON_ROW_2] & 0x01) wii_buffer[7] &= ~0x80; //zr 
    1e4a:	20 ff       	sbrs	r18, 0
    1e4c:	05 c0       	rjmp	.+10     	; 0x1e58 <Update+0x12e>
    1e4e:	90 91 d2 01 	lds	r25, 0x01D2
    1e52:	9f 77       	andi	r25, 0x7F	; 127
    1e54:	90 93 d2 01 	sts	0x01D2, r25
	if (reportBuffer[BUTTON_ROW_1] & 0x01) wii_buffer[7] &= ~0x40; //b
    1e58:	80 ff       	sbrs	r24, 0
    1e5a:	05 c0       	rjmp	.+10     	; 0x1e66 <Update+0x13c>
    1e5c:	90 91 d2 01 	lds	r25, 0x01D2
    1e60:	9f 7b       	andi	r25, 0xBF	; 191
    1e62:	90 93 d2 01 	sts	0x01D2, r25
	if (reportBuffer[BUTTON_ROW_1] & 0x02) wii_buffer[7] &= ~0x10; //a
    1e66:	81 ff       	sbrs	r24, 1
    1e68:	05 c0       	rjmp	.+10     	; 0x1e74 <Update+0x14a>
    1e6a:	90 91 d2 01 	lds	r25, 0x01D2
    1e6e:	9f 7e       	andi	r25, 0xEF	; 239
    1e70:	90 93 d2 01 	sts	0x01D2, r25
	if (reportBuffer[BUTTON_ROW_1] & 0x04) wii_buffer[7] &= ~0x20; //y
    1e74:	82 ff       	sbrs	r24, 2
    1e76:	05 c0       	rjmp	.+10     	; 0x1e82 <Update+0x158>
    1e78:	90 91 d2 01 	lds	r25, 0x01D2
    1e7c:	9f 7d       	andi	r25, 0xDF	; 223
    1e7e:	90 93 d2 01 	sts	0x01D2, r25
	if (reportBuffer[BUTTON_ROW_1] & 0x08) wii_buffer[7] &= ~0x08; //x
    1e82:	83 ff       	sbrs	r24, 3
    1e84:	05 c0       	rjmp	.+10     	; 0x1e90 <Update+0x166>
    1e86:	80 91 d2 01 	lds	r24, 0x01D2
    1e8a:	87 7f       	andi	r24, 0xF7	; 247
    1e8c:	80 93 d2 01 	sts	0x01D2, r24
	//nes mini goes to 21 all remaing 0's
		
	if (!  high_res_mode )
    1e90:	80 91 89 03 	lds	r24, 0x0389
    1e94:	81 11       	cpse	r24, r1
    1e96:	45 c0       	rjmp	.+138    	; 0x1f22 <Update+0x1f8>
	{
		wii_buffer[0] =  ( ( (wii_buffer[0] >> 2) ) )	 			          | ( ( (wii_buffer[1]			    >> 3) & 0x18 ) << 3) ;
    1e98:	80 91 cc 01 	lds	r24, 0x01CC
    1e9c:	86 95       	lsr	r24
    1e9e:	86 95       	lsr	r24
    1ea0:	86 95       	lsr	r24
    1ea2:	28 2f       	mov	r18, r24
    1ea4:	28 71       	andi	r18, 0x18	; 24
    1ea6:	b8 e0       	ldi	r27, 0x08	; 8
    1ea8:	2b 9f       	mul	r18, r27
    1eaa:	90 01       	movw	r18, r0
    1eac:	11 24       	eor	r1, r1
    1eae:	90 91 cb 01 	lds	r25, 0x01CB
    1eb2:	96 95       	lsr	r25
    1eb4:	96 95       	lsr	r25
    1eb6:	92 2b       	or	r25, r18
    1eb8:	90 93 cb 01 	sts	0x01CB, r25
		wii_buffer[1] =  ( ( (wii_buffer[2] >> 2) ) )	 			          | ( ( (wii_buffer[1]			    >> 3) & 0x06 ) << 5) ;
    1ebc:	86 70       	andi	r24, 0x06	; 6
    1ebe:	20 e2       	ldi	r18, 0x20	; 32
    1ec0:	82 9f       	mul	r24, r18
    1ec2:	c0 01       	movw	r24, r0
    1ec4:	11 24       	eor	r1, r1
    1ec6:	90 91 cd 01 	lds	r25, 0x01CD
    1eca:	96 95       	lsr	r25
    1ecc:	96 95       	lsr	r25
    1ece:	98 2b       	or	r25, r24
    1ed0:	90 93 cc 01 	sts	0x01CC, r25
		wii_buffer[2] =  ( ( (wii_buffer[1] >> 3)  & 0x01 )	>> 7    )         | ( ( (pressureData[l2__pressure] >> 3) & 0x18 ) << 2) | ( wii_buffer[3] >> 3);
    1ed4:	80 91 3f 03 	lds	r24, 0x033F
    1ed8:	86 95       	lsr	r24
    1eda:	86 95       	lsr	r24
    1edc:	86 95       	lsr	r24
    1ede:	28 2f       	mov	r18, r24
    1ee0:	28 71       	andi	r18, 0x18	; 24
    1ee2:	94 e0       	ldi	r25, 0x04	; 4
    1ee4:	29 9f       	mul	r18, r25
    1ee6:	90 01       	movw	r18, r0
    1ee8:	11 24       	eor	r1, r1
    1eea:	90 91 ce 01 	lds	r25, 0x01CE
    1eee:	96 95       	lsr	r25
    1ef0:	96 95       	lsr	r25
    1ef2:	96 95       	lsr	r25
    1ef4:	92 2b       	or	r25, r18
    1ef6:	90 93 cd 01 	sts	0x01CD, r25
		wii_buffer[3] =  ( ( (pressureData[l2__pressure] >> 3) & 0x07 ) << 5 )| ( ( (pressureData[r2__pressure] >> 3) ) );
    1efa:	a0 e2       	ldi	r26, 0x20	; 32
    1efc:	8a 9f       	mul	r24, r26
    1efe:	c0 01       	movw	r24, r0
    1f00:	11 24       	eor	r1, r1
    1f02:	90 91 40 03 	lds	r25, 0x0340
    1f06:	96 95       	lsr	r25
    1f08:	96 95       	lsr	r25
    1f0a:	96 95       	lsr	r25
    1f0c:	98 2b       	or	r25, r24
    1f0e:	90 93 ce 01 	sts	0x01CE, r25
		wii_buffer[4] = wii_buffer[6];
    1f12:	80 91 d1 01 	lds	r24, 0x01D1
    1f16:	80 93 cf 01 	sts	0x01CF, r24
		wii_buffer[5] = wii_buffer[7]; 	 
    1f1a:	80 91 d2 01 	lds	r24, 0x01D2
    1f1e:	80 93 d0 01 	sts	0x01D0, r24
	}  
	
	wm_newaction(wii_buffer, PACKED_CLASSIC_DATA_SIZE);
    1f22:	65 e1       	ldi	r22, 0x15	; 21
    1f24:	8b ec       	ldi	r24, 0xCB	; 203
    1f26:	91 e0       	ldi	r25, 0x01	; 1
    1f28:	14 c3       	rjmp	.+1576   	; 0x2552 <wm_newaction>

00001f2a <Init>:
    1f2a:	0f 93       	push	r16
{
	performupdate = 1;
}

void Init(void)
{
    1f2c:	1f 93       	push	r17

	PORTD |= 3; //no point - The regular IO pin driver for the port is actually completely disconnected when the TWI is enabled.
    1f2e:	8b b1       	in	r24, 0x0b	; 11
    1f30:	83 60       	ori	r24, 0x03	; 3
    1f32:	8b b9       	out	0x0b, r24	; 11
    DDRD &= ~3;  //but its good practice to config as inputs. 
    1f34:	8a b1       	in	r24, 0x0a	; 10
    1f36:	8c 7f       	andi	r24, 0xFC	; 252
    1f38:	8a b9       	out	0x0a, r24	; 10

	memset(wii_buffer,0,PACKED_CLASSIC_DATA_SIZE);
    1f3a:	85 e1       	ldi	r24, 0x15	; 21
    1f3c:	eb ec       	ldi	r30, 0xCB	; 203
    1f3e:	f1 e0       	ldi	r31, 0x01	; 1
    1f40:	df 01       	movw	r26, r30
    1f42:	1d 92       	st	X+, r1
    1f44:	8a 95       	dec	r24
    1f46:	e9 f7       	brne	.-6      	; 0x1f42 <Init+0x18>
	wm_init(classic_id, wii_buffer, PACKED_CLASSIC_DATA_SIZE, cal_data, pollfunc); //pollfunc is an event function. It will set performupdate
    1f48:	03 e8       	ldi	r16, 0x83	; 131
    1f4a:	1e e0       	ldi	r17, 0x0E	; 14
    1f4c:	24 e1       	ldi	r18, 0x14	; 20
    1f4e:	31 e0       	ldi	r19, 0x01	; 1
    1f50:	45 e1       	ldi	r20, 0x15	; 21
    1f52:	bf 01       	movw	r22, r30
    1f54:	84 e3       	ldi	r24, 0x34	; 52
    1f56:	91 e0       	ldi	r25, 0x01	; 1
    1f58:	03 d3       	rcall	.+1542   	; 0x2560 <wm_init>
    1f5a:	1f 91       	pop	r17
	wm_start();
}
    1f5c:	0f 91       	pop	r16
    1f5e:	60 c3       	rjmp	.+1728   	; 0x2620 <wm_start>

00001f60 <wiiGetConsole>:
	PORTD |= 3; //no point - The regular IO pin driver for the port is actually completely disconnected when the TWI is enabled.
    DDRD &= ~3;  //but its good practice to config as inputs. 

	memset(wii_buffer,0,PACKED_CLASSIC_DATA_SIZE);
	wm_init(classic_id, wii_buffer, PACKED_CLASSIC_DATA_SIZE, cal_data, pollfunc); //pollfunc is an event function. It will set performupdate
	wm_start();
    1f60:	8a e0       	ldi	r24, 0x0A	; 10
    1f62:	91 e0       	ldi	r25, 0x01	; 1
};

ConsoleFound *wiiGetConsole(void)
{
	return &Wii_Console;
}
    1f64:	08 95       	ret

00001f66 <wm_gentabs>:
	// bit shift with roll-over
	return (a >> b) | ((a << (8 - b)) & 0xFF);
}

void wm_gentabs()
{
    1f66:	2f 92       	push	r2
    1f68:	3f 92       	push	r3
    1f6a:	4f 92       	push	r4
    1f6c:	5f 92       	push	r5
    1f6e:	6f 92       	push	r6
    1f70:	7f 92       	push	r7
    1f72:	8f 92       	push	r8
    1f74:	9f 92       	push	r9
    1f76:	af 92       	push	r10
    1f78:	bf 92       	push	r11
    1f7a:	cf 92       	push	r12
    1f7c:	df 92       	push	r13
    1f7e:	ef 92       	push	r14
    1f80:	ff 92       	push	r15
    1f82:	0f 93       	push	r16
    1f84:	1f 93       	push	r17
    1f86:	cf 93       	push	r28
    1f88:	df 93       	push	r29
    1f8a:	cd b7       	in	r28, 0x3d	; 61
    1f8c:	de b7       	in	r29, 0x3e	; 62
    1f8e:	e2 97       	sbiw	r28, 0x32	; 50
    1f90:	0f b6       	in	r0, 0x3f	; 63
    1f92:	f8 94       	cli
    1f94:	de bf       	out	0x3e, r29	; 62
    1f96:	0f be       	out	0x3f, r0	; 63
    1f98:	cd bf       	out	0x3d, r28	; 61
		// generate test key
		unsigned char ans[6];
		unsigned char tkey[6];
		unsigned char t0[10];
		
		for(i = 0; i < 6; i++)
    1f9a:	1d a6       	std	Y+45, r1	; 0x2d
    1f9c:	1c a6       	std	Y+44, r1	; 0x2c
    1f9e:	a1 2c       	mov	r10, r1
    1fa0:	b1 2c       	mov	r11, r1


unsigned char wm_ror8(unsigned char a, unsigned char b)
{
	// bit shift with roll-over
	return (a >> b) | ((a << (8 - b)) & 0xFF);
    1fa2:	78 e0       	ldi	r23, 0x08	; 8
    1fa4:	e7 2e       	mov	r14, r23
    1fa6:	f1 2c       	mov	r15, r1
    1fa8:	de 01       	movw	r26, r28
    1faa:	51 96       	adiw	r26, 0x11	; 17
}

void wm_gentabs()
{
    1fac:	80 e0       	ldi	r24, 0x00	; 0
    1fae:	90 e0       	ldi	r25, 0x00	; 0
    1fb0:	2c a5       	ldd	r18, Y+44	; 0x2c
    1fb2:	3d a5       	ldd	r19, Y+45	; 0x2d
    1fb4:	24 53       	subi	r18, 0x34	; 52
    1fb6:	35 4f       	sbci	r19, 0xF5	; 245
    1fb8:	f9 01       	movw	r30, r18
    1fba:	e8 0f       	add	r30, r24
    1fbc:	f9 1f       	adc	r31, r25
		unsigned char tkey[6];
		unsigned char t0[10];
		
		for(i = 0; i < 6; i++)
		{
			ans[i] = pgm_read_byte(&(ans_tbl[idx][i]));
    1fbe:	e4 91       	lpm	r30, Z
    1fc0:	ed 93       	st	X+, r30
    1fc2:	01 96       	adiw	r24, 0x01	; 1
		// generate test key
		unsigned char ans[6];
		unsigned char tkey[6];
		unsigned char t0[10];
		
		for(i = 0; i < 6; i++)
    1fc4:	86 30       	cpi	r24, 0x06	; 6
    1fc6:	91 05       	cpc	r25, r1
    1fc8:	b9 f7       	brne	.-18     	; 0x1fb8 <wm_gentabs+0x52>
    1fca:	de 01       	movw	r26, r28
    1fcc:	11 96       	adiw	r26, 0x01	; 1
    1fce:	80 e0       	ldi	r24, 0x00	; 0
    1fd0:	90 e0       	ldi	r25, 0x00	; 0
		{
			ans[i] = pgm_read_byte(&(ans_tbl[idx][i]));
		}	
		for(i = 0; i < 10; i++)
		{
			t0[i] = pgm_read_byte(&(sboxes[0][wm_rand[i]]));
    1fd2:	fc 01       	movw	r30, r24
    1fd4:	ed 5f       	subi	r30, 0xFD	; 253
    1fd6:	fc 4f       	sbci	r31, 0xFC	; 252
    1fd8:	e0 81       	ld	r30, Z
    1fda:	f0 e0       	ldi	r31, 0x00	; 0
    1fdc:	e4 53       	subi	r30, 0x34	; 52
    1fde:	ff 4f       	sbci	r31, 0xFF	; 255
    1fe0:	e4 91       	lpm	r30, Z
    1fe2:	ed 93       	st	X+, r30
    1fe4:	01 96       	adiw	r24, 0x01	; 1
		
		for(i = 0; i < 6; i++)
		{
			ans[i] = pgm_read_byte(&(ans_tbl[idx][i]));
		}	
		for(i = 0; i < 10; i++)
    1fe6:	8a 30       	cpi	r24, 0x0A	; 10
    1fe8:	91 05       	cpc	r25, r1
    1fea:	99 f7       	brne	.-26     	; 0x1fd2 <wm_gentabs+0x6c>
		{
			t0[i] = pgm_read_byte(&(sboxes[0][wm_rand[i]]));
		}
	
		tkey[0] = ((wm_ror8((ans[0] ^ t0[5]), (t0[2] % 8)) - t0[9]) ^ t0[4]);
    1fec:	ab 81       	ldd	r26, Y+3	; 0x03
    1fee:	7e 81       	ldd	r23, Y+6	; 0x06
    1ff0:	89 89       	ldd	r24, Y+17	; 0x11
    1ff2:	87 27       	eor	r24, r23


unsigned char wm_ror8(unsigned char a, unsigned char b)
{
	// bit shift with roll-over
	return (a >> b) | ((a << (8 - b)) & 0xFF);
    1ff4:	90 e0       	ldi	r25, 0x00	; 0
		for(i = 0; i < 10; i++)
		{
			t0[i] = pgm_read_byte(&(sboxes[0][wm_rand[i]]));
		}
	
		tkey[0] = ((wm_ror8((ans[0] ^ t0[5]), (t0[2] % 8)) - t0[9]) ^ t0[4]);
    1ff6:	4a 2f       	mov	r20, r26
    1ff8:	47 70       	andi	r20, 0x07	; 7
    1ffa:	2a 85       	ldd	r18, Y+10	; 0x0a
    1ffc:	28 ab       	std	Y+48, r18	; 0x30
    1ffe:	fd 81       	ldd	r31, Y+5	; 0x05


unsigned char wm_ror8(unsigned char a, unsigned char b)
{
	// bit shift with roll-over
	return (a >> b) | ((a << (8 - b)) & 0xFF);
    2000:	97 01       	movw	r18, r14
    2002:	24 1b       	sub	r18, r20
    2004:	31 09       	sbc	r19, r1
    2006:	3a ab       	std	Y+50, r19	; 0x32
    2008:	29 ab       	std	Y+49, r18	; 0x31
    200a:	9c 01       	movw	r18, r24
    200c:	09 a8       	ldd	r0, Y+49	; 0x31
    200e:	02 c0       	rjmp	.+4      	; 0x2014 <wm_gentabs+0xae>
    2010:	22 0f       	add	r18, r18
    2012:	33 1f       	adc	r19, r19
    2014:	0a 94       	dec	r0
    2016:	e2 f7       	brpl	.-8      	; 0x2010 <wm_gentabs+0xaa>
    2018:	02 c0       	rjmp	.+4      	; 0x201e <wm_gentabs+0xb8>
    201a:	95 95       	asr	r25
    201c:	87 95       	ror	r24
    201e:	4a 95       	dec	r20
    2020:	e2 f7       	brpl	.-8      	; 0x201a <wm_gentabs+0xb4>
    2022:	82 2b       	or	r24, r18
		for(i = 0; i < 10; i++)
		{
			t0[i] = pgm_read_byte(&(sboxes[0][wm_rand[i]]));
		}
	
		tkey[0] = ((wm_ror8((ans[0] ^ t0[5]), (t0[2] % 8)) - t0[9]) ^ t0[4]);
    2024:	38 a9       	ldd	r19, Y+48	; 0x30
    2026:	83 1b       	sub	r24, r19
    2028:	8f 27       	eor	r24, r31
    202a:	8b 87       	std	Y+11, r24	; 0x0b
		tkey[1] = ((wm_ror8((ans[1] ^ t0[1]), (t0[0] % 8)) - t0[5]) ^ t0[7]);
    202c:	b9 81       	ldd	r27, Y+1	; 0x01
    202e:	4a 81       	ldd	r20, Y+2	; 0x02
    2030:	4e a7       	std	Y+46, r20	; 0x2e
    2032:	8a 89       	ldd	r24, Y+18	; 0x12
    2034:	84 27       	eor	r24, r20


unsigned char wm_ror8(unsigned char a, unsigned char b)
{
	// bit shift with roll-over
	return (a >> b) | ((a << (8 - b)) & 0xFF);
    2036:	90 e0       	ldi	r25, 0x00	; 0
		{
			t0[i] = pgm_read_byte(&(sboxes[0][wm_rand[i]]));
		}
	
		tkey[0] = ((wm_ror8((ans[0] ^ t0[5]), (t0[2] % 8)) - t0[9]) ^ t0[4]);
		tkey[1] = ((wm_ror8((ans[1] ^ t0[1]), (t0[0] % 8)) - t0[5]) ^ t0[7]);
    2038:	4b 2f       	mov	r20, r27
    203a:	47 70       	andi	r20, 0x07	; 7
    203c:	e8 85       	ldd	r30, Y+8	; 0x08


unsigned char wm_ror8(unsigned char a, unsigned char b)
{
	// bit shift with roll-over
	return (a >> b) | ((a << (8 - b)) & 0xFF);
    203e:	97 01       	movw	r18, r14
    2040:	24 1b       	sub	r18, r20
    2042:	31 09       	sbc	r19, r1
    2044:	3a ab       	std	Y+50, r19	; 0x32
    2046:	29 ab       	std	Y+49, r18	; 0x31
    2048:	9c 01       	movw	r18, r24
    204a:	09 a8       	ldd	r0, Y+49	; 0x31
    204c:	02 c0       	rjmp	.+4      	; 0x2052 <wm_gentabs+0xec>
    204e:	22 0f       	add	r18, r18
    2050:	33 1f       	adc	r19, r19
    2052:	0a 94       	dec	r0
    2054:	e2 f7       	brpl	.-8      	; 0x204e <wm_gentabs+0xe8>
    2056:	02 c0       	rjmp	.+4      	; 0x205c <wm_gentabs+0xf6>
    2058:	95 95       	asr	r25
    205a:	87 95       	ror	r24
    205c:	4a 95       	dec	r20
    205e:	e2 f7       	brpl	.-8      	; 0x2058 <wm_gentabs+0xf2>
    2060:	82 2b       	or	r24, r18
		{
			t0[i] = pgm_read_byte(&(sboxes[0][wm_rand[i]]));
		}
	
		tkey[0] = ((wm_ror8((ans[0] ^ t0[5]), (t0[2] % 8)) - t0[9]) ^ t0[4]);
		tkey[1] = ((wm_ror8((ans[1] ^ t0[1]), (t0[0] % 8)) - t0[5]) ^ t0[7]);
    2062:	87 1b       	sub	r24, r23
    2064:	8e 27       	eor	r24, r30
    2066:	8c 87       	std	Y+12, r24	; 0x0c
		tkey[2] = ((wm_ror8((ans[2] ^ t0[6]), (t0[8] % 8)) - t0[2]) ^ t0[0]);
    2068:	3f 81       	ldd	r19, Y+7	; 0x07
    206a:	3f a7       	std	Y+47, r19	; 0x2f
    206c:	2b 89       	ldd	r18, Y+19	; 0x13
    206e:	23 27       	eor	r18, r19


unsigned char wm_ror8(unsigned char a, unsigned char b)
{
	// bit shift with roll-over
	return (a >> b) | ((a << (8 - b)) & 0xFF);
    2070:	30 e0       	ldi	r19, 0x00	; 0
			t0[i] = pgm_read_byte(&(sboxes[0][wm_rand[i]]));
		}
	
		tkey[0] = ((wm_ror8((ans[0] ^ t0[5]), (t0[2] % 8)) - t0[9]) ^ t0[4]);
		tkey[1] = ((wm_ror8((ans[1] ^ t0[1]), (t0[0] % 8)) - t0[5]) ^ t0[7]);
		tkey[2] = ((wm_ror8((ans[2] ^ t0[6]), (t0[8] % 8)) - t0[2]) ^ t0[0]);
    2072:	69 85       	ldd	r22, Y+9	; 0x09
    2074:	67 70       	andi	r22, 0x07	; 7


unsigned char wm_ror8(unsigned char a, unsigned char b)
{
	// bit shift with roll-over
	return (a >> b) | ((a << (8 - b)) & 0xFF);
    2076:	c7 01       	movw	r24, r14
    2078:	86 1b       	sub	r24, r22
    207a:	91 09       	sbc	r25, r1
    207c:	a9 01       	movw	r20, r18
    207e:	08 2e       	mov	r0, r24
    2080:	01 c0       	rjmp	.+2      	; 0x2084 <wm_gentabs+0x11e>
    2082:	44 0f       	add	r20, r20
    2084:	0a 94       	dec	r0
    2086:	ea f7       	brpl	.-6      	; 0x2082 <wm_gentabs+0x11c>
    2088:	06 2e       	mov	r0, r22
    208a:	02 c0       	rjmp	.+4      	; 0x2090 <wm_gentabs+0x12a>
    208c:	35 95       	asr	r19
    208e:	27 95       	ror	r18
    2090:	0a 94       	dec	r0
    2092:	e2 f7       	brpl	.-8      	; 0x208c <wm_gentabs+0x126>
    2094:	24 2b       	or	r18, r20
			t0[i] = pgm_read_byte(&(sboxes[0][wm_rand[i]]));
		}
	
		tkey[0] = ((wm_ror8((ans[0] ^ t0[5]), (t0[2] % 8)) - t0[9]) ^ t0[4]);
		tkey[1] = ((wm_ror8((ans[1] ^ t0[1]), (t0[0] % 8)) - t0[5]) ^ t0[7]);
		tkey[2] = ((wm_ror8((ans[2] ^ t0[6]), (t0[8] % 8)) - t0[2]) ^ t0[0]);
    2096:	2a 1b       	sub	r18, r26
    2098:	2b 27       	eor	r18, r27
    209a:	2d 87       	std	Y+13, r18	; 0x0d
		tkey[3] = ((wm_ror8((ans[3] ^ t0[4]), (t0[7] % 8)) - t0[3]) ^ t0[2]);
    209c:	2c 89       	ldd	r18, Y+20	; 0x14
    209e:	2f 27       	eor	r18, r31


unsigned char wm_ror8(unsigned char a, unsigned char b)
{
	// bit shift with roll-over
	return (a >> b) | ((a << (8 - b)) & 0xFF);
    20a0:	30 e0       	ldi	r19, 0x00	; 0
		}
	
		tkey[0] = ((wm_ror8((ans[0] ^ t0[5]), (t0[2] % 8)) - t0[9]) ^ t0[4]);
		tkey[1] = ((wm_ror8((ans[1] ^ t0[1]), (t0[0] % 8)) - t0[5]) ^ t0[7]);
		tkey[2] = ((wm_ror8((ans[2] ^ t0[6]), (t0[8] % 8)) - t0[2]) ^ t0[0]);
		tkey[3] = ((wm_ror8((ans[3] ^ t0[4]), (t0[7] % 8)) - t0[3]) ^ t0[2]);
    20a2:	4e 2f       	mov	r20, r30
    20a4:	47 70       	andi	r20, 0x07	; 7
    20a6:	4b a7       	std	Y+43, r20	; 0x2b
    20a8:	9c 81       	ldd	r25, Y+4	; 0x04


unsigned char wm_ror8(unsigned char a, unsigned char b)
{
	// bit shift with roll-over
	return (a >> b) | ((a << (8 - b)) & 0xFF);
    20aa:	a7 01       	movw	r20, r14
    20ac:	bb a5       	ldd	r27, Y+43	; 0x2b
    20ae:	4b 1b       	sub	r20, r27
    20b0:	51 09       	sbc	r21, r1
    20b2:	5a ab       	std	Y+50, r21	; 0x32
    20b4:	49 ab       	std	Y+49, r20	; 0x31
    20b6:	a9 01       	movw	r20, r18
    20b8:	09 a8       	ldd	r0, Y+49	; 0x31
    20ba:	02 c0       	rjmp	.+4      	; 0x20c0 <wm_gentabs+0x15a>
    20bc:	44 0f       	add	r20, r20
    20be:	55 1f       	adc	r21, r21
    20c0:	0a 94       	dec	r0
    20c2:	e2 f7       	brpl	.-8      	; 0x20bc <wm_gentabs+0x156>
    20c4:	02 c0       	rjmp	.+4      	; 0x20ca <wm_gentabs+0x164>
    20c6:	35 95       	asr	r19
    20c8:	27 95       	ror	r18
    20ca:	ba 95       	dec	r27
    20cc:	e2 f7       	brpl	.-8      	; 0x20c6 <wm_gentabs+0x160>
    20ce:	24 2b       	or	r18, r20
		}
	
		tkey[0] = ((wm_ror8((ans[0] ^ t0[5]), (t0[2] % 8)) - t0[9]) ^ t0[4]);
		tkey[1] = ((wm_ror8((ans[1] ^ t0[1]), (t0[0] % 8)) - t0[5]) ^ t0[7]);
		tkey[2] = ((wm_ror8((ans[2] ^ t0[6]), (t0[8] % 8)) - t0[2]) ^ t0[0]);
		tkey[3] = ((wm_ror8((ans[3] ^ t0[4]), (t0[7] % 8)) - t0[3]) ^ t0[2]);
    20d0:	29 1b       	sub	r18, r25
    20d2:	2a 27       	eor	r18, r26
    20d4:	2e 87       	std	Y+14, r18	; 0x0e
		tkey[4] = ((wm_ror8((ans[4] ^ t0[1]), (t0[6] % 8)) - t0[3]) ^ t0[4]);
    20d6:	2d 89       	ldd	r18, Y+21	; 0x15
    20d8:	5e a5       	ldd	r21, Y+46	; 0x2e
    20da:	25 27       	eor	r18, r21


unsigned char wm_ror8(unsigned char a, unsigned char b)
{
	// bit shift with roll-over
	return (a >> b) | ((a << (8 - b)) & 0xFF);
    20dc:	30 e0       	ldi	r19, 0x00	; 0
	
		tkey[0] = ((wm_ror8((ans[0] ^ t0[5]), (t0[2] % 8)) - t0[9]) ^ t0[4]);
		tkey[1] = ((wm_ror8((ans[1] ^ t0[1]), (t0[0] % 8)) - t0[5]) ^ t0[7]);
		tkey[2] = ((wm_ror8((ans[2] ^ t0[6]), (t0[8] % 8)) - t0[2]) ^ t0[0]);
		tkey[3] = ((wm_ror8((ans[3] ^ t0[4]), (t0[7] % 8)) - t0[3]) ^ t0[2]);
		tkey[4] = ((wm_ror8((ans[4] ^ t0[1]), (t0[6] % 8)) - t0[3]) ^ t0[4]);
    20de:	af a5       	ldd	r26, Y+47	; 0x2f
    20e0:	a7 70       	andi	r26, 0x07	; 7


unsigned char wm_ror8(unsigned char a, unsigned char b)
{
	// bit shift with roll-over
	return (a >> b) | ((a << (8 - b)) & 0xFF);
    20e2:	a7 01       	movw	r20, r14
    20e4:	4a 1b       	sub	r20, r26
    20e6:	51 09       	sbc	r21, r1
    20e8:	5a ab       	std	Y+50, r21	; 0x32
    20ea:	49 ab       	std	Y+49, r20	; 0x31
    20ec:	a9 01       	movw	r20, r18
    20ee:	09 a8       	ldd	r0, Y+49	; 0x31
    20f0:	02 c0       	rjmp	.+4      	; 0x20f6 <wm_gentabs+0x190>
    20f2:	44 0f       	add	r20, r20
    20f4:	55 1f       	adc	r21, r21
    20f6:	0a 94       	dec	r0
    20f8:	e2 f7       	brpl	.-8      	; 0x20f2 <wm_gentabs+0x18c>
    20fa:	5a ab       	std	Y+50, r21	; 0x32
    20fc:	49 ab       	std	Y+49, r20	; 0x31
    20fe:	02 c0       	rjmp	.+4      	; 0x2104 <wm_gentabs+0x19e>
    2100:	35 95       	asr	r19
    2102:	27 95       	ror	r18
    2104:	aa 95       	dec	r26
    2106:	e2 f7       	brpl	.-8      	; 0x2100 <wm_gentabs+0x19a>
    2108:	24 2b       	or	r18, r20
	
		tkey[0] = ((wm_ror8((ans[0] ^ t0[5]), (t0[2] % 8)) - t0[9]) ^ t0[4]);
		tkey[1] = ((wm_ror8((ans[1] ^ t0[1]), (t0[0] % 8)) - t0[5]) ^ t0[7]);
		tkey[2] = ((wm_ror8((ans[2] ^ t0[6]), (t0[8] % 8)) - t0[2]) ^ t0[0]);
		tkey[3] = ((wm_ror8((ans[3] ^ t0[4]), (t0[7] % 8)) - t0[3]) ^ t0[2]);
		tkey[4] = ((wm_ror8((ans[4] ^ t0[1]), (t0[6] % 8)) - t0[3]) ^ t0[4]);
    210a:	29 1b       	sub	r18, r25
    210c:	2f 27       	eor	r18, r31
    210e:	2f 87       	std	Y+15, r18	; 0x0f
		tkey[5] = ((wm_ror8((ans[5] ^ t0[7]), (t0[8] % 8)) - t0[5]) ^ t0[9]);
    2110:	2e 89       	ldd	r18, Y+22	; 0x16
    2112:	2e 27       	eor	r18, r30


unsigned char wm_ror8(unsigned char a, unsigned char b)
{
	// bit shift with roll-over
	return (a >> b) | ((a << (8 - b)) & 0xFF);
    2114:	30 e0       	ldi	r19, 0x00	; 0
    2116:	f9 01       	movw	r30, r18
    2118:	02 c0       	rjmp	.+4      	; 0x211e <wm_gentabs+0x1b8>
    211a:	ee 0f       	add	r30, r30
    211c:	ff 1f       	adc	r31, r31
    211e:	8a 95       	dec	r24
    2120:	e2 f7       	brpl	.-8      	; 0x211a <wm_gentabs+0x1b4>
    2122:	cf 01       	movw	r24, r30
    2124:	02 c0       	rjmp	.+4      	; 0x212a <wm_gentabs+0x1c4>
    2126:	35 95       	asr	r19
    2128:	27 95       	ror	r18
    212a:	6a 95       	dec	r22
    212c:	e2 f7       	brpl	.-8      	; 0x2126 <wm_gentabs+0x1c0>
    212e:	82 2b       	or	r24, r18
		tkey[0] = ((wm_ror8((ans[0] ^ t0[5]), (t0[2] % 8)) - t0[9]) ^ t0[4]);
		tkey[1] = ((wm_ror8((ans[1] ^ t0[1]), (t0[0] % 8)) - t0[5]) ^ t0[7]);
		tkey[2] = ((wm_ror8((ans[2] ^ t0[6]), (t0[8] % 8)) - t0[2]) ^ t0[0]);
		tkey[3] = ((wm_ror8((ans[3] ^ t0[4]), (t0[7] % 8)) - t0[3]) ^ t0[2]);
		tkey[4] = ((wm_ror8((ans[4] ^ t0[1]), (t0[6] % 8)) - t0[3]) ^ t0[4]);
		tkey[5] = ((wm_ror8((ans[5] ^ t0[7]), (t0[8] % 8)) - t0[5]) ^ t0[9]);
    2130:	87 1b       	sub	r24, r23
    2132:	f8 a9       	ldd	r31, Y+48	; 0x30
    2134:	8f 27       	eor	r24, r31
    2136:	88 8b       	std	Y+16, r24	; 0x10

		// compare with actual key
		if(memcmp(tkey, (void*)wm_key, 6) == 0) break; // if match, then use this idx
    2138:	46 e0       	ldi	r20, 0x06	; 6
    213a:	50 e0       	ldi	r21, 0x00	; 0
    213c:	6d ef       	ldi	r22, 0xFD	; 253
    213e:	72 e0       	ldi	r23, 0x02	; 2
    2140:	ce 01       	movw	r24, r28
    2142:	0b 96       	adiw	r24, 0x0b	; 11
    2144:	0e 94 b0 2a 	call	0x5560	; 0x5560 <memcmp>
    2148:	95 01       	movw	r18, r10
    214a:	2f 5f       	subi	r18, 0xFF	; 255
    214c:	3f 4f       	sbci	r19, 0xFF	; 255
    214e:	89 2b       	or	r24, r25
    2150:	79 f0       	breq	.+30     	; 0x2170 <wm_gentabs+0x20a>
    2152:	59 01       	movw	r10, r18
    2154:	2c a5       	ldd	r18, Y+44	; 0x2c
    2156:	3d a5       	ldd	r19, Y+45	; 0x2d
    2158:	2a 5f       	subi	r18, 0xFA	; 250
    215a:	3f 4f       	sbci	r19, 0xFF	; 255
    215c:	3d a7       	std	Y+45, r19	; 0x2d
    215e:	2c a7       	std	Y+44, r18	; 0x2c
{
	unsigned char idx;
	unsigned char i;

	// check all idx
	for(idx = 0; idx < 7; idx++)
    2160:	37 e0       	ldi	r19, 0x07	; 7
    2162:	a3 16       	cp	r10, r19
    2164:	b1 04       	cpc	r11, r1
    2166:	09 f0       	breq	.+2      	; 0x216a <wm_gentabs+0x204>
    2168:	1f cf       	rjmp	.-450    	; 0x1fa8 <wm_gentabs+0x42>

		// compare with actual key
		if(memcmp(tkey, (void*)wm_key, 6) == 0) break; // if match, then use this idx
	}
	if (idx == 7) {
		g_enc_on = 0;
    216a:	10 92 0e 03 	sts	0x030E, r1
		return;
    216e:	80 c1       	rjmp	.+768    	; 0x2470 <wm_gentabs+0x50a>
	}

	// generate encryption from idx key and rand
	wm_ft[0] = pgm_read_byte(&(sboxes[idx + 1][wm_key[4]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[3]]));
    2170:	82 2f       	mov	r24, r18
    2172:	90 91 01 03 	lds	r25, 0x0301
    2176:	12 2f       	mov	r17, r18
    2178:	00 e0       	ldi	r16, 0x00	; 0
    217a:	09 0f       	add	r16, r25
    217c:	11 1d       	adc	r17, r1
    217e:	04 53       	subi	r16, 0x34	; 52
    2180:	1f 4f       	sbci	r17, 0xFF	; 255
    2182:	f8 01       	movw	r30, r16
    2184:	04 91       	lpm	r16, Z
    2186:	f2 e0       	ldi	r31, 0x02	; 2
    2188:	af 0e       	add	r10, r31
    218a:	b1 1c       	adc	r11, r1
    218c:	90 91 06 03 	lds	r25, 0x0306
    2190:	fa 2d       	mov	r31, r10
    2192:	ee 27       	eor	r30, r30
    2194:	e9 0f       	add	r30, r25
    2196:	f1 1d       	adc	r31, r1
    2198:	e4 53       	subi	r30, 0x34	; 52
    219a:	ff 4f       	sbci	r31, 0xFF	; 255
    219c:	e4 91       	lpm	r30, Z
    219e:	e0 27       	eor	r30, r16
    21a0:	e0 93 f5 02 	sts	0x02F5, r30
	wm_ft[1] = pgm_read_byte(&(sboxes[idx + 1][wm_key[2]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[5]]));
    21a4:	90 91 ff 02 	lds	r25, 0x02FF
    21a8:	78 2e       	mov	r7, r24
    21aa:	61 2c       	mov	r6, r1
    21ac:	69 0e       	add	r6, r25
    21ae:	71 1c       	adc	r7, r1
    21b0:	93 01       	movw	r18, r6
    21b2:	24 53       	subi	r18, 0x34	; 52
    21b4:	3f 4f       	sbci	r19, 0xFF	; 255
    21b6:	f9 01       	movw	r30, r18
    21b8:	64 90       	lpm	r6, Z
    21ba:	90 91 08 03 	lds	r25, 0x0308
    21be:	fa 2d       	mov	r31, r10
    21c0:	ee 27       	eor	r30, r30
    21c2:	e9 0f       	add	r30, r25
    21c4:	f1 1d       	adc	r31, r1
    21c6:	e4 53       	subi	r30, 0x34	; 52
    21c8:	ff 4f       	sbci	r31, 0xFF	; 255
    21ca:	e4 91       	lpm	r30, Z
    21cc:	e6 25       	eor	r30, r6
    21ce:	e0 93 f6 02 	sts	0x02F6, r30
	wm_ft[2] = pgm_read_byte(&(sboxes[idx + 1][wm_key[5]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[7]]));
    21d2:	90 91 02 03 	lds	r25, 0x0302
    21d6:	58 2e       	mov	r5, r24
    21d8:	41 2c       	mov	r4, r1
    21da:	49 0e       	add	r4, r25
    21dc:	51 1c       	adc	r5, r1
    21de:	92 01       	movw	r18, r4
    21e0:	24 53       	subi	r18, 0x34	; 52
    21e2:	3f 4f       	sbci	r19, 0xFF	; 255
    21e4:	f9 01       	movw	r30, r18
    21e6:	44 90       	lpm	r4, Z
    21e8:	90 91 0a 03 	lds	r25, 0x030A
    21ec:	fa 2d       	mov	r31, r10
    21ee:	ee 27       	eor	r30, r30
    21f0:	e9 0f       	add	r30, r25
    21f2:	f1 1d       	adc	r31, r1
    21f4:	e4 53       	subi	r30, 0x34	; 52
    21f6:	ff 4f       	sbci	r31, 0xFF	; 255
    21f8:	e4 91       	lpm	r30, Z
    21fa:	e4 25       	eor	r30, r4
    21fc:	e0 93 f7 02 	sts	0x02F7, r30
	wm_ft[3] = pgm_read_byte(&(sboxes[idx + 1][wm_key[0]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[2]]));
    2200:	90 91 fd 02 	lds	r25, 0x02FD
    2204:	d8 2e       	mov	r13, r24
    2206:	c1 2c       	mov	r12, r1
    2208:	c9 0e       	add	r12, r25
    220a:	d1 1c       	adc	r13, r1
    220c:	96 01       	movw	r18, r12
    220e:	24 53       	subi	r18, 0x34	; 52
    2210:	3f 4f       	sbci	r19, 0xFF	; 255
    2212:	f9 01       	movw	r30, r18
    2214:	94 91       	lpm	r25, Z
    2216:	20 91 05 03 	lds	r18, 0x0305
    221a:	fa 2d       	mov	r31, r10
    221c:	ee 27       	eor	r30, r30
    221e:	e2 0f       	add	r30, r18
    2220:	f1 1d       	adc	r31, r1
    2222:	e4 53       	subi	r30, 0x34	; 52
    2224:	ff 4f       	sbci	r31, 0xFF	; 255
    2226:	e4 91       	lpm	r30, Z
    2228:	e9 27       	eor	r30, r25
    222a:	e0 93 f8 02 	sts	0x02F8, r30
	wm_ft[4] = pgm_read_byte(&(sboxes[idx + 1][wm_key[1]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[4]]));
    222e:	90 91 fe 02 	lds	r25, 0x02FE
    2232:	98 2e       	mov	r9, r24
    2234:	81 2c       	mov	r8, r1
    2236:	89 0e       	add	r8, r25
    2238:	91 1c       	adc	r9, r1
    223a:	94 01       	movw	r18, r8
    223c:	24 53       	subi	r18, 0x34	; 52
    223e:	3f 4f       	sbci	r19, 0xFF	; 255
    2240:	f9 01       	movw	r30, r18
    2242:	94 91       	lpm	r25, Z
    2244:	20 91 07 03 	lds	r18, 0x0307
    2248:	fa 2d       	mov	r31, r10
    224a:	ee 27       	eor	r30, r30
    224c:	e2 0f       	add	r30, r18
    224e:	f1 1d       	adc	r31, r1
    2250:	e4 53       	subi	r30, 0x34	; 52
    2252:	ff 4f       	sbci	r31, 0xFF	; 255
    2254:	e4 91       	lpm	r30, Z
    2256:	e9 27       	eor	r30, r25
    2258:	e0 93 f9 02 	sts	0x02F9, r30
	wm_ft[5] = pgm_read_byte(&(sboxes[idx + 1][wm_key[3]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[9]]));
    225c:	90 91 00 03 	lds	r25, 0x0300
    2260:	88 8f       	std	Y+24, r24	; 0x18
    2262:	1f 8a       	std	Y+23, r1	; 0x17
    2264:	2f 89       	ldd	r18, Y+23	; 0x17
    2266:	38 8d       	ldd	r19, Y+24	; 0x18
    2268:	29 0f       	add	r18, r25
    226a:	31 1d       	adc	r19, r1
    226c:	24 53       	subi	r18, 0x34	; 52
    226e:	3f 4f       	sbci	r19, 0xFF	; 255
    2270:	f9 01       	movw	r30, r18
    2272:	94 91       	lpm	r25, Z
    2274:	20 91 0c 03 	lds	r18, 0x030C
    2278:	fa 2d       	mov	r31, r10
    227a:	ee 27       	eor	r30, r30
    227c:	e2 0f       	add	r30, r18
    227e:	f1 1d       	adc	r31, r1
    2280:	e4 53       	subi	r30, 0x34	; 52
    2282:	ff 4f       	sbci	r31, 0xFF	; 255
    2284:	e4 91       	lpm	r30, Z
    2286:	e9 27       	eor	r30, r25
    2288:	e0 93 fa 02 	sts	0x02FA, r30
	wm_ft[6] = pgm_read_byte(&(sboxes[idx + 1][wm_rand[0]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[6]]));
    228c:	90 91 03 03 	lds	r25, 0x0303
    2290:	8a 8f       	std	Y+26, r24	; 0x1a
    2292:	19 8e       	std	Y+25, r1	; 0x19
    2294:	29 8d       	ldd	r18, Y+25	; 0x19
    2296:	3a 8d       	ldd	r19, Y+26	; 0x1a
    2298:	29 0f       	add	r18, r25
    229a:	31 1d       	adc	r19, r1
    229c:	24 53       	subi	r18, 0x34	; 52
    229e:	3f 4f       	sbci	r19, 0xFF	; 255
    22a0:	f9 01       	movw	r30, r18
    22a2:	94 91       	lpm	r25, Z
    22a4:	20 91 09 03 	lds	r18, 0x0309
    22a8:	fa 2d       	mov	r31, r10
    22aa:	ee 27       	eor	r30, r30
    22ac:	e2 0f       	add	r30, r18
    22ae:	f1 1d       	adc	r31, r1
    22b0:	e4 53       	subi	r30, 0x34	; 52
    22b2:	ff 4f       	sbci	r31, 0xFF	; 255
    22b4:	e4 91       	lpm	r30, Z
    22b6:	e9 27       	eor	r30, r25
    22b8:	e0 93 fb 02 	sts	0x02FB, r30
	wm_ft[7] = pgm_read_byte(&(sboxes[idx + 1][wm_rand[1]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[8]]));
    22bc:	90 91 04 03 	lds	r25, 0x0304
    22c0:	8c 8f       	std	Y+28, r24	; 0x1c
    22c2:	1b 8e       	std	Y+27, r1	; 0x1b
    22c4:	2b 8d       	ldd	r18, Y+27	; 0x1b
    22c6:	3c 8d       	ldd	r19, Y+28	; 0x1c
    22c8:	29 0f       	add	r18, r25
    22ca:	31 1d       	adc	r19, r1
    22cc:	24 53       	subi	r18, 0x34	; 52
    22ce:	3f 4f       	sbci	r19, 0xFF	; 255
    22d0:	f9 01       	movw	r30, r18
    22d2:	94 91       	lpm	r25, Z
    22d4:	20 91 0b 03 	lds	r18, 0x030B
    22d8:	fa 2d       	mov	r31, r10
    22da:	ee 27       	eor	r30, r30
    22dc:	e2 0f       	add	r30, r18
    22de:	f1 1d       	adc	r31, r1
    22e0:	e4 53       	subi	r30, 0x34	; 52
    22e2:	ff 4f       	sbci	r31, 0xFF	; 255
    22e4:	e4 91       	lpm	r30, Z
    22e6:	e9 27       	eor	r30, r25
    22e8:	e0 93 fc 02 	sts	0x02FC, r30
	
	wm_sb[0] = pgm_read_byte(&(sboxes[idx + 1][wm_key[0]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[1]]));
    22ec:	90 91 fd 02 	lds	r25, 0x02FD
    22f0:	8e 8f       	std	Y+30, r24	; 0x1e
    22f2:	1d 8e       	std	Y+29, r1	; 0x1d
    22f4:	2d 8d       	ldd	r18, Y+29	; 0x1d
    22f6:	3e 8d       	ldd	r19, Y+30	; 0x1e
    22f8:	29 0f       	add	r18, r25
    22fa:	31 1d       	adc	r19, r1
    22fc:	24 53       	subi	r18, 0x34	; 52
    22fe:	3f 4f       	sbci	r19, 0xFF	; 255
    2300:	f9 01       	movw	r30, r18
    2302:	94 91       	lpm	r25, Z
    2304:	20 91 04 03 	lds	r18, 0x0304
    2308:	fa 2d       	mov	r31, r10
    230a:	ee 27       	eor	r30, r30
    230c:	e2 0f       	add	r30, r18
    230e:	f1 1d       	adc	r31, r1
    2310:	e4 53       	subi	r30, 0x34	; 52
    2312:	ff 4f       	sbci	r31, 0xFF	; 255
    2314:	e4 91       	lpm	r30, Z
    2316:	e9 27       	eor	r30, r25
    2318:	e0 93 ed 02 	sts	0x02ED, r30
	wm_sb[1] = pgm_read_byte(&(sboxes[idx + 1][wm_key[5]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[4]]));
    231c:	90 91 02 03 	lds	r25, 0x0302
    2320:	88 a3       	std	Y+32, r24	; 0x20
    2322:	1f 8e       	std	Y+31, r1	; 0x1f
    2324:	2f 8d       	ldd	r18, Y+31	; 0x1f
    2326:	38 a1       	ldd	r19, Y+32	; 0x20
    2328:	29 0f       	add	r18, r25
    232a:	31 1d       	adc	r19, r1
    232c:	24 53       	subi	r18, 0x34	; 52
    232e:	3f 4f       	sbci	r19, 0xFF	; 255
    2330:	f9 01       	movw	r30, r18
    2332:	94 91       	lpm	r25, Z
    2334:	20 91 07 03 	lds	r18, 0x0307
    2338:	fa 2d       	mov	r31, r10
    233a:	ee 27       	eor	r30, r30
    233c:	e2 0f       	add	r30, r18
    233e:	f1 1d       	adc	r31, r1
    2340:	e4 53       	subi	r30, 0x34	; 52
    2342:	ff 4f       	sbci	r31, 0xFF	; 255
    2344:	e4 91       	lpm	r30, Z
    2346:	e9 27       	eor	r30, r25
    2348:	e0 93 ee 02 	sts	0x02EE, r30
	wm_sb[2] = pgm_read_byte(&(sboxes[idx + 1][wm_key[3]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[0]]));
    234c:	90 91 00 03 	lds	r25, 0x0300
    2350:	8a a3       	std	Y+34, r24	; 0x22
    2352:	19 a2       	std	Y+33, r1	; 0x21
    2354:	29 a1       	ldd	r18, Y+33	; 0x21
    2356:	3a a1       	ldd	r19, Y+34	; 0x22
    2358:	29 0f       	add	r18, r25
    235a:	31 1d       	adc	r19, r1
    235c:	24 53       	subi	r18, 0x34	; 52
    235e:	3f 4f       	sbci	r19, 0xFF	; 255
    2360:	f9 01       	movw	r30, r18
    2362:	94 91       	lpm	r25, Z
    2364:	20 91 03 03 	lds	r18, 0x0303
    2368:	fa 2d       	mov	r31, r10
    236a:	ee 27       	eor	r30, r30
    236c:	e2 0f       	add	r30, r18
    236e:	f1 1d       	adc	r31, r1
    2370:	e4 53       	subi	r30, 0x34	; 52
    2372:	ff 4f       	sbci	r31, 0xFF	; 255
    2374:	e4 91       	lpm	r30, Z
    2376:	e9 27       	eor	r30, r25
    2378:	e0 93 ef 02 	sts	0x02EF, r30
	wm_sb[3] = pgm_read_byte(&(sboxes[idx + 1][wm_key[2]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[9]]));
    237c:	90 91 ff 02 	lds	r25, 0x02FF
    2380:	8c a3       	std	Y+36, r24	; 0x24
    2382:	1b a2       	std	Y+35, r1	; 0x23
    2384:	2b a1       	ldd	r18, Y+35	; 0x23
    2386:	3c a1       	ldd	r19, Y+36	; 0x24
    2388:	29 0f       	add	r18, r25
    238a:	31 1d       	adc	r19, r1
    238c:	24 53       	subi	r18, 0x34	; 52
    238e:	3f 4f       	sbci	r19, 0xFF	; 255
    2390:	f9 01       	movw	r30, r18
    2392:	94 91       	lpm	r25, Z
    2394:	20 91 0c 03 	lds	r18, 0x030C
    2398:	fa 2d       	mov	r31, r10
    239a:	ee 27       	eor	r30, r30
    239c:	e2 0f       	add	r30, r18
    239e:	f1 1d       	adc	r31, r1
    23a0:	e4 53       	subi	r30, 0x34	; 52
    23a2:	ff 4f       	sbci	r31, 0xFF	; 255
    23a4:	e4 91       	lpm	r30, Z
    23a6:	e9 27       	eor	r30, r25
    23a8:	e0 93 f0 02 	sts	0x02F0, r30
	wm_sb[4] = pgm_read_byte(&(sboxes[idx + 1][wm_key[4]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[7]]));
    23ac:	90 91 01 03 	lds	r25, 0x0301
    23b0:	8e a3       	std	Y+38, r24	; 0x26
    23b2:	1d a2       	std	Y+37, r1	; 0x25
    23b4:	2d a1       	ldd	r18, Y+37	; 0x25
    23b6:	3e a1       	ldd	r19, Y+38	; 0x26
    23b8:	29 0f       	add	r18, r25
    23ba:	31 1d       	adc	r19, r1
    23bc:	24 53       	subi	r18, 0x34	; 52
    23be:	3f 4f       	sbci	r19, 0xFF	; 255
    23c0:	f9 01       	movw	r30, r18
    23c2:	94 91       	lpm	r25, Z
    23c4:	20 91 0a 03 	lds	r18, 0x030A
    23c8:	fa 2d       	mov	r31, r10
    23ca:	ee 27       	eor	r30, r30
    23cc:	e2 0f       	add	r30, r18
    23ce:	f1 1d       	adc	r31, r1
    23d0:	e4 53       	subi	r30, 0x34	; 52
    23d2:	ff 4f       	sbci	r31, 0xFF	; 255
    23d4:	e4 91       	lpm	r30, Z
    23d6:	e9 27       	eor	r30, r25
    23d8:	e0 93 f1 02 	sts	0x02F1, r30
	wm_sb[5] = pgm_read_byte(&(sboxes[idx + 1][wm_key[1]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[8]]));
    23dc:	90 91 fe 02 	lds	r25, 0x02FE
    23e0:	88 a7       	std	Y+40, r24	; 0x28
    23e2:	1f a2       	std	Y+39, r1	; 0x27
    23e4:	2f a1       	ldd	r18, Y+39	; 0x27
    23e6:	38 a5       	ldd	r19, Y+40	; 0x28
    23e8:	29 0f       	add	r18, r25
    23ea:	31 1d       	adc	r19, r1
    23ec:	24 53       	subi	r18, 0x34	; 52
    23ee:	3f 4f       	sbci	r19, 0xFF	; 255
    23f0:	f9 01       	movw	r30, r18
    23f2:	94 91       	lpm	r25, Z
    23f4:	20 91 0b 03 	lds	r18, 0x030B
    23f8:	fa 2d       	mov	r31, r10
    23fa:	ee 27       	eor	r30, r30
    23fc:	e2 0f       	add	r30, r18
    23fe:	f1 1d       	adc	r31, r1
    2400:	e4 53       	subi	r30, 0x34	; 52
    2402:	ff 4f       	sbci	r31, 0xFF	; 255
    2404:	e4 91       	lpm	r30, Z
    2406:	e9 27       	eor	r30, r25
    2408:	e0 93 f2 02 	sts	0x02F2, r30
	wm_sb[6] = pgm_read_byte(&(sboxes[idx + 1][wm_rand[3]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[5]]));
    240c:	90 91 06 03 	lds	r25, 0x0306
    2410:	8a a7       	std	Y+42, r24	; 0x2a
    2412:	19 a6       	std	Y+41, r1	; 0x29
    2414:	29 a5       	ldd	r18, Y+41	; 0x29
    2416:	3a a5       	ldd	r19, Y+42	; 0x2a
    2418:	29 0f       	add	r18, r25
    241a:	31 1d       	adc	r19, r1
    241c:	24 53       	subi	r18, 0x34	; 52
    241e:	3f 4f       	sbci	r19, 0xFF	; 255
    2420:	f9 01       	movw	r30, r18
    2422:	94 91       	lpm	r25, Z
    2424:	20 91 08 03 	lds	r18, 0x0308
    2428:	fa 2d       	mov	r31, r10
    242a:	ee 27       	eor	r30, r30
    242c:	e2 0f       	add	r30, r18
    242e:	f1 1d       	adc	r31, r1
    2430:	e4 53       	subi	r30, 0x34	; 52
    2432:	ff 4f       	sbci	r31, 0xFF	; 255
    2434:	e4 91       	lpm	r30, Z
    2436:	e9 27       	eor	r30, r25
    2438:	e0 93 f3 02 	sts	0x02F3, r30
	wm_sb[7] = pgm_read_byte(&(sboxes[idx + 1][wm_rand[2]])) ^ pgm_read_byte(&(sboxes[idx + 2][wm_rand[6]]));
    243c:	90 91 05 03 	lds	r25, 0x0305
    2440:	38 2e       	mov	r3, r24
    2442:	21 2c       	mov	r2, r1
    2444:	29 0e       	add	r2, r25
    2446:	31 1c       	adc	r3, r1
    2448:	91 01       	movw	r18, r2
    244a:	24 53       	subi	r18, 0x34	; 52
    244c:	3f 4f       	sbci	r19, 0xFF	; 255
    244e:	f9 01       	movw	r30, r18
    2450:	24 90       	lpm	r2, Z
    2452:	80 91 09 03 	lds	r24, 0x0309
    2456:	fa 2d       	mov	r31, r10
    2458:	ee 27       	eor	r30, r30
    245a:	e8 0f       	add	r30, r24
    245c:	f1 1d       	adc	r31, r1
    245e:	e4 53       	subi	r30, 0x34	; 52
    2460:	ff 4f       	sbci	r31, 0xFF	; 255
    2462:	e4 91       	lpm	r30, Z
    2464:	e2 25       	eor	r30, r2
    2466:	e0 93 f4 02 	sts	0x02F4, r30
	g_enc_on = 1;
    246a:	81 e0       	ldi	r24, 0x01	; 1
    246c:	80 93 0e 03 	sts	0x030E, r24
}
    2470:	e2 96       	adiw	r28, 0x32	; 50
    2472:	0f b6       	in	r0, 0x3f	; 63
    2474:	f8 94       	cli
    2476:	de bf       	out	0x3e, r29	; 62
    2478:	0f be       	out	0x3f, r0	; 63
    247a:	cd bf       	out	0x3d, r28	; 61
    247c:	df 91       	pop	r29
    247e:	cf 91       	pop	r28
    2480:	1f 91       	pop	r17
    2482:	0f 91       	pop	r16
    2484:	ff 90       	pop	r15
    2486:	ef 90       	pop	r14
    2488:	df 90       	pop	r13
    248a:	cf 90       	pop	r12
    248c:	bf 90       	pop	r11
    248e:	af 90       	pop	r10
    2490:	9f 90       	pop	r9
    2492:	8f 90       	pop	r8
    2494:	7f 90       	pop	r7
    2496:	6f 90       	pop	r6
    2498:	5f 90       	pop	r5
    249a:	4f 90       	pop	r4
    249c:	3f 90       	pop	r3
    249e:	2f 90       	pop	r2
    24a0:	08 95       	ret

000024a2 <wm_slaveTxStart>:

void wm_slaveTxStart(unsigned char addr)
{
	if(addr >= 0x00 && addr < 0x06)
    24a2:	86 30       	cpi	r24, 0x06	; 6
    24a4:	28 f4       	brcc	.+10     	; 0x24b0 <wm_slaveTxStart+0xe>
	{
		// call user event
		wm_sample_event();
    24a6:	e0 91 0f 03 	lds	r30, 0x030F
    24aa:	f0 91 10 03 	lds	r31, 0x0310
    24ae:	09 94       	ijmp
    24b0:	08 95       	ret

000024b2 <wm_slaveRx>:
void wm_slaveRx(unsigned char addr, unsigned char l)
{
	unsigned int i;
	
	// if encryption data is sent, store them accordingly
	if(addr >= 0x40 && addr < 0x46)
    24b2:	90 ec       	ldi	r25, 0xC0	; 192
    24b4:	98 0f       	add	r25, r24
    24b6:	96 30       	cpi	r25, 0x06	; 6
    24b8:	98 f4       	brcc	.+38     	; 0x24e0 <wm_slaveRx+0x2e>
    24ba:	80 e4       	ldi	r24, 0x40	; 64
    24bc:	90 e0       	ldi	r25, 0x00	; 0
	{
		for(i = 0; i < 6; i++)
		{
			wm_rand[9 - i] = twi_reg[0x40 + i];
    24be:	29 e4       	ldi	r18, 0x49	; 73
    24c0:	30 e0       	ldi	r19, 0x00	; 0
    24c2:	f9 01       	movw	r30, r18
    24c4:	e8 1b       	sub	r30, r24
    24c6:	f9 0b       	sbc	r31, r25
    24c8:	dc 01       	movw	r26, r24
    24ca:	a3 51       	subi	r26, 0x13	; 19
    24cc:	be 4f       	sbci	r27, 0xFE	; 254
    24ce:	4c 91       	ld	r20, X
    24d0:	ed 5f       	subi	r30, 0xFD	; 253
    24d2:	fc 4f       	sbci	r31, 0xFC	; 252
    24d4:	40 83       	st	Z, r20
    24d6:	01 96       	adiw	r24, 0x01	; 1
	unsigned int i;
	
	// if encryption data is sent, store them accordingly
	if(addr >= 0x40 && addr < 0x46)
	{
		for(i = 0; i < 6; i++)
    24d8:	86 34       	cpi	r24, 0x46	; 70
    24da:	91 05       	cpc	r25, r1
    24dc:	91 f7       	brne	.-28     	; 0x24c2 <wm_slaveRx+0x10>
    24de:	08 95       	ret
		{
			wm_rand[9 - i] = twi_reg[0x40 + i];
		}
		//	wm_gentabs();
	}
	else if(addr >= 0x46 && addr < 0x4C)
    24e0:	9a eb       	ldi	r25, 0xBA	; 186
    24e2:	98 0f       	add	r25, r24
    24e4:	96 30       	cpi	r25, 0x06	; 6
    24e6:	c8 f4       	brcc	.+50     	; 0x251a <wm_slaveRx+0x68>
	{
		for(i = 6; i < 10; i++)
		{
			wm_rand[9 - i] = twi_reg[0x40 + i];
    24e8:	80 91 33 02 	lds	r24, 0x0233
    24ec:	80 93 06 03 	sts	0x0306, r24
    24f0:	80 91 34 02 	lds	r24, 0x0234
    24f4:	80 93 05 03 	sts	0x0305, r24
    24f8:	80 91 35 02 	lds	r24, 0x0235
    24fc:	80 93 04 03 	sts	0x0304, r24
    2500:	80 91 36 02 	lds	r24, 0x0236
    2504:	80 93 03 03 	sts	0x0303, r24
		}
		for(i = 0; i < 2; i++)
		{
			wm_key[5 - i] = twi_reg[0x40 + 10 + i];
    2508:	80 91 37 02 	lds	r24, 0x0237
    250c:	80 93 02 03 	sts	0x0302, r24
    2510:	80 91 38 02 	lds	r24, 0x0238
    2514:	80 93 01 03 	sts	0x0301, r24
    2518:	08 95       	ret
		}
		//	wm_gentabs();
	}
	else if(addr >= 0x4C && addr < 0x50)
    251a:	94 eb       	ldi	r25, 0xB4	; 180
    251c:	98 0f       	add	r25, r24
    251e:	94 30       	cpi	r25, 0x04	; 4
    2520:	b8 f4       	brcc	.+46     	; 0x2550 <wm_slaveRx+0x9e>
	{
		for(i = 2; i < 6; i++)
		{
			wm_key[5 - i] = twi_reg[0x40 + 10 + i];
    2522:	90 91 39 02 	lds	r25, 0x0239
    2526:	90 93 00 03 	sts	0x0300, r25
    252a:	90 91 3a 02 	lds	r25, 0x023A
    252e:	90 93 ff 02 	sts	0x02FF, r25
    2532:	90 91 3b 02 	lds	r25, 0x023B
    2536:	90 93 fe 02 	sts	0x02FE, r25
    253a:	90 91 3c 02 	lds	r25, 0x023C
    253e:	90 93 fd 02 	sts	0x02FD, r25
		}
		if (addr + l == 0x50) {
    2542:	70 e0       	ldi	r23, 0x00	; 0
    2544:	68 0f       	add	r22, r24
    2546:	71 1d       	adc	r23, r1
    2548:	60 35       	cpi	r22, 0x50	; 80
    254a:	71 05       	cpc	r23, r1
    254c:	09 f4       	brne	.+2      	; 0x2550 <wm_slaveRx+0x9e>
			// generate decryption once all data is loaded
			wm_gentabs();
    254e:	0b cd       	rjmp	.-1514   	; 0x1f66 <wm_gentabs>
    2550:	08 95       	ret

00002552 <wm_newaction>:
    2552:	46 2f       	mov	r20, r22
}

void wm_newaction(unsigned char * d, unsigned char len)
{
	// load button data from user application
	memcpy((void*)twi_reg, d, len);
    2554:	50 e0       	ldi	r21, 0x00	; 0
    2556:	bc 01       	movw	r22, r24
    2558:	8d ee       	ldi	r24, 0xED	; 237
    255a:	91 e0       	ldi	r25, 0x01	; 1
    255c:	0c 94 bd 2a 	jmp	0x557a	; 0x557a <memcpy>

00002560 <wm_init>:
}

void wm_init(unsigned char * id, unsigned char * t, unsigned char len, unsigned char * cal_data, void (*function)(void))
{
    2560:	ef 92       	push	r14
    2562:	ff 92       	push	r15
    2564:	0f 93       	push	r16
    2566:	1f 93       	push	r17
    2568:	cf 93       	push	r28
    256a:	df 93       	push	r29
    256c:	00 d0       	rcall	.+0      	; 0x256e <wm_init+0xe>
    256e:	cd b7       	in	r28, 0x3d	; 61
    2570:	de b7       	in	r29, 0x3e	; 62
    2572:	7c 01       	movw	r14, r24
    2574:	cb 01       	movw	r24, r22
	unsigned int i,j;
	wm_started=0;	
    2576:	10 92 0d 03 	sts	0x030D, r1
	// link user function
	wm_sample_event = function;
    257a:	10 93 10 03 	sts	0x0310, r17
    257e:	00 93 0f 03 	sts	0x030F, r16
	// start state
	wm_newaction(t, len);
    2582:	64 2f       	mov	r22, r20
    2584:	29 83       	std	Y+1, r18	; 0x01
    2586:	3a 83       	std	Y+2, r19	; 0x02
    2588:	e4 df       	rcall	.-56     	; 0x2552 <wm_newaction>
    258a:	10 92 dd 02 	sts	0x02DD, r1
	twi_reg[WM_EXP_MEM_ENABLE1] = 0; // disable encryption
    258e:	86 e0       	ldi	r24, 0x06	; 6

	// set id
	memcpy(default_id, id, 6);
    2590:	f7 01       	movw	r30, r14
    2592:	ab ed       	ldi	r26, 0xDB	; 219
    2594:	b1 e0       	ldi	r27, 0x01	; 1
    2596:	01 90       	ld	r0, Z+
    2598:	0d 92       	st	X+, r0
    259a:	8a 95       	dec	r24
    259c:	e1 f7       	brne	.-8      	; 0x2596 <wm_init+0x36>
    259e:	86 e0       	ldi	r24, 0x06	; 6
	memcpy(twi_reg + WM_EXP_ID, default_id, 6);
    25a0:	eb ed       	ldi	r30, 0xDB	; 219
    25a2:	f1 e0       	ldi	r31, 0x01	; 1
    25a4:	a7 ee       	ldi	r26, 0xE7	; 231
    25a6:	b2 e0       	ldi	r27, 0x02	; 2
    25a8:	01 90       	ld	r0, Z+
    25aa:	0d 92       	st	X+, r0
    25ac:	8a 95       	dec	r24
    25ae:	e1 f7       	brne	.-8      	; 0x25a8 <wm_init+0x48>
    25b0:	29 81       	ldd	r18, Y+1	; 0x01
    25b2:	e2 2f       	mov	r30, r18
    25b4:	3a 81       	ldd	r19, Y+2	; 0x02
    25b6:	f3 2f       	mov	r31, r19
    25b8:	80 e2       	ldi	r24, 0x20	; 32


	// set calibration data
	for(i = 0, j = WM_EXP_MEM_CALIBR; i < 32; i++, j++)
    25ba:	90 e0       	ldi	r25, 0x00	; 0
    25bc:	21 91       	ld	r18, Z+
	{
		twi_reg[j] = cal_data[i];
    25be:	dc 01       	movw	r26, r24
    25c0:	a3 51       	subi	r26, 0x13	; 19
    25c2:	be 4f       	sbci	r27, 0xFE	; 254
    25c4:	2c 93       	st	X, r18
    25c6:	01 96       	adiw	r24, 0x01	; 1
	memcpy(default_id, id, 6);
	memcpy(twi_reg + WM_EXP_ID, default_id, 6);


	// set calibration data
	for(i = 0, j = WM_EXP_MEM_CALIBR; i < 32; i++, j++)
    25c8:	80 34       	cpi	r24, 0x40	; 64
    25ca:	91 05       	cpc	r25, r1
    25cc:	b9 f7       	brne	.-18     	; 0x25bc <wm_init+0x5c>
    25ce:	2f ef       	ldi	r18, 0xFF	; 255
    25d0:	89 e6       	ldi	r24, 0x69	; 105
    25d2:	98 e1       	ldi	r25, 0x18	; 24
    25d4:	21 50       	subi	r18, 0x01	; 1
    25d6:	80 40       	sbci	r24, 0x00	; 0
    25d8:	90 40       	sbci	r25, 0x00	; 0
    25da:	e1 f7       	brne	.-8      	; 0x25d4 <wm_init+0x74>
    25dc:	00 c0       	rjmp	.+0      	; 0x25de <wm_init+0x7e>
    25de:	00 00       	nop
    25e0:	58 98       	cbi	0x0b, 0	; 11
	}

	_delay_ms(500);

	// ready twi bus, no pull-ups
	twi_port &= 0xFF ^ _BV(twi_scl_pin);
    25e2:	59 98       	cbi	0x0b, 1	; 11
	twi_port &= 0xFF ^ _BV(twi_sda_pin);
    25e4:	50 9a       	sbi	0x0a, 0	; 10

	twi_ddr |= _BV(twi_scl_pin); // test: Pull clk while busy initializing
    25e6:	8a b1       	in	r24, 0x0a	; 10
}
//todo: rename all _bv stuff to 1<< i.e. _BV(6) is the same as 1<<6

static void twi_slave_init(unsigned char addr)
{
	twi_ddr &= ~0x03;
    25e8:	8c 7f       	andi	r24, 0xFC	; 252
    25ea:	8a b9       	out	0x0a, r24	; 10
    25ec:	10 92 ec 01 	sts	0x01EC, r1
	
	// initialize stuff
	twi_reg_addr = 0;
    25f0:	10 92 eb 01 	sts	0x01EB, r1
    25f4:	84 ea       	ldi	r24, 0xA4	; 164

	// set slave address
	TWAR = addr << 1;
    25f6:	80 93 ba 00 	sts	0x00BA, r24
    25fa:	10 92 b9 00 	sts	0x00B9, r1
	
	TWSR = 0;// no prescaler 
    25fe:	88 e4       	ldi	r24, 0x48	; 72
	
	TWBR = ((F_CPU / 100000) - 16) / 2;          // set the I2C clock rate to 400kHz
    2600:	80 93 b8 00 	sts	0x00B8, r24
    2604:	81 ec       	ldi	r24, 0xC1	; 193
	 
	// enable twi module, acks, and twi interrupt
	//   Interrupt Enable    |- Enable Acknowledge Bit
	//          |            |       /-clear flag
	TWCR = _BV(TWIE) | _BV(TWEA) | _BV(TWINT) ;
    2606:	80 93 bc 00 	sts	0x00BC, r24
    260a:	10 92 89 03 	sts	0x0389, r1

	high_res_mode=0; 
    260e:	0f 90       	pop	r0
	twi_slave_init(0x52);

	// make the wiimote think something is connected by bring this pin high
	//dev_detect_port |= _BV(dev_detect_pin);
	
}
    2610:	0f 90       	pop	r0
    2612:	df 91       	pop	r29
    2614:	cf 91       	pop	r28
    2616:	1f 91       	pop	r17
    2618:	0f 91       	pop	r16
    261a:	ff 90       	pop	r15
    261c:	ef 90       	pop	r14
    261e:	08 95       	ret

00002620 <wm_start>:
    2620:	80 91 0d 03 	lds	r24, 0x030D
	TWCR &= 0xFF ^  _BV(TWEN);// Stop I2C
	cli();
}
void wm_start(void)
{	
	if (!wm_started) {	// Start I2C
    2624:	81 11       	cpse	r24, r1
    2626:	09 c0       	rjmp	.+18     	; 0x263a <wm_start+0x1a>
	
		TWCR |= _BV(TWEN);
    2628:	80 91 bc 00 	lds	r24, 0x00BC
    262c:	84 60       	ori	r24, 0x04	; 4
    262e:	80 93 bc 00 	sts	0x00BC, r24
		wm_started = 1;
    2632:	81 e0       	ldi	r24, 0x01	; 1
    2634:	80 93 0d 03 	sts	0x030D, r24
		sei();
    2638:	78 94       	sei
    263a:	08 95       	ret

0000263c <__vector_36>:
	memcpy(alt_id, id, 6);
	alt_id_set = 1;
}

ISR(TWI_vect)
{
    263c:	1f 92       	push	r1
    263e:	0f 92       	push	r0
    2640:	0f b6       	in	r0, 0x3f	; 63
    2642:	0f 92       	push	r0
    2644:	11 24       	eor	r1, r1
    2646:	2f 93       	push	r18
    2648:	3f 93       	push	r19
    264a:	4f 93       	push	r20
    264c:	5f 93       	push	r21
    264e:	6f 93       	push	r22
    2650:	7f 93       	push	r23
    2652:	8f 93       	push	r24
    2654:	9f 93       	push	r25
    2656:	af 93       	push	r26
    2658:	bf 93       	push	r27
    265a:	ef 93       	push	r30
    265c:	ff 93       	push	r31
	switch(TW_STATUS)
    265e:	80 91 b9 00 	lds	r24, 0x00B9
    2662:	88 7f       	andi	r24, 0xF8	; 248
    2664:	80 39       	cpi	r24, 0x90	; 144
    2666:	51 f1       	breq	.+84     	; 0x26bc <__vector_36+0x80>
    2668:	88 f4       	brcc	.+34     	; 0x268c <__vector_36+0x50>
    266a:	80 37       	cpi	r24, 0x70	; 112
    266c:	21 f1       	breq	.+72     	; 0x26b6 <__vector_36+0x7a>
    266e:	28 f4       	brcc	.+10     	; 0x267a <__vector_36+0x3e>
    2670:	80 36       	cpi	r24, 0x60	; 96
    2672:	09 f1       	breq	.+66     	; 0x26b6 <__vector_36+0x7a>
    2674:	88 36       	cpi	r24, 0x68	; 104
    2676:	f9 f0       	breq	.+62     	; 0x26b6 <__vector_36+0x7a>
    2678:	de c0       	rjmp	.+444    	; 0x2836 <__vector_36+0x1fa>
    267a:	80 38       	cpi	r24, 0x80	; 128
    267c:	f9 f0       	breq	.+62     	; 0x26bc <__vector_36+0x80>
    267e:	88 38       	cpi	r24, 0x88	; 136
    2680:	09 f4       	brne	.+2      	; 0x2684 <__vector_36+0x48>
    2682:	d9 c0       	rjmp	.+434    	; 0x2836 <__vector_36+0x1fa>
    2684:	88 37       	cpi	r24, 0x78	; 120
    2686:	09 f0       	breq	.+2      	; 0x268a <__vector_36+0x4e>
    2688:	d6 c0       	rjmp	.+428    	; 0x2836 <__vector_36+0x1fa>
    268a:	15 c0       	rjmp	.+42     	; 0x26b6 <__vector_36+0x7a>
    268c:	80 3b       	cpi	r24, 0xB0	; 176
    268e:	09 f4       	brne	.+2      	; 0x2692 <__vector_36+0x56>
    2690:	98 c0       	rjmp	.+304    	; 0x27c2 <__vector_36+0x186>
    2692:	38 f4       	brcc	.+14     	; 0x26a2 <__vector_36+0x66>
    2694:	80 3a       	cpi	r24, 0xA0	; 160
    2696:	09 f4       	brne	.+2      	; 0x269a <__vector_36+0x5e>
    2698:	89 c0       	rjmp	.+274    	; 0x27ac <__vector_36+0x170>
    269a:	88 3a       	cpi	r24, 0xA8	; 168
    269c:	09 f0       	breq	.+2      	; 0x26a0 <__vector_36+0x64>
    269e:	cb c0       	rjmp	.+406    	; 0x2836 <__vector_36+0x1fa>
    26a0:	90 c0       	rjmp	.+288    	; 0x27c2 <__vector_36+0x186>
    26a2:	80 3c       	cpi	r24, 0xC0	; 192
    26a4:	09 f4       	brne	.+2      	; 0x26a8 <__vector_36+0x6c>
    26a6:	c5 c0       	rjmp	.+394    	; 0x2832 <__vector_36+0x1f6>
    26a8:	88 3c       	cpi	r24, 0xC8	; 200
    26aa:	09 f4       	brne	.+2      	; 0x26ae <__vector_36+0x72>
    26ac:	c2 c0       	rjmp	.+388    	; 0x2832 <__vector_36+0x1f6>
    26ae:	88 3b       	cpi	r24, 0xB8	; 184
    26b0:	09 f4       	brne	.+2      	; 0x26b4 <__vector_36+0x78>
    26b2:	8e c0       	rjmp	.+284    	; 0x27d0 <__vector_36+0x194>
    26b4:	c0 c0       	rjmp	.+384    	; 0x2836 <__vector_36+0x1fa>
		case TW_SR_GCALL_ACK: // addressed generally, returned ack
		case TW_SR_ARB_LOST_SLA_ACK: // lost arbitration, returned ack
		case TW_SR_ARB_LOST_GCALL_ACK: // lost arbitration generally, returned ack
		
			// get ready to receive pointer
			twi_first_addr_flag = 0;
    26b6:	10 92 ea 01 	sts	0x01EA, r1
    26ba:	bb c0       	rjmp	.+374    	; 0x2832 <__vector_36+0x1f6>
		case TW_SR_DATA_ACK: // data received, returned ack
		case TW_SR_GCALL_DATA_ACK: // data received generally, returned ack
		
		
		
		if(twi_first_addr_flag != 0)
    26bc:	80 91 ea 01 	lds	r24, 0x01EA
    26c0:	88 23       	and	r24, r24
    26c2:	09 f4       	brne	.+2      	; 0x26c6 <__vector_36+0x8a>
    26c4:	66 c0       	rjmp	.+204    	; 0x2792 <__vector_36+0x156>
		{
			// put byte in register
			unsigned char t = TWDR;
    26c6:	20 91 bb 00 	lds	r18, 0x00BB

			if (twi_reg_addr == 0xFE && t == 0x03 ) high_res_mode=1;
    26ca:	80 91 eb 01 	lds	r24, 0x01EB
    26ce:	90 91 ec 01 	lds	r25, 0x01EC
    26d2:	8e 3f       	cpi	r24, 0xFE	; 254
    26d4:	91 05       	cpc	r25, r1
    26d6:	29 f4       	brne	.+10     	; 0x26e2 <__vector_36+0xa6>
    26d8:	23 30       	cpi	r18, 0x03	; 3
    26da:	19 f4       	brne	.+6      	; 0x26e2 <__vector_36+0xa6>
    26dc:	81 e0       	ldi	r24, 0x01	; 1
    26de:	80 93 89 03 	sts	0x0389, r24
			
			if ((twi_reg_addr == 0xF0) && (t == 0x55 || t == 0xAA)) {
    26e2:	80 91 eb 01 	lds	r24, 0x01EB
    26e6:	90 91 ec 01 	lds	r25, 0x01EC
    26ea:	80 3f       	cpi	r24, 0xF0	; 240
    26ec:	91 05       	cpc	r25, r1
    26ee:	89 f4       	brne	.+34     	; 0x2712 <__vector_36+0xd6>
    26f0:	25 35       	cpi	r18, 0x55	; 85
    26f2:	11 f0       	breq	.+4      	; 0x26f8 <__vector_36+0xbc>
    26f4:	2a 3a       	cpi	r18, 0xAA	; 170
    26f6:	69 f4       	brne	.+26     	; 0x2712 <__vector_36+0xd6>
				g_enc_on = 0;
    26f8:	10 92 0e 03 	sts	0x030E, r1
				memcpy(twi_reg + WM_EXP_ID, default_id, 6);
    26fc:	86 e0       	ldi	r24, 0x06	; 6
    26fe:	eb ed       	ldi	r30, 0xDB	; 219
    2700:	f1 e0       	ldi	r31, 0x01	; 1
    2702:	a7 ee       	ldi	r26, 0xE7	; 231
    2704:	b2 e0       	ldi	r27, 0x02	; 2
    2706:	01 90       	ld	r0, Z+
    2708:	0d 92       	st	X+, r0
    270a:	8a 95       	dec	r24
    270c:	e1 f7       	brne	.-8      	; 0x2706 <__vector_36+0xca>
				alt_id_enabled = 0;
    270e:	10 92 e7 01 	sts	0x01E7, r1
			}

			// Writing 0x64 to register 0x00 after disabling encryption but
			// before reading the extension id enables an alternate extension
			// id. Adapted controller data is the reported as is.
			if ((twi_reg_addr == 0x00) && (t == 0x64) && alt_id_set) {
    2712:	80 91 eb 01 	lds	r24, 0x01EB
    2716:	90 91 ec 01 	lds	r25, 0x01EC
    271a:	89 2b       	or	r24, r25
    271c:	91 f4       	brne	.+36     	; 0x2742 <__vector_36+0x106>
    271e:	24 36       	cpi	r18, 0x64	; 100
    2720:	81 f4       	brne	.+32     	; 0x2742 <__vector_36+0x106>
    2722:	80 91 e8 01 	lds	r24, 0x01E8
    2726:	88 23       	and	r24, r24
    2728:	61 f0       	breq	.+24     	; 0x2742 <__vector_36+0x106>
				memcpy(twi_reg + WM_EXP_ID, alt_id, 6);
    272a:	86 e0       	ldi	r24, 0x06	; 6
    272c:	e1 ee       	ldi	r30, 0xE1	; 225
    272e:	f1 e0       	ldi	r31, 0x01	; 1
    2730:	a7 ee       	ldi	r26, 0xE7	; 231
    2732:	b2 e0       	ldi	r27, 0x02	; 2
    2734:	01 90       	ld	r0, Z+
    2736:	0d 92       	st	X+, r0
    2738:	8a 95       	dec	r24
    273a:	e1 f7       	brne	.-8      	; 0x2734 <__vector_36+0xf8>
				alt_id_enabled = 1;
    273c:	81 e0       	ldi	r24, 0x01	; 1
    273e:	80 93 e7 01 	sts	0x01E7, r24
			}
			
			if(g_enc_on ) // if encryption is on
    2742:	80 91 0e 03 	lds	r24, 0x030E
    2746:	88 23       	and	r24, r24
    2748:	e1 f0       	breq	.+56     	; 0x2782 <__vector_36+0x146>
			{
				// decrypt
				twi_reg[twi_reg_addr] = (t ^ wm_sb[twi_reg_addr % 8]) + wm_ft[twi_reg_addr % 8];
    274a:	a0 91 eb 01 	lds	r26, 0x01EB
    274e:	b0 91 ec 01 	lds	r27, 0x01EC
    2752:	e0 91 eb 01 	lds	r30, 0x01EB
    2756:	f0 91 ec 01 	lds	r31, 0x01EC
    275a:	e7 70       	andi	r30, 0x07	; 7
    275c:	ff 27       	eor	r31, r31
    275e:	e3 51       	subi	r30, 0x13	; 19
    2760:	fd 4f       	sbci	r31, 0xFD	; 253
    2762:	80 81       	ld	r24, Z
    2764:	e0 91 eb 01 	lds	r30, 0x01EB
    2768:	f0 91 ec 01 	lds	r31, 0x01EC
    276c:	e7 70       	andi	r30, 0x07	; 7
    276e:	ff 27       	eor	r31, r31
    2770:	eb 50       	subi	r30, 0x0B	; 11
    2772:	fd 4f       	sbci	r31, 0xFD	; 253
    2774:	90 81       	ld	r25, Z
    2776:	82 27       	eor	r24, r18
    2778:	89 0f       	add	r24, r25
    277a:	a3 51       	subi	r26, 0x13	; 19
    277c:	be 4f       	sbci	r27, 0xFE	; 254
    277e:	8c 93       	st	X, r24
    2780:	4a c0       	rjmp	.+148    	; 0x2816 <__vector_36+0x1da>
			}
			else
			{
				twi_reg[twi_reg_addr] = t;
    2782:	e0 91 eb 01 	lds	r30, 0x01EB
    2786:	f0 91 ec 01 	lds	r31, 0x01EC
    278a:	e3 51       	subi	r30, 0x13	; 19
    278c:	fe 4f       	sbci	r31, 0xFE	; 254
    278e:	20 83       	st	Z, r18
    2790:	42 c0       	rjmp	.+132    	; 0x2816 <__vector_36+0x1da>
			twi_rw_len++;
		}
		else
		{
			// set address
			twi_reg_addr = TWDR;
    2792:	80 91 bb 00 	lds	r24, 0x00BB
    2796:	90 e0       	ldi	r25, 0x00	; 0
    2798:	90 93 ec 01 	sts	0x01EC, r25
    279c:	80 93 eb 01 	sts	0x01EB, r24
			twi_first_addr_flag = 1;
    27a0:	81 e0       	ldi	r24, 0x01	; 1
    27a2:	80 93 ea 01 	sts	0x01EA, r24
			twi_rw_len = 0;
    27a6:	10 92 e9 01 	sts	0x01E9, r1
    27aa:	43 c0       	rjmp	.+134    	; 0x2832 <__vector_36+0x1f6>
		}
		twi_clear_int(1); // ack
			break;
		case TW_SR_STOP: // stop or repeated start condition received
			// run user defined function
			wm_slaveRx(twi_reg_addr - twi_rw_len, twi_rw_len);
    27ac:	60 91 e9 01 	lds	r22, 0x01E9
    27b0:	80 91 eb 01 	lds	r24, 0x01EB
    27b4:	90 91 ec 01 	lds	r25, 0x01EC
    27b8:	90 91 e9 01 	lds	r25, 0x01E9
    27bc:	89 1b       	sub	r24, r25
    27be:	79 de       	rcall	.-782    	; 0x24b2 <wm_slaveRx>
    27c0:	38 c0       	rjmp	.+112    	; 0x2832 <__vector_36+0x1f6>
    27c2:	80 91 eb 01 	lds	r24, 0x01EB
		
		// Slave Tx
		case TW_ST_SLA_ACK:	// addressed, returned ack
		case TW_ST_ARB_LOST_SLA_ACK: // arbitration lost, returned ack
			// run user defined function
			wm_slaveTxStart(twi_reg_addr);
    27c6:	90 91 ec 01 	lds	r25, 0x01EC
    27ca:	6b de       	rcall	.-810    	; 0x24a2 <wm_slaveTxStart>
    27cc:	10 92 e9 01 	sts	0x01E9, r1
			twi_rw_len = 0;
    27d0:	80 91 0e 03 	lds	r24, 0x030E
		case TW_ST_DATA_ACK: // byte sent, ack returned
			// ready output byte
			if(g_enc_on) // encryption is on
    27d4:	e0 91 eb 01 	lds	r30, 0x01EB
			{
				// encrypt
				TWDR = (twi_reg[twi_reg_addr] - wm_ft[twi_reg_addr % 8]) ^ wm_sb[twi_reg_addr % 8];
    27d8:	f0 91 ec 01 	lds	r31, 0x01EC
    27dc:	e3 51       	subi	r30, 0x13	; 19
    27de:	fe 4f       	sbci	r31, 0xFE	; 254
    27e0:	88 23       	and	r24, r24
    27e2:	b1 f0       	breq	.+44     	; 0x2810 <__vector_36+0x1d4>
			// run user defined function
			wm_slaveTxStart(twi_reg_addr);
			twi_rw_len = 0;
		case TW_ST_DATA_ACK: // byte sent, ack returned
			// ready output byte
			if(g_enc_on) // encryption is on
    27e4:	80 81       	ld	r24, Z
    27e6:	e0 91 eb 01 	lds	r30, 0x01EB
			{
				// encrypt
				TWDR = (twi_reg[twi_reg_addr] - wm_ft[twi_reg_addr % 8]) ^ wm_sb[twi_reg_addr % 8];
    27ea:	f0 91 ec 01 	lds	r31, 0x01EC
    27ee:	e7 70       	andi	r30, 0x07	; 7
    27f0:	ff 27       	eor	r31, r31
    27f2:	eb 50       	subi	r30, 0x0B	; 11
    27f4:	fd 4f       	sbci	r31, 0xFD	; 253
    27f6:	20 81       	ld	r18, Z
    27f8:	e0 91 eb 01 	lds	r30, 0x01EB
    27fc:	f0 91 ec 01 	lds	r31, 0x01EC
    2800:	e7 70       	andi	r30, 0x07	; 7
    2802:	ff 27       	eor	r31, r31
    2804:	e3 51       	subi	r30, 0x13	; 19
    2806:	fd 4f       	sbci	r31, 0xFD	; 253
    2808:	90 81       	ld	r25, Z
    280a:	82 1b       	sub	r24, r18
    280c:	89 27       	eor	r24, r25
    280e:	01 c0       	rjmp	.+2      	; 0x2812 <__vector_36+0x1d6>
    2810:	80 81       	ld	r24, Z
    2812:	80 93 bb 00 	sts	0x00BB, r24
			}
			else
			{
				TWDR = twi_reg[twi_reg_addr];
    2816:	80 91 eb 01 	lds	r24, 0x01EB
			}
			twi_reg_addr++;
    281a:	90 91 ec 01 	lds	r25, 0x01EC
    281e:	01 96       	adiw	r24, 0x01	; 1
    2820:	90 93 ec 01 	sts	0x01EC, r25
    2824:	80 93 eb 01 	sts	0x01EB, r24
    2828:	80 91 e9 01 	lds	r24, 0x01E9
			twi_rw_len++;
    282c:	8f 5f       	subi	r24, 0xFF	; 255
    282e:	80 93 e9 01 	sts	0x01E9, r24
    2832:	85 ec       	ldi	r24, 0xC5	; 197
    2834:	01 c0       	rjmp	.+2      	; 0x2838 <__vector_36+0x1fc>


	// get ready by clearing interrupt, with or without ack
	if(ack != 0)
	{
		TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT) | _BV(TWEA);
    2836:	85 e8       	ldi	r24, 0x85	; 133
    2838:	80 93 bc 00 	sts	0x00BC, r24
	}
	else
	{
		TWCR = _BV(TWEN) | _BV(TWIE) | _BV(TWINT);
    283c:	ff 91       	pop	r31
    283e:	ef 91       	pop	r30
			break;
		default:
			twi_clear_int(0);
			break;
	}
}
    2840:	bf 91       	pop	r27
    2842:	af 91       	pop	r26
    2844:	9f 91       	pop	r25
    2846:	8f 91       	pop	r24
    2848:	7f 91       	pop	r23
    284a:	6f 91       	pop	r22
    284c:	5f 91       	pop	r21
    284e:	4f 91       	pop	r20
    2850:	3f 91       	pop	r19
    2852:	2f 91       	pop	r18
    2854:	0f 90       	pop	r0
    2856:	0f be       	out	0x3f, r0	; 63
    2858:	0f 90       	pop	r0
    285a:	1f 90       	pop	r1
    285c:	18 95       	reti

0000285e <doWork>:
#define WHILE_LINE_IS_HI_SHORT while ( timer < MAX_TIME_SHORT &&(PIND & 0x80)==0x80) {asm("\NOP;NOP;NOP;NOP;NOP");timer++; };
/*********** prototypes *************/
static void Init(void);
static void Update(void);
static unsigned char Probe(void);
static void doWork(void){};
    285e:	08 95       	ret

00002860 <Init>:
static unsigned char sendPayload(unsigned char command);
static unsigned char read( unsigned char shortRead);
 
void Init(void)
{
	_rumble=0;
    2860:	10 92 8a 03 	sts	0x038A, r1
	DDRD &= ~0x80;// in
    2864:	57 98       	cbi	0x0a, 7	; 10
	PORTD |= 0x80;// keep low as we use an external pull up
    2866:	5f 9a       	sbi	0x0b, 7	; 11
    2868:	08 95       	ret

0000286a <CleanUp>:
}

void CleanUp(void)
{
    286a:	08 95       	ret

0000286c <read>:
	if (_rumble) RumbleSmallMotor=0xff; else RumbleSmallMotor=0;	
}

unsigned char read( unsigned char shortRead )
{
DDRD |= 0x10;//prevents TG16 from getting picked up
    286c:	54 9a       	sbi	0x0a, 4	; 10

	unsigned char data =0;
	char i=0;
	DDRD &= ~0x80;// in
    286e:	57 98       	cbi	0x0a, 7	; 10
	PORTD |= 0x00;
    2870:	9b b1       	in	r25, 0x0b	; 11
    2872:	9b b9       	out	0x0b, r25	; 11
	long timer = 1;	
	if (shortRead) {WHILE_LINE_IS_HI_SHORT}
    2874:	81 11       	cpse	r24, r1
    2876:	05 c0       	rjmp	.+10     	; 0x2882 <read+0x16>
    2878:	81 e0       	ldi	r24, 0x01	; 1
    287a:	90 e0       	ldi	r25, 0x00	; 0
    287c:	a0 e0       	ldi	r26, 0x00	; 0
    287e:	b0 e0       	ldi	r27, 0x00	; 0
    2880:	1c c0       	rjmp	.+56     	; 0x28ba <read+0x4e>
    2882:	81 e0       	ldi	r24, 0x01	; 1
    2884:	90 e0       	ldi	r25, 0x00	; 0
    2886:	a0 e0       	ldi	r26, 0x00	; 0
    2888:	b0 e0       	ldi	r27, 0x00	; 0
    288a:	4f 9b       	sbis	0x09, 7	; 9
    288c:	1f c0       	rjmp	.+62     	; 0x28cc <read+0x60>
    288e:	00 00       	nop
    2890:	01 96       	adiw	r24, 0x01	; 1
    2892:	a1 1d       	adc	r26, r1
    2894:	b1 1d       	adc	r27, r1
    2896:	88 3e       	cpi	r24, 0xE8	; 232
    2898:	23 e0       	ldi	r18, 0x03	; 3
    289a:	92 07       	cpc	r25, r18
    289c:	a1 05       	cpc	r26, r1
    289e:	b1 05       	cpc	r27, r1
    28a0:	a1 f7       	brne	.-24     	; 0x288a <read+0x1e>
    28a2:	12 c0       	rjmp	.+36     	; 0x28c8 <read+0x5c>
	else	{WHILE_LINE_IS_HI_LONG }//found start of data.
    28a4:	00 00       	nop
    28a6:	01 96       	adiw	r24, 0x01	; 1
    28a8:	a1 1d       	adc	r26, r1
    28aa:	b1 1d       	adc	r27, r1
    28ac:	81 15       	cp	r24, r1
    28ae:	23 e5       	ldi	r18, 0x53	; 83
    28b0:	92 07       	cpc	r25, r18
    28b2:	27 e0       	ldi	r18, 0x07	; 7
    28b4:	a2 07       	cpc	r26, r18
    28b6:	b1 05       	cpc	r27, r1
    28b8:	39 f0       	breq	.+14     	; 0x28c8 <read+0x5c>
    28ba:	4f 99       	sbic	0x09, 7	; 9
    28bc:	f3 cf       	rjmp	.-26     	; 0x28a4 <read+0x38>
	 	
	if (timer == MAX_TIME) return 0xff;
	if (timer == MAX_TIME_SHORT) return 0xff;
    28be:	88 3e       	cpi	r24, 0xE8	; 232
    28c0:	93 40       	sbci	r25, 0x03	; 3
    28c2:	a1 05       	cpc	r26, r1
    28c4:	b1 05       	cpc	r27, r1
    28c6:	11 f4       	brne	.+4      	; 0x28cc <read+0x60>
    28c8:	8f ef       	ldi	r24, 0xFF	; 255
    28ca:	08 95       	ret
	unsigned char data =0;
	char i=0;
	DDRD &= ~0x80;// in
	PORTD |= 0x00;
	long timer = 1;	
	if (shortRead) {WHILE_LINE_IS_HI_SHORT}
    28cc:	98 e0       	ldi	r25, 0x08	; 8
    28ce:	80 e0       	ldi	r24, 0x00	; 0
	if (timer == MAX_TIME) return 0xff;
	if (timer == MAX_TIME_SHORT) return 0xff;
	
	for (;i<8;i++)
	{   
		data <<=1;
    28d0:	88 0f       	add	r24, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    28d2:	2b e0       	ldi	r18, 0x0B	; 11
    28d4:	2a 95       	dec	r18
    28d6:	f1 f7       	brne	.-4      	; 0x28d4 <read+0x68>
    28d8:	00 00       	nop
		_delay_us(2.1); 
		if (PIND & 0x80) data  |= 1;
    28da:	4f 99       	sbic	0x09, 7	; 9
    28dc:	81 60       	ori	r24, 0x01	; 1
    28de:	2c e0       	ldi	r18, 0x0C	; 12
    28e0:	2a 95       	dec	r18
    28e2:	f1 f7       	brne	.-4      	; 0x28e0 <read+0x74>
    28e4:	00 00       	nop
    28e6:	91 50       	subi	r25, 0x01	; 1
	else	{WHILE_LINE_IS_HI_LONG }//found start of data.
	 	
	if (timer == MAX_TIME) return 0xff;
	if (timer == MAX_TIME_SHORT) return 0xff;
	
	for (;i<8;i++)
    28e8:	99 f7       	brne	.-26     	; 0x28d0 <read+0x64>
		if (PIND & 0x80) data  |= 1;
		
		_delay_us(2.3);//could try just doing this here  -> WHILE_LINE_IS_HI
	}

	if ( data == 0x40 )
    28ea:	80 34       	cpi	r24, 0x40	; 64
    28ec:	61 f4       	brne	.+24     	; 0x2906 <read+0x9a>
    28ee:	8f e2       	ldi	r24, 0x2F	; 47
    28f0:	91 e0       	ldi	r25, 0x01	; 1
    28f2:	01 97       	sbiw	r24, 0x01	; 1
    28f4:	f1 f7       	brne	.-4      	; 0x28f2 <read+0x86>
    28f6:	00 c0       	rjmp	.+0      	; 0x28f8 <read+0x8c>
    28f8:	00 00       	nop
	{
		_delay_us(76);//sync to and check.
		_rumble = (PIND & 0x80);
    28fa:	89 b1       	in	r24, 0x09	; 9
    28fc:	80 78       	andi	r24, 0x80	; 128
    28fe:	80 93 8a 03 	sts	0x038A, r24
    2902:	80 e4       	ldi	r24, 0x40	; 64
    2904:	08 95       	ret
  // 1    ~~~
  // stop ~~_
  //I think we best just know the bytes

	return data;
}
    2906:	08 95       	ret

00002908 <probeReply>:
    2908:	3a e0       	ldi	r19, 0x0A	; 10
    290a:	3a 95       	dec	r19
    290c:	f1 f7       	brne	.-4      	; 0x290a <probeReply+0x2>
    290e:	00 c0       	rjmp	.+0      	; 0x2910 <probeReply+0x8>
{


	long buffer = 0x09000300;//normal reply to a 0 command. - last byte is padding. it really is only 0x090003
	_delay_us(2);//2.4 is the normal reply time. 
	DDRD |= 0x80;//out
    2910:	57 9a       	sbi	0x0a, 7	; 10
	PORTD &= ~0x80;//go low	
    2912:	5f 98       	cbi	0x0b, 7	; 11
    2914:	28 e1       	ldi	r18, 0x18	; 24

unsigned char probeReply()
{


	long buffer = 0x09000300;//normal reply to a 0 command. - last byte is padding. it really is only 0x090003
    2916:	80 e0       	ldi	r24, 0x00	; 0
    2918:	93 e0       	ldi	r25, 0x03	; 3
    291a:	a0 e0       	ldi	r26, 0x00	; 0
    291c:	b9 e0       	ldi	r27, 0x09	; 9
	_delay_us(2);//2.4 is the normal reply time. 
	DDRD |= 0x80;//out
	PORTD &= ~0x80;//go low	
	for (char count=0;count<24;count++)
	{
		if (buffer & 0x80000000) { _delay_us(1); PORTD |= 0x80;   _delay_us(4); }
    291e:	b7 ff       	sbrs	r27, 7
    2920:	09 c0       	rjmp	.+18     	; 0x2934 <probeReply+0x2c>
    2922:	35 e0       	ldi	r19, 0x05	; 5
    2924:	3a 95       	dec	r19
    2926:	f1 f7       	brne	.-4      	; 0x2924 <probeReply+0x1c>
    2928:	00 00       	nop
    292a:	5f 9a       	sbi	0x0b, 7	; 11
    292c:	35 e1       	ldi	r19, 0x15	; 21
    292e:	3a 95       	dec	r19
    2930:	f1 f7       	brne	.-4      	; 0x292e <probeReply+0x26>
    2932:	08 c0       	rjmp	.+16     	; 0x2944 <probeReply+0x3c>
    2934:	35 e1       	ldi	r19, 0x15	; 21
    2936:	3a 95       	dec	r19
    2938:	f1 f7       	brne	.-4      	; 0x2936 <probeReply+0x2e>
    293a:	00 00       	nop
		else    { _delay_us(4); PORTD |= 0x80;   _delay_us(1); }
    293c:	5f 9a       	sbi	0x0b, 7	; 11
    293e:	35 e0       	ldi	r19, 0x05	; 5
    2940:	3a 95       	dec	r19
    2942:	f1 f7       	brne	.-4      	; 0x2940 <probeReply+0x38>
    2944:	00 00       	nop
		PORTD &= ~0x80;//go low	
    2946:	5f 98       	cbi	0x0b, 7	; 11
		buffer <<= 1;
    2948:	88 0f       	add	r24, r24
    294a:	99 1f       	adc	r25, r25
    294c:	aa 1f       	adc	r26, r26
    294e:	bb 1f       	adc	r27, r27
    2950:	21 50       	subi	r18, 0x01	; 1

	long buffer = 0x09000300;//normal reply to a 0 command. - last byte is padding. it really is only 0x090003
	_delay_us(2);//2.4 is the normal reply time. 
	DDRD |= 0x80;//out
	PORTD &= ~0x80;//go low	
	for (char count=0;count<24;count++)
    2952:	29 f7       	brne	.-54     	; 0x291e <probeReply+0x16>
    2954:	8a e0       	ldi	r24, 0x0A	; 10
    2956:	8a 95       	dec	r24
    2958:	f1 f7       	brne	.-4      	; 0x2956 <probeReply+0x4e>
    295a:	00 c0       	rjmp	.+0      	; 0x295c <probeReply+0x54>
		else    { _delay_us(4); PORTD |= 0x80;   _delay_us(1); }
		PORTD &= ~0x80;//go low	
		buffer <<= 1;
	}
	_delay_us(2);//2 us end bit
	DDRD &= ~0x80;//in
    295c:	57 98       	cbi	0x0a, 7	; 10
	PORTD |= 0x80;//go hi	
    295e:	5f 9a       	sbi	0x0b, 7	; 11

	return read(1);
    2960:	81 e0       	ldi	r24, 0x01	; 1
    2962:	84 cf       	rjmp	.-248    	; 0x286c <read>

00002964 <Update>:
    2964:	2f 92       	push	r2
	return 1;
}


void Update(void)
{
    2966:	3f 92       	push	r3
    2968:	4f 92       	push	r4
    296a:	5f 92       	push	r5
    296c:	6f 92       	push	r6
    296e:	7f 92       	push	r7
    2970:	8f 92       	push	r8
    2972:	9f 92       	push	r9
    2974:	af 92       	push	r10
    2976:	bf 92       	push	r11
    2978:	cf 92       	push	r12
    297a:	df 92       	push	r13
    297c:	ef 92       	push	r14
    297e:	ff 92       	push	r15
    2980:	0f 93       	push	r16
    2982:	1f 93       	push	r17
    2984:	cf 93       	push	r28
    2986:	df 93       	push	r29
    2988:	cd b7       	in	r28, 0x3d	; 61
    298a:	de b7       	in	r29, 0x3e	; 62
    298c:	65 97       	sbiw	r28, 0x15	; 21
    298e:	0f b6       	in	r0, 0x3f	; 63
    2990:	f8 94       	cli
    2992:	de bf       	out	0x3e, r29	; 62
    2994:	0f be       	out	0x3f, r0	; 63
    2996:	cd bf       	out	0x3d, r28	; 61
	//pin 2 prevents communication or simple fails detection, I tried bring it out and low here but still didnt work.
	
	char count=0;
	char size=0;
	_rumble=0;
    2998:	10 92 8a 03 	sts	0x038A, r1

	unsigned char command = 0xff;
	command = read(0);
    299c:	80 e0       	ldi	r24, 0x00	; 0
    299e:	66 df       	rcall	.-308    	; 0x286c <read>
    29a0:	8d 8b       	std	Y+21, r24	; 0x15
    29a2:	81 11       	cpse	r24, r1
	if ( command == 0) command = probeReply();
    29a4:	02 c0       	rjmp	.+4      	; 0x29aa <Update+0x46>
    29a6:	b0 df       	rcall	.-160    	; 0x2908 <probeReply>
    29a8:	8d 8b       	std	Y+21, r24	; 0x15
    29aa:	41 2c       	mov	r4, r1
    29ac:	51 2c       	mov	r5, r1
	if (reportBuffer[HAT] == DPAD_UP	   )GC_OUT_BUFFER2 |=    0x80000;
	if (reportBuffer[HAT] == DPAD_DOWN	   )GC_OUT_BUFFER2 |=    0x40000;
	if (reportBuffer[HAT] == DPAD_DOWNLEFT )GC_OUT_BUFFER2 |=    0x50000;
	if (reportBuffer[HAT] == DPAD_UPLEFT   )GC_OUT_BUFFER2 |=    0x90000;
	if (reportBuffer[HAT] == DPAD_UPRIGHT  )GC_OUT_BUFFER2 |=    0xA0000;
	if (reportBuffer[HAT] == DPAD_DOWNRIGHT)GC_OUT_BUFFER2 |=    0x60000;
    29ae:	32 01       	movw	r6, r4
    29b0:	d3 01       	movw	r26, r6
    29b2:	c2 01       	movw	r24, r4
    29b4:	a6 60       	ori	r26, 0x06	; 6
    29b6:	89 83       	std	Y+1, r24	; 0x01
    29b8:	9a 83       	std	Y+2, r25	; 0x02
    29ba:	ab 83       	std	Y+3, r26	; 0x03
    29bc:	bc 83       	std	Y+4, r27	; 0x04
    29be:	d3 01       	movw	r26, r6
    29c0:	c2 01       	movw	r24, r4
	if (reportBuffer[HAT] == DPAD_RIGHT	   )GC_OUT_BUFFER2 |=    0x20000;
	if (reportBuffer[HAT] == DPAD_UP	   )GC_OUT_BUFFER2 |=    0x80000;
	if (reportBuffer[HAT] == DPAD_DOWN	   )GC_OUT_BUFFER2 |=    0x40000;
	if (reportBuffer[HAT] == DPAD_DOWNLEFT )GC_OUT_BUFFER2 |=    0x50000;
	if (reportBuffer[HAT] == DPAD_UPLEFT   )GC_OUT_BUFFER2 |=    0x90000;
	if (reportBuffer[HAT] == DPAD_UPRIGHT  )GC_OUT_BUFFER2 |=    0xA0000;
    29c2:	aa 60       	ori	r26, 0x0A	; 10
    29c4:	8d 83       	std	Y+5, r24	; 0x05
    29c6:	9e 83       	std	Y+6, r25	; 0x06
    29c8:	af 83       	std	Y+7, r26	; 0x07
    29ca:	b8 87       	std	Y+8, r27	; 0x08
    29cc:	d3 01       	movw	r26, r6
    29ce:	c2 01       	movw	r24, r4
	if (reportBuffer[HAT] == DPAD_LEFT	   )GC_OUT_BUFFER2 |=    0x10000;
	if (reportBuffer[HAT] == DPAD_RIGHT	   )GC_OUT_BUFFER2 |=    0x20000;
	if (reportBuffer[HAT] == DPAD_UP	   )GC_OUT_BUFFER2 |=    0x80000;
	if (reportBuffer[HAT] == DPAD_DOWN	   )GC_OUT_BUFFER2 |=    0x40000;
	if (reportBuffer[HAT] == DPAD_DOWNLEFT )GC_OUT_BUFFER2 |=    0x50000;
	if (reportBuffer[HAT] == DPAD_UPLEFT   )GC_OUT_BUFFER2 |=    0x90000;
    29d0:	a9 60       	ori	r26, 0x09	; 9
    29d2:	89 87       	std	Y+9, r24	; 0x09
    29d4:	9a 87       	std	Y+10, r25	; 0x0a
    29d6:	ab 87       	std	Y+11, r26	; 0x0b
    29d8:	bc 87       	std	Y+12, r27	; 0x0c
    29da:	d3 01       	movw	r26, r6
    29dc:	c2 01       	movw	r24, r4

	if (reportBuffer[HAT] == DPAD_LEFT	   )GC_OUT_BUFFER2 |=    0x10000;
	if (reportBuffer[HAT] == DPAD_RIGHT	   )GC_OUT_BUFFER2 |=    0x20000;
	if (reportBuffer[HAT] == DPAD_UP	   )GC_OUT_BUFFER2 |=    0x80000;
	if (reportBuffer[HAT] == DPAD_DOWN	   )GC_OUT_BUFFER2 |=    0x40000;
	if (reportBuffer[HAT] == DPAD_DOWNLEFT )GC_OUT_BUFFER2 |=    0x50000;
    29de:	a5 60       	ori	r26, 0x05	; 5
    29e0:	8d 87       	std	Y+13, r24	; 0x0d
    29e2:	9e 87       	std	Y+14, r25	; 0x0e
    29e4:	af 87       	std	Y+15, r26	; 0x0f
    29e6:	b8 8b       	std	Y+16, r27	; 0x10
    29e8:	d3 01       	movw	r26, r6
    29ea:	c2 01       	movw	r24, r4
	long GC_OUT_BUFFER3;

	if (reportBuffer[HAT] == DPAD_LEFT	   )GC_OUT_BUFFER2 |=    0x10000;
	if (reportBuffer[HAT] == DPAD_RIGHT	   )GC_OUT_BUFFER2 |=    0x20000;
	if (reportBuffer[HAT] == DPAD_UP	   )GC_OUT_BUFFER2 |=    0x80000;
	if (reportBuffer[HAT] == DPAD_DOWN	   )GC_OUT_BUFFER2 |=    0x40000;
    29ec:	a4 60       	ori	r26, 0x04	; 4
    29ee:	89 8b       	std	Y+17, r24	; 0x11
    29f0:	9a 8b       	std	Y+18, r25	; 0x12
    29f2:	ab 8b       	std	Y+19, r26	; 0x13
    29f4:	bc 8b       	std	Y+20, r27	; 0x14
    29f6:	73 01       	movw	r14, r6
    29f8:	62 01       	movw	r12, r4
	long GC_OUT_BUFFER2;
	long GC_OUT_BUFFER3;

	if (reportBuffer[HAT] == DPAD_LEFT	   )GC_OUT_BUFFER2 |=    0x10000;
	if (reportBuffer[HAT] == DPAD_RIGHT	   )GC_OUT_BUFFER2 |=    0x20000;
	if (reportBuffer[HAT] == DPAD_UP	   )GC_OUT_BUFFER2 |=    0x80000;
    29fa:	68 94       	set
    29fc:	e3 f8       	bld	r14, 3
    29fe:	53 01       	movw	r10, r6
    2a00:	42 01       	movw	r8, r4

	long GC_OUT_BUFFER2;
	long GC_OUT_BUFFER3;

	if (reportBuffer[HAT] == DPAD_LEFT	   )GC_OUT_BUFFER2 |=    0x10000;
	if (reportBuffer[HAT] == DPAD_RIGHT	   )GC_OUT_BUFFER2 |=    0x20000;
    2a02:	68 94       	set
    2a04:	a1 f8       	bld	r10, 1
    2a06:	68 94       	set
    2a08:	60 f8       	bld	r6, 0
	_delay_us(3); //wait before sending data. 

	long GC_OUT_BUFFER2;
	long GC_OUT_BUFFER3;

	if (reportBuffer[HAT] == DPAD_LEFT	   )GC_OUT_BUFFER2 |=    0x10000;
    2a0a:	22 24       	eor	r2, r2
    2a0c:	2a 94       	dec	r2
	if (reportBuffer[BUTTON_ROW_1] & 0x01)  GC_OUT_BUFFER2 |=  0x2000000;	//b
	if (reportBuffer[BUTTON_ROW_1] & 0x08)  GC_OUT_BUFFER2 |=  0x4000000;	//y
	if (reportBuffer[BUTTON_ROW_1] & 0x04)  GC_OUT_BUFFER2 |=  0x8000000;	//x
	if (reportBuffer[BUTTON_ROW_1] & 0x20)  GC_OUT_BUFFER2 |= 0x10000000;//start
	
	long shifter = 255-reportBuffer[Y_MAIN_STICK];  GC_OUT_BUFFER2 |= shifter;
    2a0e:	31 2c       	mov	r3, r1
    2a10:	9d 89       	ldd	r25, Y+21	; 0x15
    2a12:	9f 3f       	cpi	r25, 0xFF	; 255
	unsigned char command = 0xff;
	command = read(0);
	if ( command == 0) command = probeReply();
	
	unsigned char readAgain=1;
	while (command != 0xff) //0xff means a reset, or rimeout, either way these are exit conditions. 
    2a14:	09 f4       	brne	.+2      	; 0x2a18 <Update+0xb4>
    2a16:	d8 c0       	rjmp	.+432    	; 0x2bc8 <Update+0x264>
    2a18:	9d 89       	ldd	r25, Y+21	; 0x15
    2a1a:	91 11       	cpse	r25, r1
	{
		if ( command == 0) command = probeReply();//if its a 0x00 This also does a read, so we need to send payload next. 
    2a1c:	02 c0       	rjmp	.+4      	; 0x2a22 <Update+0xbe>
    2a1e:	74 df       	rcall	.-280    	; 0x2908 <probeReply>
    2a20:	8d 8b       	std	Y+21, r24	; 0x15
    2a22:	a0 e1       	ldi	r26, 0x10	; 16
    2a24:	aa 95       	dec	r26
    2a26:	f1 f7       	brne	.-4      	; 0x2a24 <Update+0xc0>
    2a28:	80 91 6a 03 	lds	r24, 0x036A
    2a2c:	86 30       	cpi	r24, 0x06	; 6
	_delay_us(3); //wait before sending data. 

	long GC_OUT_BUFFER2;
	long GC_OUT_BUFFER3;

	if (reportBuffer[HAT] == DPAD_LEFT	   )GC_OUT_BUFFER2 |=    0x10000;
    2a2e:	19 f4       	brne	.+6      	; 0x2a36 <Update+0xd2>
    2a30:	b3 01       	movw	r22, r6
    2a32:	a2 01       	movw	r20, r4
    2a34:	2f c0       	rjmp	.+94     	; 0x2a94 <Update+0x130>
    2a36:	82 30       	cpi	r24, 0x02	; 2
    2a38:	19 f4       	brne	.+6      	; 0x2a40 <Update+0xdc>
    2a3a:	b5 01       	movw	r22, r10
	if (reportBuffer[HAT] == DPAD_RIGHT	   )GC_OUT_BUFFER2 |=    0x20000;
    2a3c:	a4 01       	movw	r20, r8
    2a3e:	2a c0       	rjmp	.+84     	; 0x2a94 <Update+0x130>
    2a40:	81 11       	cpse	r24, r1
    2a42:	03 c0       	rjmp	.+6      	; 0x2a4a <Update+0xe6>
    2a44:	b7 01       	movw	r22, r14
	if (reportBuffer[HAT] == DPAD_UP	   )GC_OUT_BUFFER2 |=    0x80000;
    2a46:	a6 01       	movw	r20, r12
    2a48:	25 c0       	rjmp	.+74     	; 0x2a94 <Update+0x130>
    2a4a:	84 30       	cpi	r24, 0x04	; 4
    2a4c:	29 f4       	brne	.+10     	; 0x2a58 <Update+0xf4>
    2a4e:	49 89       	ldd	r20, Y+17	; 0x11
	if (reportBuffer[HAT] == DPAD_DOWN	   )GC_OUT_BUFFER2 |=    0x40000;
    2a50:	5a 89       	ldd	r21, Y+18	; 0x12
    2a52:	6b 89       	ldd	r22, Y+19	; 0x13
    2a54:	7c 89       	ldd	r23, Y+20	; 0x14
    2a56:	1e c0       	rjmp	.+60     	; 0x2a94 <Update+0x130>
    2a58:	85 30       	cpi	r24, 0x05	; 5
    2a5a:	29 f4       	brne	.+10     	; 0x2a66 <Update+0x102>
    2a5c:	4d 85       	ldd	r20, Y+13	; 0x0d
	if (reportBuffer[HAT] == DPAD_DOWNLEFT )GC_OUT_BUFFER2 |=    0x50000;
    2a5e:	5e 85       	ldd	r21, Y+14	; 0x0e
    2a60:	6f 85       	ldd	r22, Y+15	; 0x0f
    2a62:	78 89       	ldd	r23, Y+16	; 0x10
    2a64:	17 c0       	rjmp	.+46     	; 0x2a94 <Update+0x130>
    2a66:	40 e0       	ldi	r20, 0x00	; 0
    2a68:	50 e0       	ldi	r21, 0x00	; 0
    2a6a:	ba 01       	movw	r22, r20
    2a6c:	87 30       	cpi	r24, 0x07	; 7
    2a6e:	29 f4       	brne	.+10     	; 0x2a7a <Update+0x116>
    2a70:	49 85       	ldd	r20, Y+9	; 0x09
	if (reportBuffer[HAT] == DPAD_UPLEFT   )GC_OUT_BUFFER2 |=    0x90000;
    2a72:	5a 85       	ldd	r21, Y+10	; 0x0a
    2a74:	6b 85       	ldd	r22, Y+11	; 0x0b
    2a76:	7c 85       	ldd	r23, Y+12	; 0x0c
    2a78:	0d c0       	rjmp	.+26     	; 0x2a94 <Update+0x130>
    2a7a:	81 30       	cpi	r24, 0x01	; 1
    2a7c:	29 f4       	brne	.+10     	; 0x2a88 <Update+0x124>
    2a7e:	4d 81       	ldd	r20, Y+5	; 0x05
	if (reportBuffer[HAT] == DPAD_UPRIGHT  )GC_OUT_BUFFER2 |=    0xA0000;
    2a80:	5e 81       	ldd	r21, Y+6	; 0x06
    2a82:	6f 81       	ldd	r22, Y+7	; 0x07
    2a84:	78 85       	ldd	r23, Y+8	; 0x08
    2a86:	06 c0       	rjmp	.+12     	; 0x2a94 <Update+0x130>
    2a88:	83 30       	cpi	r24, 0x03	; 3
    2a8a:	21 f4       	brne	.+8      	; 0x2a94 <Update+0x130>
    2a8c:	49 81       	ldd	r20, Y+1	; 0x01
	if (reportBuffer[HAT] == DPAD_DOWNRIGHT)GC_OUT_BUFFER2 |=    0x60000;
    2a8e:	5a 81       	ldd	r21, Y+2	; 0x02
    2a90:	6b 81       	ldd	r22, Y+3	; 0x03
    2a92:	7c 81       	ldd	r23, Y+4	; 0x04
    2a94:	80 91 68 03 	lds	r24, 0x0368
    2a98:	84 fd       	sbrc	r24, 4
	if (reportBuffer[BUTTON_ROW_1] & 0x10)  GC_OUT_BUFFER2 |=   0x100000;	//select
    2a9a:	60 61       	ori	r22, 0x10	; 16
    2a9c:	87 fd       	sbrc	r24, 7
    2a9e:	60 62       	ori	r22, 0x20	; 32
    2aa0:	86 fd       	sbrc	r24, 6
	if (reportBuffer[BUTTON_ROW_1] & 0x80)  GC_OUT_BUFFER2 |=   0x200000;	//r
    2aa2:	60 64       	ori	r22, 0x40	; 64
    2aa4:	81 fd       	sbrc	r24, 1
	if (reportBuffer[BUTTON_ROW_1] & 0x40)  GC_OUT_BUFFER2 |=   0x400000;	//l	
    2aa6:	02 c0       	rjmp	.+4      	; 0x2aac <Update+0x148>
    2aa8:	60 68       	ori	r22, 0x80	; 128
											GC_OUT_BUFFER2 |=   0x800000;//static
	if (reportBuffer[BUTTON_ROW_1] & 0x02)  GC_OUT_BUFFER2 |=  0x1000000;	//a
    2aaa:	02 c0       	rjmp	.+4      	; 0x2ab0 <Update+0x14c>
    2aac:	60 68       	ori	r22, 0x80	; 128
	if (reportBuffer[HAT] == DPAD_UPRIGHT  )GC_OUT_BUFFER2 |=    0xA0000;
	if (reportBuffer[HAT] == DPAD_DOWNRIGHT)GC_OUT_BUFFER2 |=    0x60000;
	if (reportBuffer[BUTTON_ROW_1] & 0x10)  GC_OUT_BUFFER2 |=   0x100000;	//select
	if (reportBuffer[BUTTON_ROW_1] & 0x80)  GC_OUT_BUFFER2 |=   0x200000;	//r
	if (reportBuffer[BUTTON_ROW_1] & 0x40)  GC_OUT_BUFFER2 |=   0x400000;	//l	
											GC_OUT_BUFFER2 |=   0x800000;//static
    2aae:	71 60       	ori	r23, 0x01	; 1
    2ab0:	80 fd       	sbrc	r24, 0
	if (reportBuffer[BUTTON_ROW_1] & 0x02)  GC_OUT_BUFFER2 |=  0x1000000;	//a
    2ab2:	72 60       	ori	r23, 0x02	; 2
    2ab4:	83 fd       	sbrc	r24, 3
	if (reportBuffer[BUTTON_ROW_1] & 0x01)  GC_OUT_BUFFER2 |=  0x2000000;	//b
    2ab6:	74 60       	ori	r23, 0x04	; 4
    2ab8:	82 fd       	sbrc	r24, 2
	if (reportBuffer[BUTTON_ROW_1] & 0x08)  GC_OUT_BUFFER2 |=  0x4000000;	//y
    2aba:	78 60       	ori	r23, 0x08	; 8
    2abc:	85 fd       	sbrc	r24, 5
	if (reportBuffer[BUTTON_ROW_1] & 0x04)  GC_OUT_BUFFER2 |=  0x8000000;	//x
    2abe:	70 61       	ori	r23, 0x10	; 16
    2ac0:	80 91 6b 03 	lds	r24, 0x036B
	if (reportBuffer[BUTTON_ROW_1] & 0x20)  GC_OUT_BUFFER2 |= 0x10000000;//start
    2ac4:	90 91 6c 03 	lds	r25, 0x036C
	
	long shifter = 255-reportBuffer[Y_MAIN_STICK];  GC_OUT_BUFFER2 |= shifter;
	shifter =  reportBuffer[X_MAIN_STICK];shifter <<= 8;  GC_OUT_BUFFER2 |= shifter;
    2ac8:	81 01       	movw	r16, r2
	if (reportBuffer[BUTTON_ROW_1] & 0x01)  GC_OUT_BUFFER2 |=  0x2000000;	//b
	if (reportBuffer[BUTTON_ROW_1] & 0x08)  GC_OUT_BUFFER2 |=  0x4000000;	//y
	if (reportBuffer[BUTTON_ROW_1] & 0x04)  GC_OUT_BUFFER2 |=  0x8000000;	//x
	if (reportBuffer[BUTTON_ROW_1] & 0x20)  GC_OUT_BUFFER2 |= 0x10000000;//start
	
	long shifter = 255-reportBuffer[Y_MAIN_STICK];  GC_OUT_BUFFER2 |= shifter;
    2aca:	09 1b       	sub	r16, r25
    2acc:	11 09       	sbc	r17, r1
    2ace:	22 27       	eor	r18, r18
    2ad0:	17 fd       	sbrc	r17, 7
    2ad2:	20 95       	com	r18
    2ad4:	32 2f       	mov	r19, r18
    2ad6:	18 2b       	or	r17, r24
    2ad8:	04 2b       	or	r16, r20
    2ada:	15 2b       	or	r17, r21
    2adc:	26 2b       	or	r18, r22
	shifter =  reportBuffer[X_MAIN_STICK];shifter <<= 8;  GC_OUT_BUFFER2 |= shifter;
    2ade:	37 2b       	or	r19, r23
    2ae0:	40 91 6d 03 	lds	r20, 0x036D
    2ae4:	50 e0       	ldi	r21, 0x00	; 0
	shifter =  reportBuffer[X_SECONDARY_STICK];shifter <<= 24;  GC_OUT_BUFFER3 |= shifter;
    2ae6:	60 e0       	ldi	r22, 0x00	; 0
    2ae8:	70 e0       	ldi	r23, 0x00	; 0
    2aea:	80 91 6e 03 	lds	r24, 0x036E
    2aee:	f1 01       	movw	r30, r2
	shifter =  255-reportBuffer[Y_SECONDARY_STICK];shifter <<= 16;  GC_OUT_BUFFER3 |= shifter;
    2af0:	e8 1b       	sub	r30, r24
    2af2:	f1 09       	sbc	r31, r1
    2af4:	cf 01       	movw	r24, r30
    2af6:	aa 27       	eor	r26, r26
    2af8:	97 fd       	sbrc	r25, 7
    2afa:	a0 95       	com	r26
    2afc:	ba 2f       	mov	r27, r26
    2afe:	f0 91 3f 03 	lds	r31, 0x033F
    2b02:	74 2f       	mov	r23, r20
	shifter = pressureData[l2__pressure]; shifter <<=8; GC_OUT_BUFFER3 |= shifter;
    2b04:	66 27       	eor	r22, r22
    2b06:	55 27       	eor	r21, r21
	if (reportBuffer[BUTTON_ROW_1] & 0x04)  GC_OUT_BUFFER2 |=  0x8000000;	//x
	if (reportBuffer[BUTTON_ROW_1] & 0x20)  GC_OUT_BUFFER2 |= 0x10000000;//start
	
	long shifter = 255-reportBuffer[Y_MAIN_STICK];  GC_OUT_BUFFER2 |= shifter;
	shifter =  reportBuffer[X_MAIN_STICK];shifter <<= 8;  GC_OUT_BUFFER2 |= shifter;
	shifter =  reportBuffer[X_SECONDARY_STICK];shifter <<= 24;  GC_OUT_BUFFER3 |= shifter;
    2b08:	44 27       	eor	r20, r20
    2b0a:	e0 91 40 03 	lds	r30, 0x0340
    2b0e:	4e 2b       	or	r20, r30
	shifter =  255-reportBuffer[Y_SECONDARY_STICK];shifter <<= 16;  GC_OUT_BUFFER3 |= shifter;
	shifter = pressureData[l2__pressure]; shifter <<=8; GC_OUT_BUFFER3 |= shifter;
	GC_OUT_BUFFER3 |= pressureData[r2__pressure];
    2b10:	5f 2b       	or	r21, r31
    2b12:	dc 01       	movw	r26, r24
	if (reportBuffer[BUTTON_ROW_1] & 0x20)  GC_OUT_BUFFER2 |= 0x10000000;//start
	
	long shifter = 255-reportBuffer[Y_MAIN_STICK];  GC_OUT_BUFFER2 |= shifter;
	shifter =  reportBuffer[X_MAIN_STICK];shifter <<= 8;  GC_OUT_BUFFER2 |= shifter;
	shifter =  reportBuffer[X_SECONDARY_STICK];shifter <<= 24;  GC_OUT_BUFFER3 |= shifter;
	shifter =  255-reportBuffer[Y_SECONDARY_STICK];shifter <<= 16;  GC_OUT_BUFFER3 |= shifter;
    2b14:	99 27       	eor	r25, r25
	shifter = pressureData[l2__pressure]; shifter <<=8; GC_OUT_BUFFER3 |= shifter;
    2b16:	88 27       	eor	r24, r24
	if (reportBuffer[BUTTON_ROW_1] & 0x20)  GC_OUT_BUFFER2 |= 0x10000000;//start
	
	long shifter = 255-reportBuffer[Y_MAIN_STICK];  GC_OUT_BUFFER2 |= shifter;
	shifter =  reportBuffer[X_MAIN_STICK];shifter <<= 8;  GC_OUT_BUFFER2 |= shifter;
	shifter =  reportBuffer[X_SECONDARY_STICK];shifter <<= 24;  GC_OUT_BUFFER3 |= shifter;
	shifter =  255-reportBuffer[Y_SECONDARY_STICK];shifter <<= 16;  GC_OUT_BUFFER3 |= shifter;
    2b18:	48 2b       	or	r20, r24
    2b1a:	59 2b       	or	r21, r25
    2b1c:	6a 2b       	or	r22, r26
	shifter = pressureData[l2__pressure]; shifter <<=8; GC_OUT_BUFFER3 |= shifter;
	GC_OUT_BUFFER3 |= pressureData[r2__pressure];
    2b1e:	7b 2b       	or	r23, r27
    2b20:	57 9a       	sbi	0x0a, 7	; 10
    2b22:	5f 98       	cbi	0x0b, 7	; 11
    2b24:	80 e2       	ldi	r24, 0x20	; 32
	
	char count=0;

	DDRD |= 0x80;//out
    2b26:	37 ff       	sbrs	r19, 7
	PORTD &= ~0x80;//go low	
    2b28:	09 c0       	rjmp	.+18     	; 0x2b3c <Update+0x1d8>
    2b2a:	f5 e0       	ldi	r31, 0x05	; 5

	for (;count<32;count++)
	{
		if (GC_OUT_BUFFER2 & 0x80000000) { _delay_us(1); PORTD |= 0x80;   _delay_us(4); }
    2b2c:	fa 95       	dec	r31
    2b2e:	f1 f7       	brne	.-4      	; 0x2b2c <Update+0x1c8>
    2b30:	00 00       	nop
    2b32:	5f 9a       	sbi	0x0b, 7	; 11
    2b34:	95 e1       	ldi	r25, 0x15	; 21
    2b36:	9a 95       	dec	r25
    2b38:	f1 f7       	brne	.-4      	; 0x2b36 <Update+0x1d2>
    2b3a:	08 c0       	rjmp	.+16     	; 0x2b4c <Update+0x1e8>
    2b3c:	a5 e1       	ldi	r26, 0x15	; 21
    2b3e:	aa 95       	dec	r26
    2b40:	f1 f7       	brne	.-4      	; 0x2b3e <Update+0x1da>
    2b42:	00 00       	nop
    2b44:	5f 9a       	sbi	0x0b, 7	; 11
    2b46:	b5 e0       	ldi	r27, 0x05	; 5
    2b48:	ba 95       	dec	r27
		else    { _delay_us(4); PORTD |= 0x80;   _delay_us(1); }
    2b4a:	f1 f7       	brne	.-4      	; 0x2b48 <Update+0x1e4>
    2b4c:	00 00       	nop
    2b4e:	5f 98       	cbi	0x0b, 7	; 11
    2b50:	00 0f       	add	r16, r16
    2b52:	11 1f       	adc	r17, r17
		PORTD &= ~0x80;//go low	
    2b54:	22 1f       	adc	r18, r18
		GC_OUT_BUFFER2 <<= 1;
    2b56:	33 1f       	adc	r19, r19
    2b58:	81 50       	subi	r24, 0x01	; 1
    2b5a:	29 f7       	brne	.-54     	; 0x2b26 <Update+0x1c2>
    2b5c:	80 e2       	ldi	r24, 0x20	; 32
    2b5e:	77 ff       	sbrs	r23, 7
	char count=0;

	DDRD |= 0x80;//out
	PORTD &= ~0x80;//go low	

	for (;count<32;count++)
    2b60:	09 c0       	rjmp	.+18     	; 0x2b74 <Update+0x210>
    2b62:	e5 e0       	ldi	r30, 0x05	; 5

	count = 0;

	for (;count<32;count++)
	{
		if (GC_OUT_BUFFER3 & 0x80000000) { _delay_us(1); PORTD |= 0x80;   _delay_us(4); }
    2b64:	ea 95       	dec	r30
    2b66:	f1 f7       	brne	.-4      	; 0x2b64 <Update+0x200>
    2b68:	00 00       	nop
    2b6a:	5f 9a       	sbi	0x0b, 7	; 11
    2b6c:	f5 e1       	ldi	r31, 0x15	; 21
    2b6e:	fa 95       	dec	r31
    2b70:	f1 f7       	brne	.-4      	; 0x2b6e <Update+0x20a>
    2b72:	08 c0       	rjmp	.+16     	; 0x2b84 <Update+0x220>
    2b74:	95 e1       	ldi	r25, 0x15	; 21
    2b76:	9a 95       	dec	r25
    2b78:	f1 f7       	brne	.-4      	; 0x2b76 <Update+0x212>
    2b7a:	00 00       	nop
    2b7c:	5f 9a       	sbi	0x0b, 7	; 11
    2b7e:	a5 e0       	ldi	r26, 0x05	; 5
    2b80:	aa 95       	dec	r26
		else    { _delay_us(4); PORTD |= 0x80;   _delay_us(1); }
    2b82:	f1 f7       	brne	.-4      	; 0x2b80 <Update+0x21c>
    2b84:	00 00       	nop
    2b86:	5f 98       	cbi	0x0b, 7	; 11
    2b88:	44 0f       	add	r20, r20
    2b8a:	55 1f       	adc	r21, r21
		PORTD &= ~0x80;//go low	
    2b8c:	66 1f       	adc	r22, r22
		GC_OUT_BUFFER3 <<= 1;
    2b8e:	77 1f       	adc	r23, r23
    2b90:	81 50       	subi	r24, 0x01	; 1
    2b92:	29 f7       	brne	.-54     	; 0x2b5e <Update+0x1fa>
    2b94:	bd 89       	ldd	r27, Y+21	; 0x15
    2b96:	b1 34       	cpi	r27, 0x41	; 65
		GC_OUT_BUFFER2 <<= 1;
	}

	count = 0;

	for (;count<32;count++)
    2b98:	69 f4       	brne	.+26     	; 0x2bb4 <Update+0x250>
		else    { _delay_us(4); PORTD |= 0x80;   _delay_us(1); }
		PORTD &= ~0x80;//go low	
		GC_OUT_BUFFER3 <<= 1;
	}

	if (command == 0x41)//two null bytes. 
    2b9a:	80 e1       	ldi	r24, 0x10	; 16
    2b9c:	e5 e1       	ldi	r30, 0x15	; 21
    2b9e:	ea 95       	dec	r30
    2ba0:	f1 f7       	brne	.-4      	; 0x2b9e <Update+0x23a>
    2ba2:	00 00       	nop
    2ba4:	5f 9a       	sbi	0x0b, 7	; 11
    2ba6:	f5 e0       	ldi	r31, 0x05	; 5
    2ba8:	fa 95       	dec	r31
	{	
		count=0;
		for (;count<16;count++)
		{
			_delay_us(4); PORTD |= 0x80;   _delay_us(1); 
    2baa:	f1 f7       	brne	.-4      	; 0x2ba8 <Update+0x244>
    2bac:	00 00       	nop
    2bae:	5f 98       	cbi	0x0b, 7	; 11
    2bb0:	81 50       	subi	r24, 0x01	; 1
    2bb2:	a1 f7       	brne	.-24     	; 0x2b9c <Update+0x238>
			PORTD &= ~0x80;//go low	
    2bb4:	85 e0       	ldi	r24, 0x05	; 5
    2bb6:	8a 95       	dec	r24
	}

	if (command == 0x41)//two null bytes. 
	{	
		count=0;
		for (;count<16;count++)
    2bb8:	f1 f7       	brne	.-4      	; 0x2bb6 <Update+0x252>
    2bba:	00 00       	nop
    2bbc:	57 98       	cbi	0x0a, 7	; 10
    2bbe:	5f 9a       	sbi	0x0b, 7	; 11
    2bc0:	81 e0       	ldi	r24, 0x01	; 1
//	}
//}
	
	_delay_us(1);//2 us end bit

	DDRD &= ~0x80;//in
    2bc2:	54 de       	rcall	.-856    	; 0x286c <read>
	PORTD |= 0x80;//go hi
    2bc4:	8d 8b       	std	Y+21, r24	; 0x15
	unsigned char readAgain=1;
	while (command != 0xff) //0xff means a reset, or rimeout, either way these are exit conditions. 
	{
		if ( command == 0) command = probeReply();//if its a 0x00 This also does a read, so we need to send payload next. 
		sendPayload( command );	
		command = read(1);
    2bc6:	24 cf       	rjmp	.-440    	; 0x2a10 <Update+0xac>
    2bc8:	80 91 8a 03 	lds	r24, 0x038A
    2bcc:	88 23       	and	r24, r24
    2bce:	19 f0       	breq	.+6      	; 0x2bd6 <Update+0x272>
	}
	
	if (_rumble) RumbleSmallMotor=0xff; else RumbleSmallMotor=0;	
    2bd0:	90 93 41 03 	sts	0x0341, r25
    2bd4:	02 c0       	rjmp	.+4      	; 0x2bda <Update+0x276>
    2bd6:	10 92 41 03 	sts	0x0341, r1
    2bda:	65 96       	adiw	r28, 0x15	; 21
    2bdc:	0f b6       	in	r0, 0x3f	; 63
    2bde:	f8 94       	cli
    2be0:	de bf       	out	0x3e, r29	; 62
}
    2be2:	0f be       	out	0x3f, r0	; 63
    2be4:	cd bf       	out	0x3d, r28	; 61
    2be6:	df 91       	pop	r29
    2be8:	cf 91       	pop	r28
    2bea:	1f 91       	pop	r17
    2bec:	0f 91       	pop	r16
    2bee:	ff 90       	pop	r15
    2bf0:	ef 90       	pop	r14
    2bf2:	df 90       	pop	r13
    2bf4:	cf 90       	pop	r12
    2bf6:	bf 90       	pop	r11
    2bf8:	af 90       	pop	r10
    2bfa:	9f 90       	pop	r9
    2bfc:	8f 90       	pop	r8
    2bfe:	7f 90       	pop	r7
    2c00:	6f 90       	pop	r6
    2c02:	5f 90       	pop	r5
    2c04:	4f 90       	pop	r4
    2c06:	3f 90       	pop	r3
    2c08:	2f 90       	pop	r2
    2c0a:	08 95       	ret

00002c0c <Probe>:
    2c0c:	80 e0       	ldi	r24, 0x00	; 0
    2c0e:	2e de       	rcall	.-932    	; 0x286c <read>
    2c10:	99 b1       	in	r25, 0x09	; 9
    2c12:	20 e1       	ldi	r18, 0x10	; 16
    2c14:	2a 95       	dec	r18
    2c16:	f1 f7       	brne	.-4      	; 0x2c14 <Probe+0x8>
    2c18:	81 11       	cpse	r24, r1
{
	unsigned char data = read(0);
	unsigned char check=1;
	check = (PIND & 0x80);//check for the low here, had a .4 us but it was getting missed, removing it seem to help. If a wait is needed try < .5
	_delay_us(3);
	if ( data == 0 && (PIND & 0x80) == 0x80 && check == 0 )  return GC; else return 0;//test for high here to know we are at the end
    2c1a:	06 c0       	rjmp	.+12     	; 0x2c28 <Probe+0x1c>
    2c1c:	4f 9b       	sbis	0x09, 7	; 9
    2c1e:	04 c0       	rjmp	.+8      	; 0x2c28 <Probe+0x1c>
    2c20:	97 fd       	sbrc	r25, 7
    2c22:	02 c0       	rjmp	.+4      	; 0x2c28 <Probe+0x1c>
    2c24:	81 e1       	ldi	r24, 0x11	; 17
    2c26:	08 95       	ret
    2c28:	80 e0       	ldi	r24, 0x00	; 0
    2c2a:	08 95       	ret

00002c2c <gcGetConsole>:
} 
    2c2c:	8a e3       	ldi	r24, 0x3A	; 58
};

ConsoleFound *gcGetConsole(void)
{
	return &GC_Console;
}
    2c2e:	91 e0       	ldi	r25, 0x01	; 1
    2c30:	08 95       	ret

00002c32 <doWork>:
/*********** prototypes *************/
static void Init(void);
static void Update(void);
static void N64Update(unsigned char shortWait);
static unsigned char Probe(void);
static void doWork(void){};
    2c32:	08 95       	ret

00002c34 <Init>:
// Should e able to make a write to function for all this. 


void Init(void)
{
	_checksum=0;
    2c34:	10 92 8e 03 	sts	0x038E, r1
	initRumble=0;
    2c38:	10 92 8d 03 	sts	0x038D, r1
	DDRD &= ~0x80;// in
    2c3c:	57 98       	cbi	0x0a, 7	; 10
	PORTD |= 0x80;// keep low as we use an external pull up
    2c3e:	5f 9a       	sbi	0x0b, 7	; 11
    2c40:	08 95       	ret

00002c42 <CleanUp>:
}

void CleanUp(void)
{
    2c42:	08 95       	ret

00002c44 <sendOneByte>:
    2c44:	20 e2       	ldi	r18, 0x20	; 32
    2c46:	2a 95       	dec	r18
    2c48:	f1 f7       	brne	.-4      	; 0x2c46 <sendOneByte+0x2>
}
void sendOneByte(unsigned char byte)
{

	_delay_us(6);
	DDRD |= 0x80;//out
    2c4a:	57 9a       	sbi	0x0a, 7	; 10
	PORTD &= ~0x80;//go low	
    2c4c:	5f 98       	cbi	0x0b, 7	; 11
    2c4e:	94 e0       	ldi	r25, 0x04	; 4
    2c50:	9a 95       	dec	r25
    2c52:	f1 f7       	brne	.-4      	; 0x2c50 <sendOneByte+0xc>
    2c54:	00 00       	nop
    2c56:	98 e0       	ldi	r25, 0x08	; 8
	_delay_us(.8);
 
	for (char count=0;count<8;count++)//crc
	{
		if (byte & 0x80 ) {  PORTD |= 0x80;   _delay_us(2.5); }//hi
    2c58:	87 ff       	sbrs	r24, 7
    2c5a:	05 c0       	rjmp	.+10     	; 0x2c66 <sendOneByte+0x22>
    2c5c:	5f 9a       	sbi	0x0b, 7	; 11
    2c5e:	2d e0       	ldi	r18, 0x0D	; 13
    2c60:	2a 95       	dec	r18
    2c62:	f1 f7       	brne	.-4      	; 0x2c60 <sendOneByte+0x1c>
    2c64:	08 c0       	rjmp	.+16     	; 0x2c76 <sendOneByte+0x32>
    2c66:	29 e0       	ldi	r18, 0x09	; 9
    2c68:	2a 95       	dec	r18
    2c6a:	f1 f7       	brne	.-4      	; 0x2c68 <sendOneByte+0x24>
    2c6c:	00 00       	nop
		else    { _delay_us(1.7); PORTD |= 0x80;   _delay_us(.8); }//low
    2c6e:	5f 9a       	sbi	0x0b, 7	; 11
    2c70:	24 e0       	ldi	r18, 0x04	; 4
    2c72:	2a 95       	dec	r18
    2c74:	f1 f7       	brne	.-4      	; 0x2c72 <sendOneByte+0x2e>
    2c76:	00 00       	nop
		PORTD &= ~0x80;//go low	
    2c78:	5f 98       	cbi	0x0b, 7	; 11
		byte <<= 1;
    2c7a:	88 0f       	add	r24, r24
    2c7c:	24 e0       	ldi	r18, 0x04	; 4
    2c7e:	2a 95       	dec	r18
    2c80:	f1 f7       	brne	.-4      	; 0x2c7e <sendOneByte+0x3a>
    2c82:	91 50       	subi	r25, 0x01	; 1
	_delay_us(6);
	DDRD |= 0x80;//out
	PORTD &= ~0x80;//go low	
	_delay_us(.8);
 
	for (char count=0;count<8;count++)//crc
    2c84:	49 f7       	brne	.-46     	; 0x2c58 <sendOneByte+0x14>
    2c86:	84 e0       	ldi	r24, 0x04	; 4
    2c88:	8a 95       	dec	r24
    2c8a:	f1 f7       	brne	.-4      	; 0x2c88 <sendOneByte+0x44>
		byte <<= 1;
		_delay_us(.7);
	}
		
	_delay_us(.7);//1.2 us end bit
	DDRD &= ~0x80;//in
    2c8c:	57 98       	cbi	0x0a, 7	; 10
	PORTD |= 0x80;//go hi	
    2c8e:	5f 9a       	sbi	0x0b, 7	; 11
    2c90:	08 95       	ret

00002c92 <sendCapabilities>:
    2c92:	3a e0       	ldi	r19, 0x0A	; 10
    2c94:	3a 95       	dec	r19
    2c96:	f1 f7       	brne	.-4      	; 0x2c94 <sendCapabilities+0x2>
    2c98:	00 c0       	rjmp	.+0      	; 0x2c9a <sendCapabilities+0x8>
void sendCapabilities()
{

	int byte1=0x0500, byte2=1;
	_delay_us(2);//2.4 is the normal reply time. 
	DDRD |= 0x80;//out
    2c9a:	57 9a       	sbi	0x0a, 7	; 10
	PORTD &= ~0x80;//go low	
    2c9c:	5f 98       	cbi	0x0b, 7	; 11
    2c9e:	84 e0       	ldi	r24, 0x04	; 4
    2ca0:	8a 95       	dec	r24
    2ca2:	f1 f7       	brne	.-4      	; 0x2ca0 <sendCapabilities+0xe>
    2ca4:	00 00       	nop
    2ca6:	20 e1       	ldi	r18, 0x10	; 16
}

void sendCapabilities()
{

	int byte1=0x0500, byte2=1;
    2ca8:	80 e0       	ldi	r24, 0x00	; 0
    2caa:	95 e0       	ldi	r25, 0x05	; 5
	_delay_us(.8);
 
 //'why this jump is shorter then the jump in the sendButtonData I have no idea. 
	for (char count=0;count<16;count++)//always 0x0500
	{
		if (byte1 & 0x8000 ) {  PORTD |= 0x80;   _delay_us(2.5); }//hi
    2cac:	97 ff       	sbrs	r25, 7
    2cae:	05 c0       	rjmp	.+10     	; 0x2cba <sendCapabilities+0x28>
    2cb0:	5f 9a       	sbi	0x0b, 7	; 11
    2cb2:	3d e0       	ldi	r19, 0x0D	; 13
    2cb4:	3a 95       	dec	r19
    2cb6:	f1 f7       	brne	.-4      	; 0x2cb4 <sendCapabilities+0x22>
    2cb8:	08 c0       	rjmp	.+16     	; 0x2cca <sendCapabilities+0x38>
    2cba:	39 e0       	ldi	r19, 0x09	; 9
    2cbc:	3a 95       	dec	r19
    2cbe:	f1 f7       	brne	.-4      	; 0x2cbc <sendCapabilities+0x2a>
    2cc0:	00 00       	nop
		else    { _delay_us(1.7); PORTD |= 0x80;   _delay_us(.8); }//low
    2cc2:	5f 9a       	sbi	0x0b, 7	; 11
    2cc4:	34 e0       	ldi	r19, 0x04	; 4
    2cc6:	3a 95       	dec	r19
    2cc8:	f1 f7       	brne	.-4      	; 0x2cc6 <sendCapabilities+0x34>
    2cca:	00 00       	nop
		PORTD &= ~0x80;//go low	
    2ccc:	5f 98       	cbi	0x0b, 7	; 11
		byte1 <<= 1;
    2cce:	88 0f       	add	r24, r24
    2cd0:	99 1f       	adc	r25, r25
    2cd2:	34 e0       	ldi	r19, 0x04	; 4
    2cd4:	3a 95       	dec	r19
    2cd6:	f1 f7       	brne	.-4      	; 0x2cd4 <sendCapabilities+0x42>
    2cd8:	21 50       	subi	r18, 0x01	; 1
	DDRD |= 0x80;//out
	PORTD &= ~0x80;//go low	
	_delay_us(.8);
 
 //'why this jump is shorter then the jump in the sendButtonData I have no idea. 
	for (char count=0;count<16;count++)//always 0x0500
    2cda:	41 f7       	brne	.-48     	; 0x2cac <sendCapabilities+0x1a>
    2cdc:	28 e0       	ldi	r18, 0x08	; 8
    2cde:	81 e0       	ldi	r24, 0x01	; 1
    2ce0:	90 e0       	ldi	r25, 0x00	; 0
		_delay_us(.7);
	}
	
	for (char count =0;count<8;count++)//always  controller pack (rumble)
	{
		if (byte2 & 0x80 ) {  PORTD |= 0x80;   _delay_us(2.5); }//hi
    2ce2:	87 ff       	sbrs	r24, 7
    2ce4:	05 c0       	rjmp	.+10     	; 0x2cf0 <sendCapabilities+0x5e>
    2ce6:	5f 9a       	sbi	0x0b, 7	; 11
    2ce8:	3d e0       	ldi	r19, 0x0D	; 13
    2cea:	3a 95       	dec	r19
    2cec:	f1 f7       	brne	.-4      	; 0x2cea <sendCapabilities+0x58>
    2cee:	08 c0       	rjmp	.+16     	; 0x2d00 <sendCapabilities+0x6e>
    2cf0:	39 e0       	ldi	r19, 0x09	; 9
    2cf2:	3a 95       	dec	r19
    2cf4:	f1 f7       	brne	.-4      	; 0x2cf2 <sendCapabilities+0x60>
    2cf6:	00 00       	nop
		else    { _delay_us(1.7); PORTD |= 0x80;   _delay_us(.8); }//low
    2cf8:	5f 9a       	sbi	0x0b, 7	; 11
    2cfa:	34 e0       	ldi	r19, 0x04	; 4
    2cfc:	3a 95       	dec	r19
    2cfe:	f1 f7       	brne	.-4      	; 0x2cfc <sendCapabilities+0x6a>
    2d00:	00 00       	nop
		PORTD &= ~0x80;//go low
    2d02:	5f 98       	cbi	0x0b, 7	; 11
		byte2 <<= 1;
    2d04:	88 0f       	add	r24, r24
    2d06:	99 1f       	adc	r25, r25
    2d08:	34 e0       	ldi	r19, 0x04	; 4
    2d0a:	3a 95       	dec	r19
    2d0c:	f1 f7       	brne	.-4      	; 0x2d0a <sendCapabilities+0x78>
    2d0e:	21 50       	subi	r18, 0x01	; 1
		PORTD &= ~0x80;//go low	
		byte1 <<= 1;
		_delay_us(.7);
	}
	
	for (char count =0;count<8;count++)//always  controller pack (rumble)
    2d10:	41 f7       	brne	.-48     	; 0x2ce2 <sendCapabilities+0x50>
    2d12:	84 e0       	ldi	r24, 0x04	; 4
    2d14:	8a 95       	dec	r24
    2d16:	f1 f7       	brne	.-4      	; 0x2d14 <sendCapabilities+0x82>
		byte2 <<= 1;
		_delay_us(.7);
	}
	
	_delay_us(.7);//1.2 us end bit
	DDRD &= ~0x80;//in
    2d18:	57 98       	cbi	0x0a, 7	; 10
	PORTD |= 0x80;//go hi	
    2d1a:	5f 9a       	sbi	0x0b, 7	; 11
    2d1c:	08 95       	ret

00002d1e <read>:

unsigned char read(unsigned char shortWait )
{
	unsigned char data =0;
	char i=0;
	DDRD &= ~0x80;// in
    2d1e:	57 98       	cbi	0x0a, 7	; 10
	PORTD |= 0x00;
    2d20:	9b b1       	in	r25, 0x0b	; 11
    2d22:	9b b9       	out	0x0b, r25	; 11
	long timer = 1;	 

	if (shortWait == 0xff ) {WHILE_LINE_IS_HI_ENDLESS}  
    2d24:	8f 3f       	cpi	r24, 0xFF	; 255
    2d26:	19 f4       	brne	.+6      	; 0x2d2e <read+0x10>
    2d28:	4f 99       	sbic	0x09, 7	; 9
    2d2a:	fe cf       	rjmp	.-4      	; 0x2d28 <read+0xa>
    2d2c:	14 c0       	rjmp	.+40     	; 0x2d56 <read+0x38>
	else if (shortWait == 1 ) {WHILE_LINE_IS_HI_SHORT}  
    2d2e:	41 e0       	ldi	r20, 0x01	; 1
    2d30:	50 e0       	ldi	r21, 0x00	; 0
    2d32:	60 e0       	ldi	r22, 0x00	; 0
    2d34:	70 e0       	ldi	r23, 0x00	; 0
    2d36:	81 30       	cpi	r24, 0x01	; 1
    2d38:	a9 f4       	brne	.+42     	; 0x2d64 <read+0x46>
    2d3a:	4f 9b       	sbis	0x09, 7	; 9
    2d3c:	10 c0       	rjmp	.+32     	; 0x2d5e <read+0x40>
    2d3e:	00 00       	nop
    2d40:	4f 5f       	subi	r20, 0xFF	; 255
    2d42:	5f 4f       	sbci	r21, 0xFF	; 255
    2d44:	6f 4f       	sbci	r22, 0xFF	; 255
    2d46:	7f 4f       	sbci	r23, 0xFF	; 255
    2d48:	40 3d       	cpi	r20, 0xD0	; 208
    2d4a:	37 e0       	ldi	r19, 0x07	; 7
    2d4c:	53 07       	cpc	r21, r19
    2d4e:	61 05       	cpc	r22, r1
    2d50:	71 05       	cpc	r23, r1
    2d52:	99 f7       	brne	.-26     	; 0x2d3a <read+0x1c>
    2d54:	04 c0       	rjmp	.+8      	; 0x2d5e <read+0x40>
{
	unsigned char data =0;
	char i=0;
	DDRD &= ~0x80;// in
	PORTD |= 0x00;
	long timer = 1;	 
    2d56:	41 e0       	ldi	r20, 0x01	; 1
    2d58:	50 e0       	ldi	r21, 0x00	; 0
    2d5a:	60 e0       	ldi	r22, 0x00	; 0
    2d5c:	70 e0       	ldi	r23, 0x00	; 0

	if (shortWait == 0xff ) {WHILE_LINE_IS_HI_ENDLESS}  
	else if (shortWait == 1 ) {WHILE_LINE_IS_HI_SHORT}  
	else if (shortWait == 2 ) {WHILE_LINE_IS_HI_LONG}  
    2d5e:	28 e0       	ldi	r18, 0x08	; 8
    2d60:	90 e0       	ldi	r25, 0x00	; 0
    2d62:	26 c0       	rjmp	.+76     	; 0x2db0 <read+0x92>
    2d64:	82 30       	cpi	r24, 0x02	; 2
    2d66:	d9 f4       	brne	.+54     	; 0x2d9e <read+0x80>
    2d68:	4f 9b       	sbis	0x09, 7	; 9
    2d6a:	f9 cf       	rjmp	.-14     	; 0x2d5e <read+0x40>
    2d6c:	00 00       	nop
    2d6e:	4f 5f       	subi	r20, 0xFF	; 255
    2d70:	5f 4f       	sbci	r21, 0xFF	; 255
    2d72:	6f 4f       	sbci	r22, 0xFF	; 255
    2d74:	7f 4f       	sbci	r23, 0xFF	; 255
    2d76:	40 39       	cpi	r20, 0x90	; 144
    2d78:	90 ed       	ldi	r25, 0xD0	; 208
    2d7a:	59 07       	cpc	r21, r25
    2d7c:	93 e0       	ldi	r25, 0x03	; 3
    2d7e:	69 07       	cpc	r22, r25
    2d80:	71 05       	cpc	r23, r1
    2d82:	91 f7       	brne	.-28     	; 0x2d68 <read+0x4a>
    2d84:	ec cf       	rjmp	.-40     	; 0x2d5e <read+0x40>
	else{ WHILE_LINE_IS_HI_LONG} //0
    2d86:	00 00       	nop
    2d88:	4f 5f       	subi	r20, 0xFF	; 255
    2d8a:	5f 4f       	sbci	r21, 0xFF	; 255
    2d8c:	6f 4f       	sbci	r22, 0xFF	; 255
    2d8e:	7f 4f       	sbci	r23, 0xFF	; 255
    2d90:	40 39       	cpi	r20, 0x90	; 144
    2d92:	30 ed       	ldi	r19, 0xD0	; 208
    2d94:	53 07       	cpc	r21, r19
    2d96:	33 e0       	ldi	r19, 0x03	; 3
    2d98:	63 07       	cpc	r22, r19
    2d9a:	71 05       	cpc	r23, r1
    2d9c:	01 f3       	breq	.-64     	; 0x2d5e <read+0x40>
    2d9e:	4f 99       	sbic	0x09, 7	; 9
    2da0:	f2 cf       	rjmp	.-28     	; 0x2d86 <read+0x68>
    2da2:	dd cf       	rjmp	.-70     	; 0x2d5e <read+0x40>
    2da4:	3a e0       	ldi	r19, 0x0A	; 10
    2da6:	3a 95       	dec	r19
    2da8:	f1 f7       	brne	.-4      	; 0x2da6 <read+0x88>
    2daa:	00 c0       	rjmp	.+0      	; 0x2dac <read+0x8e>
    2dac:	21 50       	subi	r18, 0x01	; 1

	for (;i<8;i++)
    2dae:	41 f0       	breq	.+16     	; 0x2dc0 <read+0xa2>
	{   
		data <<=1;
    2db0:	99 0f       	add	r25, r25
    2db2:	39 e0       	ldi	r19, 0x09	; 9
    2db4:	3a 95       	dec	r19
    2db6:	f1 f7       	brne	.-4      	; 0x2db4 <read+0x96>
		_delay_us(1.65);
		if (PIND & 0x80) data  |= 1;
    2db8:	4f 9b       	sbis	0x09, 7	; 9
    2dba:	f4 cf       	rjmp	.-24     	; 0x2da4 <read+0x86>
    2dbc:	91 60       	ori	r25, 0x01	; 1
    2dbe:	f2 cf       	rjmp	.-28     	; 0x2da4 <read+0x86>
		_delay_us(2); 
	}

	
	//we need to use the correct maxtime to see if there was no command and return NO_COMMAND if so.
	if 		(shortWait == 0 && timer == MAX_TIME) return NO_COMMAND; 
    2dc0:	81 11       	cpse	r24, r1
    2dc2:	07 c0       	rjmp	.+14     	; 0x2dd2 <read+0xb4>
    2dc4:	40 32       	cpi	r20, 0x20	; 32
    2dc6:	5e 44       	sbci	r21, 0x4E	; 78
    2dc8:	61 05       	cpc	r22, r1
    2dca:	71 05       	cpc	r23, r1
    2dcc:	89 f0       	breq	.+34     	; 0x2df0 <read+0xd2>
    2dce:	89 2f       	mov	r24, r25
    2dd0:	08 95       	ret
	else if (shortWait == 1 && timer == MAX_TIME_SHORT) return NO_COMMAND;
    2dd2:	81 30       	cpi	r24, 0x01	; 1
    2dd4:	31 f4       	brne	.+12     	; 0x2de2 <read+0xc4>
    2dd6:	40 3d       	cpi	r20, 0xD0	; 208
    2dd8:	57 40       	sbci	r21, 0x07	; 7
    2dda:	61 05       	cpc	r22, r1
    2ddc:	71 05       	cpc	r23, r1
    2dde:	b9 f7       	brne	.-18     	; 0x2dce <read+0xb0>
    2de0:	07 c0       	rjmp	.+14     	; 0x2df0 <read+0xd2>
	else if (shortWait == 2 && timer == MAX_TIME_LONG) return NO_COMMAND; 
    2de2:	82 30       	cpi	r24, 0x02	; 2
    2de4:	a1 f7       	brne	.-24     	; 0x2dce <read+0xb0>
    2de6:	40 39       	cpi	r20, 0x90	; 144
    2de8:	50 4d       	sbci	r21, 0xD0	; 208
    2dea:	63 40       	sbci	r22, 0x03	; 3
    2dec:	71 05       	cpc	r23, r1
    2dee:	79 f7       	brne	.-34     	; 0x2dce <read+0xb0>
		_delay_us(2); 
	}

	
	//we need to use the correct maxtime to see if there was no command and return NO_COMMAND if so.
	if 		(shortWait == 0 && timer == MAX_TIME) return NO_COMMAND; 
    2df0:	8e ef       	ldi	r24, 0xFE	; 254
	else if (shortWait == 1 && timer == MAX_TIME_SHORT) return NO_COMMAND;
	else if (shortWait == 2 && timer == MAX_TIME_LONG) return NO_COMMAND; 
	else return data;
}
    2df2:	08 95       	ret

00002df4 <Probe>:


 unsigned char Probe(void)
{
	unsigned char data = read(2);
    2df4:	82 e0       	ldi	r24, 0x02	; 2
    2df6:	93 df       	rcall	.-218    	; 0x2d1e <read>
    2df8:	9a e1       	ldi	r25, 0x1A	; 26
    2dfa:	9a 95       	dec	r25
    2dfc:	f1 f7       	brne	.-4      	; 0x2dfa <Probe+0x6>
    2dfe:	00 c0       	rjmp	.+0      	; 0x2e00 <Probe+0xc>
    2e00:	99 b1       	in	r25, 0x09	; 9
	_delay_us(5);//get out of data stop bit
	unsigned char check = (PIND & 0x80);//check for the low here
    2e02:	81 30       	cpi	r24, 0x01	; 1
	if ( data == 1 && check == 0x80 )  { return N64;} else return 0;//test for high here to know 
    2e04:	31 f4       	brne	.+12     	; 0x2e12 <Probe+0x1e>
    2e06:	89 2f       	mov	r24, r25

 unsigned char Probe(void)
{
	unsigned char data = read(2);
	_delay_us(5);//get out of data stop bit
	unsigned char check = (PIND & 0x80);//check for the low here
    2e08:	80 78       	andi	r24, 0x80	; 128
    2e0a:	80 38       	cpi	r24, 0x80	; 128
	if ( data == 1 && check == 0x80 )  { return N64;} else return 0;//test for high here to know 
    2e0c:	11 f4       	brne	.+4      	; 0x2e12 <Probe+0x1e>
    2e0e:	83 e2       	ldi	r24, 0x23	; 35
    2e10:	08 95       	ret
    2e12:	80 e0       	ldi	r24, 0x00	; 0
    2e14:	08 95       	ret

00002e16 <mapDPAD>:
} 
    2e16:	80 91 83 03 	lds	r24, 0x0383

}

void mapDPAD()
{
	if (Controller.DpadOnly) //map out d-pad
    2e1a:	88 23       	and	r24, r24
    2e1c:	09 f4       	brne	.+2      	; 0x2e20 <mapDPAD+0xa>
    2e1e:	9c c0       	rjmp	.+312    	; 0x2f58 <mapDPAD+0x142>
	{
		if ( isDiamondController(Controller.Type) )
    2e20:	80 91 86 03 	lds	r24, 0x0386
    2e24:	31 e0       	ldi	r19, 0x01	; 1
    2e26:	83 32       	cpi	r24, 0x23	; 35
    2e28:	09 f0       	breq	.+2      	; 0x2e2c <mapDPAD+0x16>
    2e2a:	30 e0       	ldi	r19, 0x00	; 0
    2e2c:	91 e0       	ldi	r25, 0x01	; 1
    2e2e:	80 31       	cpi	r24, 0x10	; 16
    2e30:	09 f0       	breq	.+2      	; 0x2e34 <mapDPAD+0x1e>
    2e32:	90 e0       	ldi	r25, 0x00	; 0
    2e34:	39 2b       	or	r19, r25
    2e36:	91 e0       	ldi	r25, 0x01	; 1
    2e38:	8f 32       	cpi	r24, 0x2F	; 47
    2e3a:	09 f0       	breq	.+2      	; 0x2e3e <mapDPAD+0x28>
    2e3c:	90 e0       	ldi	r25, 0x00	; 0
    2e3e:	93 2b       	or	r25, r19
    2e40:	31 e0       	ldi	r19, 0x01	; 1
    2e42:	81 34       	cpi	r24, 0x41	; 65
    2e44:	09 f0       	breq	.+2      	; 0x2e48 <mapDPAD+0x32>
    2e46:	30 e0       	ldi	r19, 0x00	; 0
    2e48:	39 2b       	or	r19, r25
    2e4a:	21 e0       	ldi	r18, 0x01	; 1
    2e4c:	89 37       	cpi	r24, 0x79	; 121
    2e4e:	09 f0       	breq	.+2      	; 0x2e52 <mapDPAD+0x3c>
    2e50:	20 e0       	ldi	r18, 0x00	; 0
    2e52:	23 2b       	or	r18, r19
    2e54:	91 e0       	ldi	r25, 0x01	; 1
    2e56:	38 2f       	mov	r19, r24
    2e58:	3f 7d       	andi	r19, 0xDF	; 223
    2e5a:	33 35       	cpi	r19, 0x53	; 83
    2e5c:	09 f0       	breq	.+2      	; 0x2e60 <mapDPAD+0x4a>
    2e5e:	90 e0       	ldi	r25, 0x00	; 0
    2e60:	92 2b       	or	r25, r18
    2e62:	21 f4       	brne	.+8      	; 0x2e6c <mapDPAD+0x56>
    2e64:	8b 7f       	andi	r24, 0xFB	; 251
    2e66:	8b 31       	cpi	r24, 0x1B	; 27
    2e68:	09 f0       	breq	.+2      	; 0x2e6c <mapDPAD+0x56>
    2e6a:	48 c0       	rjmp	.+144    	; 0x2efc <mapDPAD+0xe6>
		{
			if ( (reportBuffer[BUTTON_ROW_1] & 0x0C) == 0x0C  ) {reportBuffer[BUTTON_ROW_1] |= 0x10;}//both options currentl select (z). 
    2e6c:	80 91 68 03 	lds	r24, 0x0368
    2e70:	98 2f       	mov	r25, r24
    2e72:	9c 70       	andi	r25, 0x0C	; 12
    2e74:	9c 30       	cpi	r25, 0x0C	; 12
    2e76:	21 f4       	brne	.+8      	; 0x2e80 <mapDPAD+0x6a>
    2e78:	80 61       	ori	r24, 0x10	; 16
    2e7a:	80 93 68 03 	sts	0x0368, r24
    2e7e:	3e c0       	rjmp	.+124    	; 0x2efc <mapDPAD+0xe6>
			else if (reportBuffer[BUTTON_ROW_1] & 0x04  ) //c-left used d-pad
    2e80:	82 ff       	sbrs	r24, 2
    2e82:	04 c0       	rjmp	.+8      	; 0x2e8c <mapDPAD+0x76>
			{ 
				reportBuffer[BUTTON_ROW_1] &= ~0x04; return;
    2e84:	8b 7f       	andi	r24, 0xFB	; 251
    2e86:	80 93 68 03 	sts	0x0368, r24
    2e8a:	08 95       	ret
				//keep it how it is
			}
			else if (reportBuffer[BUTTON_ROW_1] & 0x08  ) //c-down uses c-pad
    2e8c:	83 ff       	sbrs	r24, 3
    2e8e:	36 c0       	rjmp	.+108    	; 0x2efc <mapDPAD+0xe6>
			{ 
				reportBuffer[BUTTON_ROW_1] &= ~0x08;
    2e90:	98 2f       	mov	r25, r24
    2e92:	97 7f       	andi	r25, 0xF7	; 247
    2e94:	90 93 68 03 	sts	0x0368, r25
				if (reportBuffer[HAT] == DPAD_LEFT	   )reportBuffer[BUTTON_ROW_1] |= 0x04;
    2e98:	80 91 6a 03 	lds	r24, 0x036A
    2e9c:	86 30       	cpi	r24, 0x06	; 6
    2e9e:	11 f4       	brne	.+4      	; 0x2ea4 <mapDPAD+0x8e>
    2ea0:	94 60       	ori	r25, 0x04	; 4
    2ea2:	13 c0       	rjmp	.+38     	; 0x2eca <mapDPAD+0xb4>
				if (reportBuffer[HAT] == DPAD_RIGHT	   )reportBuffer[BUTTON_ROW_2] |= 0x02;
    2ea4:	82 30       	cpi	r24, 0x02	; 2
    2ea6:	21 f4       	brne	.+8      	; 0x2eb0 <mapDPAD+0x9a>
    2ea8:	80 91 69 03 	lds	r24, 0x0369
    2eac:	82 60       	ori	r24, 0x02	; 2
    2eae:	1b c0       	rjmp	.+54     	; 0x2ee6 <mapDPAD+0xd0>
				if (reportBuffer[HAT] == DPAD_UP	   )reportBuffer[BUTTON_ROW_2] |= 0x01;
    2eb0:	81 11       	cpse	r24, r1
    2eb2:	04 c0       	rjmp	.+8      	; 0x2ebc <mapDPAD+0xa6>
    2eb4:	80 91 69 03 	lds	r24, 0x0369
    2eb8:	81 60       	ori	r24, 0x01	; 1
    2eba:	15 c0       	rjmp	.+42     	; 0x2ee6 <mapDPAD+0xd0>
				if (reportBuffer[HAT] == DPAD_DOWN	   )reportBuffer[BUTTON_ROW_1] |= 0x08;
    2ebc:	84 30       	cpi	r24, 0x04	; 4
    2ebe:	11 f4       	brne	.+4      	; 0x2ec4 <mapDPAD+0xae>
    2ec0:	98 60       	ori	r25, 0x08	; 8
    2ec2:	03 c0       	rjmp	.+6      	; 0x2eca <mapDPAD+0xb4>
				if (reportBuffer[HAT] == DPAD_UPLEFT   )reportBuffer[BUTTON_ROW_1] |= 0x05;
    2ec4:	87 30       	cpi	r24, 0x07	; 7
    2ec6:	21 f4       	brne	.+8      	; 0x2ed0 <mapDPAD+0xba>
    2ec8:	95 60       	ori	r25, 0x05	; 5
    2eca:	90 93 68 03 	sts	0x0368, r25
    2ece:	41 c0       	rjmp	.+130    	; 0x2f52 <mapDPAD+0x13c>
				if (reportBuffer[HAT] == DPAD_DOWNLEFT )reportBuffer[BUTTON_ROW_2] |= 0x0C;
    2ed0:	85 30       	cpi	r24, 0x05	; 5
    2ed2:	21 f4       	brne	.+8      	; 0x2edc <mapDPAD+0xc6>
    2ed4:	80 91 69 03 	lds	r24, 0x0369
    2ed8:	8c 60       	ori	r24, 0x0C	; 12
    2eda:	05 c0       	rjmp	.+10     	; 0x2ee6 <mapDPAD+0xd0>
				if (reportBuffer[HAT] == DPAD_UPRIGHT  )reportBuffer[BUTTON_ROW_2] |= 0x03;
    2edc:	81 30       	cpi	r24, 0x01	; 1
    2ede:	31 f4       	brne	.+12     	; 0x2eec <mapDPAD+0xd6>
    2ee0:	80 91 69 03 	lds	r24, 0x0369
    2ee4:	83 60       	ori	r24, 0x03	; 3
    2ee6:	80 93 69 03 	sts	0x0369, r24
    2eea:	33 c0       	rjmp	.+102    	; 0x2f52 <mapDPAD+0x13c>
				if (reportBuffer[HAT] == DPAD_DOWNRIGHT)reportBuffer[BUTTON_ROW_1] |= 0x0A;
    2eec:	83 30       	cpi	r24, 0x03	; 3
    2eee:	89 f5       	brne	.+98     	; 0x2f52 <mapDPAD+0x13c>
    2ef0:	80 91 68 03 	lds	r24, 0x0368
    2ef4:	8a 60       	ori	r24, 0x0A	; 10
    2ef6:	80 93 68 03 	sts	0x0368, r24
    2efa:	2b c0       	rjmp	.+86     	; 0x2f52 <mapDPAD+0x13c>
				reportBuffer[HAT] = 0xff; return;
			}
		}
		
		//default analog. 
		if (reportBuffer[HAT] == DPAD_LEFT	   )reportBuffer[X_MAIN_STICK] =0;
    2efc:	80 91 6a 03 	lds	r24, 0x036A
    2f00:	86 30       	cpi	r24, 0x06	; 6
    2f02:	b9 f0       	breq	.+46     	; 0x2f32 <mapDPAD+0x11c>
		if (reportBuffer[HAT] == DPAD_RIGHT	   )reportBuffer[X_MAIN_STICK] =255;
    2f04:	82 30       	cpi	r24, 0x02	; 2
    2f06:	e1 f0       	breq	.+56     	; 0x2f40 <mapDPAD+0x12a>
		if (reportBuffer[HAT] == DPAD_UP	   )reportBuffer[Y_MAIN_STICK] =0;
    2f08:	81 11       	cpse	r24, r1
    2f0a:	03 c0       	rjmp	.+6      	; 0x2f12 <mapDPAD+0xfc>
    2f0c:	10 92 6c 03 	sts	0x036C, r1
    2f10:	20 c0       	rjmp	.+64     	; 0x2f52 <mapDPAD+0x13c>
		if (reportBuffer[HAT] == DPAD_DOWN	   )reportBuffer[Y_MAIN_STICK] =255;
    2f12:	84 30       	cpi	r24, 0x04	; 4
    2f14:	21 f4       	brne	.+8      	; 0x2f1e <mapDPAD+0x108>
    2f16:	8f ef       	ldi	r24, 0xFF	; 255
    2f18:	80 93 6c 03 	sts	0x036C, r24
    2f1c:	1a c0       	rjmp	.+52     	; 0x2f52 <mapDPAD+0x13c>
		if (reportBuffer[HAT] == DPAD_UPLEFT   ){reportBuffer[Y_MAIN_STICK] =0;reportBuffer[X_MAIN_STICK] =0;}
    2f1e:	87 30       	cpi	r24, 0x07	; 7
    2f20:	19 f4       	brne	.+6      	; 0x2f28 <mapDPAD+0x112>
    2f22:	10 92 6c 03 	sts	0x036C, r1
    2f26:	05 c0       	rjmp	.+10     	; 0x2f32 <mapDPAD+0x11c>
		if (reportBuffer[HAT] == DPAD_DOWNLEFT ){reportBuffer[Y_MAIN_STICK] =255;reportBuffer[X_MAIN_STICK] =0;}
    2f28:	85 30       	cpi	r24, 0x05	; 5
    2f2a:	31 f4       	brne	.+12     	; 0x2f38 <mapDPAD+0x122>
    2f2c:	8f ef       	ldi	r24, 0xFF	; 255
    2f2e:	80 93 6c 03 	sts	0x036C, r24
    2f32:	10 92 6b 03 	sts	0x036B, r1
    2f36:	0d c0       	rjmp	.+26     	; 0x2f52 <mapDPAD+0x13c>
		if (reportBuffer[HAT] == DPAD_UPRIGHT  ){reportBuffer[Y_MAIN_STICK] =0;reportBuffer[X_MAIN_STICK] =255;}
    2f38:	81 30       	cpi	r24, 0x01	; 1
    2f3a:	21 f4       	brne	.+8      	; 0x2f44 <mapDPAD+0x12e>
    2f3c:	10 92 6c 03 	sts	0x036C, r1
    2f40:	8f ef       	ldi	r24, 0xFF	; 255
    2f42:	05 c0       	rjmp	.+10     	; 0x2f4e <mapDPAD+0x138>
		if (reportBuffer[HAT] == DPAD_DOWNRIGHT){reportBuffer[Y_MAIN_STICK] =255;reportBuffer[X_MAIN_STICK] =255;}
    2f44:	83 30       	cpi	r24, 0x03	; 3
    2f46:	29 f4       	brne	.+10     	; 0x2f52 <mapDPAD+0x13c>
    2f48:	8f ef       	ldi	r24, 0xFF	; 255
    2f4a:	80 93 6c 03 	sts	0x036C, r24
    2f4e:	80 93 6b 03 	sts	0x036B, r24
		reportBuffer[HAT] = 0xff;
    2f52:	8f ef       	ldi	r24, 0xFF	; 255
    2f54:	80 93 6a 03 	sts	0x036A, r24
    2f58:	08 95       	ret

00002f5a <Update>:
	DDRD &= ~0x80;//in
	PORTD |= 0x80;//go hi	
}

void  Update(  )
{
    2f5a:	df 92       	push	r13
    2f5c:	ef 92       	push	r14
    2f5e:	ff 92       	push	r15
    2f60:	0f 93       	push	r16
    2f62:	1f 93       	push	r17
    2f64:	cf 93       	push	r28
    2f66:	df 93       	push	r29
    2f68:	1f 92       	push	r1
    2f6a:	cd b7       	in	r28, 0x3d	; 61
    2f6c:	de b7       	in	r29, 0x3e	; 62


	PORTD &= ~0x30; _delay_us(10) ;
    2f6e:	8b b1       	in	r24, 0x0b	; 11
    2f70:	8f 7c       	andi	r24, 0xCF	; 207
    2f72:	8b b9       	out	0x0b, r24	; 11
    2f74:	25 e3       	ldi	r18, 0x35	; 53
    2f76:	2a 95       	dec	r18
    2f78:	f1 f7       	brne	.-4      	; 0x2f76 <Update+0x1c>
    2f7a:	00 00       	nop
    2f7c:	8f ef       	ldi	r24, 0xFF	; 255
	if (reportBuffer[BUTTON_ROW_1] & 0x02)  N64_BUFFER_D |= 0x8000;//a
	if (reportBuffer[BUTTON_ROW_1] & 0x01)  N64_BUFFER_D |= 0x4000;//b
	if (reportBuffer[BUTTON_ROW_1] & 0x20)  N64_BUFFER_D |= 0x1000;//start
	
	//n64 does not like max range, cut it down.
	if (reportBuffer[X_MAIN_STICK] > 207) reportBuffer[X_MAIN_STICK] = 207;
    2f7e:	ef ec       	ldi	r30, 0xCF	; 207
    2f80:	ee 2e       	mov	r14, r30
	if (reportBuffer[X_MAIN_STICK] < 47) reportBuffer[X_MAIN_STICK] = 47;
    2f82:	ff e2       	ldi	r31, 0x2F	; 47
    2f84:	df 2e       	mov	r13, r31
	if (reportBuffer[Y_MAIN_STICK] > 207) reportBuffer[Y_MAIN_STICK] = 207;
	if (reportBuffer[Y_MAIN_STICK] < 47) reportBuffer[Y_MAIN_STICK] = 47;
	//put into signed. 
	char x = (reportBuffer[X_MAIN_STICK] - 128);
	char y = ((255 - reportBuffer[Y_MAIN_STICK]) - 128);
    2f86:	1f e7       	ldi	r17, 0x7F	; 127
		unsigned char rumbling=read(0);
		_delay_ms(1.014); //get out of data and quickly reply
		if 		(rumbling == 0x80) { initRumble =1; sendOneByte(0xb8);} //handle the check sum and take no rumble action but expect reply. 
		else if (rumbling == 0xfe) sendOneByte(0xe1);  //handle the check sum and take no rumble action but expect reply. This is a memory card prob. 
		else if (rumbling == 0x1b) sendOneByte(0x00);  //seen in batman give it back 00
		else if (rumbling == 1) {RumbleSmallMotor=255;sendOneByte(0xeb);} //1's means rumble on
    2f88:	0f ef       	ldi	r16, 0xFF	; 255
	else if ( command == WRITE_CARD_COMMAND) //write command, for rumble we need 3,80,1,1 for on, 3,80,0,0 for off
	{ 
		_delay_us(62); //jump to our data position. 
		unsigned char rumbling=read(0);
		_delay_ms(1.014); //get out of data and quickly reply
		if 		(rumbling == 0x80) { initRumble =1; sendOneByte(0xb8);} //handle the check sum and take no rumble action but expect reply. 
    2f8a:	ff 24       	eor	r15, r15
    2f8c:	f3 94       	inc	r15
    2f8e:	20 ed       	ldi	r18, 0xD0	; 208
    2f90:	37 e0       	ldi	r19, 0x07	; 7
	// poll when it should have and the code as in here > 16 ms with a "pressed" button condition. Since we must stay in here 
	// and wait, we have that button pending. I see two options. 1) make a 16 timer after you read buttons, and clear it if exceeded.
	// 2) use a pin change to come back in here and not wait.
	
	
	unsigned char line=0;
    2f92:	90 e0       	ldi	r25, 0x00	; 0
	int to=0;
	while (line < 5)//use 5 hits
	{//this code must be less then 1us to work
		if (PIND & 0x80) line++; else line = 0;
    2f94:	49 b1       	in	r20, 0x09	; 9
    2f96:	44 0f       	add	r20, r20
    2f98:	44 0b       	sbc	r20, r20
    2f9a:	9f 5f       	subi	r25, 0xFF	; 255
    2f9c:	94 23       	and	r25, r20
    2f9e:	21 50       	subi	r18, 0x01	; 1
    2fa0:	31 09       	sbc	r19, r1
		to++;
		if (to == 2000) {return;}//something is bad wrong...
    2fa2:	21 15       	cp	r18, r1
    2fa4:	31 05       	cpc	r19, r1
    2fa6:	09 f4       	brne	.+2      	; 0x2faa <Update+0x50>
    2fa8:	03 c2       	rjmp	.+1030   	; 0x33b0 <Update+0x456>
	// 2) use a pin change to come back in here and not wait.
	
	
	unsigned char line=0;
	int to=0;
	while (line < 5)//use 5 hits
    2faa:	95 30       	cpi	r25, 0x05	; 5
    2fac:	98 f3       	brcs	.-26     	; 0x2f94 <Update+0x3a>
		if (PIND & 0x80) line++; else line = 0;
		to++;
		if (to == 2000) {return;}//something is bad wrong...
	}

	N64_BUFFER_A = N64_BUFFER_D  =0;	
    2fae:	10 92 8c 03 	sts	0x038C, r1
    2fb2:	10 92 8b 03 	sts	0x038B, r1
    2fb6:	10 92 90 03 	sts	0x0390, r1
    2fba:	10 92 8f 03 	sts	0x038F, r1
	char count=0;
	char size=0;
	
	mapDPAD();
    2fbe:	89 83       	std	Y+1, r24	; 0x01
    2fc0:	2a df       	rcall	.-428    	; 0x2e16 <mapDPAD>
    2fc2:	90 91 6a 03 	lds	r25, 0x036A

	if (reportBuffer[HAT] == DPAD_LEFT	   )N64_BUFFER_D |= 0x200;
    2fc6:	89 81       	ldd	r24, Y+1	; 0x01
    2fc8:	96 30       	cpi	r25, 0x06	; 6
    2fca:	31 f4       	brne	.+12     	; 0x2fd8 <Update+0x7e>
    2fcc:	20 91 8b 03 	lds	r18, 0x038B
    2fd0:	30 91 8c 03 	lds	r19, 0x038C
    2fd4:	32 60       	ori	r19, 0x02	; 2
    2fd6:	37 c0       	rjmp	.+110    	; 0x3046 <Update+0xec>
    2fd8:	92 30       	cpi	r25, 0x02	; 2
	if (reportBuffer[HAT] == DPAD_RIGHT	   )N64_BUFFER_D |= 0x100;
    2fda:	31 f4       	brne	.+12     	; 0x2fe8 <Update+0x8e>
    2fdc:	20 91 8b 03 	lds	r18, 0x038B
    2fe0:	30 91 8c 03 	lds	r19, 0x038C
    2fe4:	31 60       	ori	r19, 0x01	; 1
    2fe6:	2f c0       	rjmp	.+94     	; 0x3046 <Update+0xec>
    2fe8:	91 11       	cpse	r25, r1
	if (reportBuffer[HAT] == DPAD_UP	   )N64_BUFFER_D |= 0x800;
    2fea:	06 c0       	rjmp	.+12     	; 0x2ff8 <Update+0x9e>
    2fec:	20 91 8b 03 	lds	r18, 0x038B
    2ff0:	30 91 8c 03 	lds	r19, 0x038C
    2ff4:	38 60       	ori	r19, 0x08	; 8
    2ff6:	27 c0       	rjmp	.+78     	; 0x3046 <Update+0xec>
    2ff8:	94 30       	cpi	r25, 0x04	; 4
	if (reportBuffer[HAT] == DPAD_DOWN	   )N64_BUFFER_D |= 0x400;
    2ffa:	31 f4       	brne	.+12     	; 0x3008 <Update+0xae>
    2ffc:	20 91 8b 03 	lds	r18, 0x038B
    3000:	30 91 8c 03 	lds	r19, 0x038C
    3004:	34 60       	ori	r19, 0x04	; 4
    3006:	1f c0       	rjmp	.+62     	; 0x3046 <Update+0xec>
    3008:	95 30       	cpi	r25, 0x05	; 5
	if (reportBuffer[HAT] == DPAD_DOWNLEFT )N64_BUFFER_D |= 0x600;
    300a:	31 f4       	brne	.+12     	; 0x3018 <Update+0xbe>
    300c:	20 91 8b 03 	lds	r18, 0x038B
    3010:	30 91 8c 03 	lds	r19, 0x038C
    3014:	36 60       	ori	r19, 0x06	; 6
    3016:	17 c0       	rjmp	.+46     	; 0x3046 <Update+0xec>
    3018:	97 30       	cpi	r25, 0x07	; 7
	if (reportBuffer[HAT] == DPAD_UPLEFT   )N64_BUFFER_D |= 0xA00;
    301a:	31 f4       	brne	.+12     	; 0x3028 <Update+0xce>
    301c:	20 91 8b 03 	lds	r18, 0x038B
    3020:	30 91 8c 03 	lds	r19, 0x038C
    3024:	3a 60       	ori	r19, 0x0A	; 10
    3026:	0f c0       	rjmp	.+30     	; 0x3046 <Update+0xec>
    3028:	91 30       	cpi	r25, 0x01	; 1
	if (reportBuffer[HAT] == DPAD_UPRIGHT  )N64_BUFFER_D |= 0x900;
    302a:	31 f4       	brne	.+12     	; 0x3038 <Update+0xde>
    302c:	20 91 8b 03 	lds	r18, 0x038B
    3030:	30 91 8c 03 	lds	r19, 0x038C
    3034:	39 60       	ori	r19, 0x09	; 9
    3036:	07 c0       	rjmp	.+14     	; 0x3046 <Update+0xec>
    3038:	93 30       	cpi	r25, 0x03	; 3
	if (reportBuffer[HAT] == DPAD_DOWNRIGHT)N64_BUFFER_D |= 0x500;
    303a:	49 f4       	brne	.+18     	; 0x304e <Update+0xf4>
    303c:	20 91 8b 03 	lds	r18, 0x038B
    3040:	30 91 8c 03 	lds	r19, 0x038C
    3044:	35 60       	ori	r19, 0x05	; 5
    3046:	30 93 8c 03 	sts	0x038C, r19
    304a:	20 93 8b 03 	sts	0x038B, r18
    304e:	90 91 68 03 	lds	r25, 0x0368
	if (reportBuffer[BUTTON_ROW_1] & 0x10)  N64_BUFFER_D |= 0x2000;//Z
    3052:	94 ff       	sbrs	r25, 4
    3054:	09 c0       	rjmp	.+18     	; 0x3068 <Update+0x10e>
    3056:	20 91 8b 03 	lds	r18, 0x038B
    305a:	30 91 8c 03 	lds	r19, 0x038C
    305e:	30 62       	ori	r19, 0x20	; 32
    3060:	30 93 8c 03 	sts	0x038C, r19
    3064:	20 93 8b 03 	sts	0x038B, r18
    3068:	97 ff       	sbrs	r25, 7
	if (reportBuffer[BUTTON_ROW_1] & 0x80)  N64_BUFFER_D |= 0x10;//r
    306a:	09 c0       	rjmp	.+18     	; 0x307e <Update+0x124>
    306c:	20 91 8b 03 	lds	r18, 0x038B
    3070:	30 91 8c 03 	lds	r19, 0x038C
    3074:	20 61       	ori	r18, 0x10	; 16
    3076:	30 93 8c 03 	sts	0x038C, r19
    307a:	20 93 8b 03 	sts	0x038B, r18
    307e:	96 ff       	sbrs	r25, 6
	if (reportBuffer[BUTTON_ROW_1] & 0x40)  N64_BUFFER_D |= 0x20;  //l	
    3080:	09 c0       	rjmp	.+18     	; 0x3094 <Update+0x13a>
    3082:	20 91 8b 03 	lds	r18, 0x038B
    3086:	30 91 8c 03 	lds	r19, 0x038C
    308a:	20 62       	ori	r18, 0x20	; 32
    308c:	30 93 8c 03 	sts	0x038C, r19
    3090:	20 93 8b 03 	sts	0x038B, r18
    3094:	40 91 69 03 	lds	r20, 0x0369
	//reset ?         										0x80                                 
	//0                                                		0x40	
	
	//for analog sticks use right stick for the c buttons?
	if (reportBuffer[BUTTON_ROW_2] & 0x01 ||  reportBuffer[Y_SECONDARY_STICK] < 100)  N64_BUFFER_D |= 0x08;   //cu	
    3098:	40 fd       	sbrc	r20, 0
    309a:	04 c0       	rjmp	.+8      	; 0x30a4 <Update+0x14a>
    309c:	20 91 6e 03 	lds	r18, 0x036E
    30a0:	24 36       	cpi	r18, 0x64	; 100
    30a2:	48 f4       	brcc	.+18     	; 0x30b6 <Update+0x15c>
    30a4:	20 91 8b 03 	lds	r18, 0x038B
    30a8:	30 91 8c 03 	lds	r19, 0x038C
    30ac:	28 60       	ori	r18, 0x08	; 8
    30ae:	30 93 8c 03 	sts	0x038C, r19
    30b2:	20 93 8b 03 	sts	0x038B, r18
    30b6:	93 fd       	sbrc	r25, 3
	if (reportBuffer[BUTTON_ROW_1] & 0x08 ||  reportBuffer[Y_SECONDARY_STICK] > 150)  N64_BUFFER_D |= 0x04;   //cd	
    30b8:	04 c0       	rjmp	.+8      	; 0x30c2 <Update+0x168>
    30ba:	20 91 6e 03 	lds	r18, 0x036E
    30be:	27 39       	cpi	r18, 0x97	; 151
    30c0:	48 f0       	brcs	.+18     	; 0x30d4 <Update+0x17a>
    30c2:	20 91 8b 03 	lds	r18, 0x038B
    30c6:	30 91 8c 03 	lds	r19, 0x038C
    30ca:	24 60       	ori	r18, 0x04	; 4
    30cc:	30 93 8c 03 	sts	0x038C, r19
    30d0:	20 93 8b 03 	sts	0x038B, r18
    30d4:	92 fd       	sbrc	r25, 2
	if (reportBuffer[BUTTON_ROW_1] & 0x04 ||  reportBuffer[X_SECONDARY_STICK] < 100)  N64_BUFFER_D |= 0x02;   //cl	
    30d6:	04 c0       	rjmp	.+8      	; 0x30e0 <Update+0x186>
    30d8:	20 91 6d 03 	lds	r18, 0x036D
    30dc:	24 36       	cpi	r18, 0x64	; 100
    30de:	48 f4       	brcc	.+18     	; 0x30f2 <Update+0x198>
    30e0:	20 91 8b 03 	lds	r18, 0x038B
    30e4:	30 91 8c 03 	lds	r19, 0x038C
    30e8:	22 60       	ori	r18, 0x02	; 2
    30ea:	30 93 8c 03 	sts	0x038C, r19
    30ee:	20 93 8b 03 	sts	0x038B, r18
    30f2:	41 fd       	sbrc	r20, 1
	if (reportBuffer[BUTTON_ROW_2] & 0x02 ||  reportBuffer[X_SECONDARY_STICK] > 150)  N64_BUFFER_D |= 0x01;   //cr	
    30f4:	04 c0       	rjmp	.+8      	; 0x30fe <Update+0x1a4>
    30f6:	20 91 6d 03 	lds	r18, 0x036D
    30fa:	27 39       	cpi	r18, 0x97	; 151
    30fc:	48 f0       	brcs	.+18     	; 0x3110 <Update+0x1b6>
    30fe:	20 91 8b 03 	lds	r18, 0x038B
    3102:	30 91 8c 03 	lds	r19, 0x038C
    3106:	21 60       	ori	r18, 0x01	; 1
    3108:	30 93 8c 03 	sts	0x038C, r19
    310c:	20 93 8b 03 	sts	0x038B, r18
    3110:	91 ff       	sbrs	r25, 1
                                                       
	if (reportBuffer[BUTTON_ROW_1] & 0x02)  N64_BUFFER_D |= 0x8000;//a
    3112:	09 c0       	rjmp	.+18     	; 0x3126 <Update+0x1cc>
    3114:	20 91 8b 03 	lds	r18, 0x038B
    3118:	30 91 8c 03 	lds	r19, 0x038C
    311c:	30 68       	ori	r19, 0x80	; 128
    311e:	30 93 8c 03 	sts	0x038C, r19
    3122:	20 93 8b 03 	sts	0x038B, r18
    3126:	90 ff       	sbrs	r25, 0
	if (reportBuffer[BUTTON_ROW_1] & 0x01)  N64_BUFFER_D |= 0x4000;//b
    3128:	09 c0       	rjmp	.+18     	; 0x313c <Update+0x1e2>
    312a:	20 91 8b 03 	lds	r18, 0x038B
    312e:	30 91 8c 03 	lds	r19, 0x038C
    3132:	30 64       	ori	r19, 0x40	; 64
    3134:	30 93 8c 03 	sts	0x038C, r19
    3138:	20 93 8b 03 	sts	0x038B, r18
    313c:	95 ff       	sbrs	r25, 5
	if (reportBuffer[BUTTON_ROW_1] & 0x20)  N64_BUFFER_D |= 0x1000;//start
    313e:	09 c0       	rjmp	.+18     	; 0x3152 <Update+0x1f8>
    3140:	20 91 8b 03 	lds	r18, 0x038B
    3144:	30 91 8c 03 	lds	r19, 0x038C
    3148:	30 61       	ori	r19, 0x10	; 16
    314a:	30 93 8c 03 	sts	0x038C, r19
    314e:	20 93 8b 03 	sts	0x038B, r18
    3152:	90 91 6b 03 	lds	r25, 0x036B
	
	//n64 does not like max range, cut it down.
	if (reportBuffer[X_MAIN_STICK] > 207) reportBuffer[X_MAIN_STICK] = 207;
    3156:	90 3d       	cpi	r25, 0xD0	; 208
    3158:	10 f0       	brcs	.+4      	; 0x315e <Update+0x204>
    315a:	e0 92 6b 03 	sts	0x036B, r14
    315e:	90 91 6b 03 	lds	r25, 0x036B
	if (reportBuffer[X_MAIN_STICK] < 47) reportBuffer[X_MAIN_STICK] = 47;
    3162:	9f 32       	cpi	r25, 0x2F	; 47
    3164:	10 f4       	brcc	.+4      	; 0x316a <Update+0x210>
    3166:	d0 92 6b 03 	sts	0x036B, r13
    316a:	90 91 6c 03 	lds	r25, 0x036C
	if (reportBuffer[Y_MAIN_STICK] > 207) reportBuffer[Y_MAIN_STICK] = 207;
    316e:	90 3d       	cpi	r25, 0xD0	; 208
    3170:	10 f0       	brcs	.+4      	; 0x3176 <Update+0x21c>
    3172:	e0 92 6c 03 	sts	0x036C, r14
    3176:	90 91 6c 03 	lds	r25, 0x036C
	if (reportBuffer[Y_MAIN_STICK] < 47) reportBuffer[Y_MAIN_STICK] = 47;
    317a:	9f 32       	cpi	r25, 0x2F	; 47
    317c:	10 f4       	brcc	.+4      	; 0x3182 <Update+0x228>
    317e:	d0 92 6c 03 	sts	0x036C, r13
    3182:	20 91 6b 03 	lds	r18, 0x036B
	//put into signed. 
	char x = (reportBuffer[X_MAIN_STICK] - 128);
    3186:	20 58       	subi	r18, 0x80	; 128
    3188:	30 e0       	ldi	r19, 0x00	; 0
	char y = ((255 - reportBuffer[Y_MAIN_STICK]) - 128);
	
	N64_BUFFER_A =  y | (x<<8);
    318a:	32 2f       	mov	r19, r18
    318c:	22 27       	eor	r18, r18
    318e:	90 91 6c 03 	lds	r25, 0x036C
	if (reportBuffer[X_MAIN_STICK] < 47) reportBuffer[X_MAIN_STICK] = 47;
	if (reportBuffer[Y_MAIN_STICK] > 207) reportBuffer[Y_MAIN_STICK] = 207;
	if (reportBuffer[Y_MAIN_STICK] < 47) reportBuffer[Y_MAIN_STICK] = 47;
	//put into signed. 
	char x = (reportBuffer[X_MAIN_STICK] - 128);
	char y = ((255 - reportBuffer[Y_MAIN_STICK]) - 128);
    3192:	41 2f       	mov	r20, r17
    3194:	49 1b       	sub	r20, r25
    3196:	24 2b       	or	r18, r20
	
	N64_BUFFER_A =  y | (x<<8);
    3198:	30 93 90 03 	sts	0x0390, r19
    319c:	20 93 8f 03 	sts	0x038F, r18
    31a0:	be dd       	rcall	.-1156   	; 0x2d1e <read>

	//N64_GET_CAPABILITIES		0x00
	//N64_RESET					0xFF 
	//N64_GET_STATUS			0x01

	unsigned char command  = read(shortWait); 
    31a2:	81 30       	cpi	r24, 0x01	; 1
    31a4:	09 f0       	breq	.+2      	; 0x31a8 <Update+0x24e>

	if ( 	  command == STATUS_COMMAND) sendButtonData();//status
    31a6:	51 c0       	rjmp	.+162    	; 0x324a <Update+0x2f0>
    31a8:	8a e0       	ldi	r24, 0x0A	; 10
    31aa:	8a 95       	dec	r24
    31ac:	f1 f7       	brne	.-4      	; 0x31aa <Update+0x250>
    31ae:	00 c0       	rjmp	.+0      	; 0x31b0 <Update+0x256>
    31b0:	57 9a       	sbi	0x0a, 7	; 10
    31b2:	5f 98       	cbi	0x0b, 7	; 11
	
}
void sendButtonData()//up to 32 bits.  
{
	_delay_us(2);//2.4 is the normal reply time. 
	DDRD |= 0x80;//out
    31b4:	94 e0       	ldi	r25, 0x04	; 4
	PORTD &= ~0x80;//go low	
    31b6:	9a 95       	dec	r25
    31b8:	f1 f7       	brne	.-4      	; 0x31b6 <Update+0x25c>
    31ba:	00 00       	nop
    31bc:	20 e1       	ldi	r18, 0x10	; 16
    31be:	80 91 8b 03 	lds	r24, 0x038B
	_delay_us(.8);
	char count=0;
	for (;count<16;count++)//buttons
	{
		if (N64_BUFFER_D & 0x8000 ) {  PORTD |= 0x80;   _delay_us(2.5); }//hi
    31c2:	90 91 8c 03 	lds	r25, 0x038C
    31c6:	97 ff       	sbrs	r25, 7
    31c8:	05 c0       	rjmp	.+10     	; 0x31d4 <Update+0x27a>
    31ca:	5f 9a       	sbi	0x0b, 7	; 11
    31cc:	ed e0       	ldi	r30, 0x0D	; 13
    31ce:	ea 95       	dec	r30
    31d0:	f1 f7       	brne	.-4      	; 0x31ce <Update+0x274>
    31d2:	08 c0       	rjmp	.+16     	; 0x31e4 <Update+0x28a>
    31d4:	f9 e0       	ldi	r31, 0x09	; 9
    31d6:	fa 95       	dec	r31
    31d8:	f1 f7       	brne	.-4      	; 0x31d6 <Update+0x27c>
    31da:	00 c0       	rjmp	.+0      	; 0x31dc <Update+0x282>
    31dc:	5f 9a       	sbi	0x0b, 7	; 11
    31de:	34 e0       	ldi	r19, 0x04	; 4
		else    { _delay_us(1.8); PORTD |= 0x80;   _delay_us(.8); }//low
    31e0:	3a 95       	dec	r19
    31e2:	f1 f7       	brne	.-4      	; 0x31e0 <Update+0x286>
    31e4:	00 00       	nop
    31e6:	5f 98       	cbi	0x0b, 7	; 11
    31e8:	80 91 8b 03 	lds	r24, 0x038B
		PORTD &= ~0x80;//go low	
		N64_BUFFER_D <<= 1;
    31ec:	90 91 8c 03 	lds	r25, 0x038C
    31f0:	88 0f       	add	r24, r24
    31f2:	99 1f       	adc	r25, r25
    31f4:	90 93 8c 03 	sts	0x038C, r25
    31f8:	80 93 8b 03 	sts	0x038B, r24
    31fc:	21 50       	subi	r18, 0x01	; 1
    31fe:	f9 f6       	brne	.-66     	; 0x31be <Update+0x264>
    3200:	20 e1       	ldi	r18, 0x10	; 16
	_delay_us(2);//2.4 is the normal reply time. 
	DDRD |= 0x80;//out
	PORTD &= ~0x80;//go low	
	_delay_us(.8);
	char count=0;
	for (;count<16;count++)//buttons
    3202:	80 91 8f 03 	lds	r24, 0x038F
		N64_BUFFER_D <<= 1;
	}
	
	for ( ;count>0;count--)//analogs
	{
		if (N64_BUFFER_A & 0x8000 ) {  PORTD |= 0x80;   _delay_us(2.5); }//hi
    3206:	90 91 90 03 	lds	r25, 0x0390
    320a:	97 ff       	sbrs	r25, 7
    320c:	05 c0       	rjmp	.+10     	; 0x3218 <Update+0x2be>
    320e:	5f 9a       	sbi	0x0b, 7	; 11
    3210:	4d e0       	ldi	r20, 0x0D	; 13
    3212:	4a 95       	dec	r20
    3214:	f1 f7       	brne	.-4      	; 0x3212 <Update+0x2b8>
    3216:	08 c0       	rjmp	.+16     	; 0x3228 <Update+0x2ce>
    3218:	89 e0       	ldi	r24, 0x09	; 9
    321a:	8a 95       	dec	r24
    321c:	f1 f7       	brne	.-4      	; 0x321a <Update+0x2c0>
    321e:	00 c0       	rjmp	.+0      	; 0x3220 <Update+0x2c6>
    3220:	5f 9a       	sbi	0x0b, 7	; 11
    3222:	94 e0       	ldi	r25, 0x04	; 4
		else    { _delay_us(1.8); PORTD |= 0x80;   _delay_us(.8); }//low
    3224:	9a 95       	dec	r25
    3226:	f1 f7       	brne	.-4      	; 0x3224 <Update+0x2ca>
    3228:	00 00       	nop
    322a:	5f 98       	cbi	0x0b, 7	; 11
    322c:	80 91 8f 03 	lds	r24, 0x038F
		PORTD &= ~0x80;//go low
		N64_BUFFER_A <<= 1;
    3230:	90 91 90 03 	lds	r25, 0x0390
    3234:	88 0f       	add	r24, r24
    3236:	99 1f       	adc	r25, r25
    3238:	90 93 90 03 	sts	0x0390, r25
    323c:	80 93 8f 03 	sts	0x038F, r24
    3240:	21 50       	subi	r18, 0x01	; 1
    3242:	f9 f6       	brne	.-66     	; 0x3202 <Update+0x2a8>
    3244:	00 c0       	rjmp	.+0      	; 0x3246 <Update+0x2ec>
		else    { _delay_us(1.8); PORTD |= 0x80;   _delay_us(.8); }//low
		PORTD &= ~0x80;//go low	
		N64_BUFFER_D <<= 1;
	}
	
	for ( ;count>0;count--)//analogs
    3246:	00 c0       	rjmp	.+0      	; 0x3248 <Update+0x2ee>
    3248:	84 c0       	rjmp	.+264    	; 0x3352 <Update+0x3f8>
    324a:	81 11       	cpse	r24, r1
    324c:	03 c0       	rjmp	.+6      	; 0x3254 <Update+0x2fa>
	//N64_GET_STATUS			0x01

	unsigned char command  = read(shortWait); 

	if ( 	  command == STATUS_COMMAND) sendButtonData();//status
	else if ( command == GETCAP_COMMAND)  sendCapabilities(); //CAPABILITIES - expect another read !
    324e:	21 dd       	rcall	.-1470   	; 0x2c92 <sendCapabilities>
    3250:	81 e0       	ldi	r24, 0x01	; 1
    3252:	9d ce       	rjmp	.-710    	; 0x2f8e <Update+0x34>
    3254:	8f 3f       	cpi	r24, 0xFF	; 255
    3256:	49 f4       	brne	.+18     	; 0x326a <Update+0x310>
    3258:	0f 90       	pop	r0
	else if ( command ==  RESET_COMMAND) { sendCapabilities(); return;} //some games (m64) issue 1 reset and look for this reply. 
    325a:	df 91       	pop	r29
    325c:	cf 91       	pop	r28


	PORTD &= ~0x30; _delay_us(10) ;
	N64Update( 0xff );//always start with a endless wait. Some games only ask for a controller once when it starts. So from the menu to the game we need to sit and wait. 

}
    325e:	1f 91       	pop	r17
    3260:	0f 91       	pop	r16
    3262:	ff 90       	pop	r15
    3264:	ef 90       	pop	r14
    3266:	df 90       	pop	r13
    3268:	14 cd       	rjmp	.-1496   	; 0x2c92 <sendCapabilities>
    326a:	82 30       	cpi	r24, 0x02	; 2
    326c:	09 f0       	breq	.+2      	; 0x3270 <Update+0x316>

	unsigned char command  = read(shortWait); 

	if ( 	  command == STATUS_COMMAND) sendButtonData();//status
	else if ( command == GETCAP_COMMAND)  sendCapabilities(); //CAPABILITIES - expect another read !
	else if ( command ==  RESET_COMMAND) { sendCapabilities(); return;} //some games (m64) issue 1 reset and look for this reply. 
    326e:	75 c0       	rjmp	.+234    	; 0x335a <Update+0x400>
    3270:	e3 e0       	ldi	r30, 0x03	; 3
* n64 2 8001 expects 32 80's - B8 CRC. ; read at address 8001 if its a rumble it will return the 80's back.


********************************************************/

	else if ( command == READ_CARD_COMMAND) 
    3272:	f1 e0       	ldi	r31, 0x01	; 1
    3274:	31 97       	sbiw	r30, 0x01	; 1
    3276:	f1 f7       	brne	.-4      	; 0x3274 <Update+0x31a>
    3278:	00 c0       	rjmp	.+0      	; 0x327a <Update+0x320>
    327a:	00 00       	nop
    327c:	80 91 8d 03 	lds	r24, 0x038D
    3280:	88 23       	and	r24, r24
    3282:	09 f4       	brne	.+2      	; 0x3286 <Update+0x32c>
	{
		_delay_us(65); 
		if (initRumble) 
    3284:	52 c0       	rjmp	.+164    	; 0x332a <Update+0x3d0>
    3286:	fa e2       	ldi	r31, 0x2A	; 42
    3288:	fa 95       	dec	r31
    328a:	f1 f7       	brne	.-4      	; 0x3288 <Update+0x32e>
    328c:	00 c0       	rjmp	.+0      	; 0x328e <Update+0x334>
    328e:	57 9a       	sbi	0x0a, 7	; 10
    3290:	5f 98       	cbi	0x0b, 7	; 11
    3292:	22 e0       	ldi	r18, 0x02	; 2
    3294:	2a 95       	dec	r18
}
void send34Eightys()//for now, just use static stuff, not sure we'd evern send all 0's or all 1's
{
	unsigned char byte = 0x80;
	_delay_us(8);
	DDRD |= 0x80;//out
    3296:	f1 f7       	brne	.-4      	; 0x3294 <Update+0x33a>
	PORTD &= ~0x80;//go low	
    3298:	00 00       	nop
    329a:	80 e0       	ldi	r24, 0x00	; 0
    329c:	91 e0       	ldi	r25, 0x01	; 1
    329e:	20 e8       	ldi	r18, 0x80	; 128
    32a0:	27 ff       	sbrs	r18, 7
    32a2:	0a c0       	rjmp	.+20     	; 0x32b8 <Update+0x35e>
    32a4:	32 e0       	ldi	r19, 0x02	; 2
	PORTD |= 0x80;//go hi	
	
}
void send34Eightys()//for now, just use static stuff, not sure we'd evern send all 0's or all 1's
{
	unsigned char byte = 0x80;
    32a6:	3a 95       	dec	r19
	PORTD &= ~0x80;//go low	
	_delay_us(.4);
 
	for (int count=0;count<256;count++)//canlt use 255 and <= ?
	{
		if (byte & 0x80 ) {  _delay_us(.4);  PORTD |= 0x80;   _delay_us(2.5); }//hi
    32a8:	f1 f7       	brne	.-4      	; 0x32a6 <Update+0x34c>
    32aa:	00 00       	nop
    32ac:	5f 9a       	sbi	0x0b, 7	; 11
    32ae:	4d e0       	ldi	r20, 0x0D	; 13
    32b0:	4a 95       	dec	r20
    32b2:	f1 f7       	brne	.-4      	; 0x32b0 <Update+0x356>
    32b4:	00 00       	nop
    32b6:	08 c0       	rjmp	.+16     	; 0x32c8 <Update+0x36e>
    32b8:	e8 e0       	ldi	r30, 0x08	; 8
    32ba:	ea 95       	dec	r30
    32bc:	f1 f7       	brne	.-4      	; 0x32ba <Update+0x360>
    32be:	00 c0       	rjmp	.+0      	; 0x32c0 <Update+0x366>
    32c0:	5f 9a       	sbi	0x0b, 7	; 11
    32c2:	f5 e0       	ldi	r31, 0x05	; 5
    32c4:	fa 95       	dec	r31
    32c6:	f1 f7       	brne	.-4      	; 0x32c4 <Update+0x36a>
		else    { _delay_us(1.6); PORTD |= 0x80;   _delay_us(.9); }//low
    32c8:	5f 98       	cbi	0x0b, 7	; 11
    32ca:	26 95       	lsr	r18
    32cc:	29 f0       	breq	.+10     	; 0x32d8 <Update+0x37e>
    32ce:	32 e0       	ldi	r19, 0x02	; 2
		PORTD &= ~0x80;//go low	
    32d0:	3a 95       	dec	r19
		byte >>= 1;//go right so we have a natural count down to use. 
    32d2:	f1 f7       	brne	.-4      	; 0x32d0 <Update+0x376>
		if (byte == 0) byte = 0x80; 
    32d4:	00 c0       	rjmp	.+0      	; 0x32d6 <Update+0x37c>
    32d6:	01 c0       	rjmp	.+2      	; 0x32da <Update+0x380>
    32d8:	20 e8       	ldi	r18, 0x80	; 128
    32da:	01 97       	sbiw	r24, 0x01	; 1
    32dc:	00 97       	sbiw	r24, 0x00	; 0
    32de:	01 f7       	brne	.-64     	; 0x32a0 <Update+0x346>
    32e0:	00 c0       	rjmp	.+0      	; 0x32e2 <Update+0x388>
    32e2:	00 c0       	rjmp	.+0      	; 0x32e4 <Update+0x38a>
	_delay_us(8);
	DDRD |= 0x80;//out
	PORTD &= ~0x80;//go low	
	_delay_us(.4);
 
	for (int count=0;count<256;count++)//canlt use 255 and <= ?
    32e4:	00 00       	nop
    32e6:	88 e0       	ldi	r24, 0x08	; 8
    32e8:	98 eb       	ldi	r25, 0xB8	; 184
    32ea:	97 ff       	sbrs	r25, 7
    32ec:	05 c0       	rjmp	.+10     	; 0x32f8 <Update+0x39e>
    32ee:	5f 9a       	sbi	0x0b, 7	; 11
		byte >>= 1;//go right so we have a natural count down to use. 
		if (byte == 0) byte = 0x80; 
		else _delay_us(.5);
	}
	_delay_us(.3);
	byte = 0xb8;
    32f0:	4d e0       	ldi	r20, 0x0D	; 13
	for (char count=0;count<8;count++)//crc
	{
		if (byte & 0x80 ) {  PORTD |= 0x80;   _delay_us(2.5); }//hi
    32f2:	4a 95       	dec	r20
    32f4:	f1 f7       	brne	.-4      	; 0x32f2 <Update+0x398>
    32f6:	08 c0       	rjmp	.+16     	; 0x3308 <Update+0x3ae>
    32f8:	e9 e0       	ldi	r30, 0x09	; 9
    32fa:	ea 95       	dec	r30
    32fc:	f1 f7       	brne	.-4      	; 0x32fa <Update+0x3a0>
    32fe:	00 00       	nop
    3300:	5f 9a       	sbi	0x0b, 7	; 11
    3302:	f4 e0       	ldi	r31, 0x04	; 4
    3304:	fa 95       	dec	r31
    3306:	f1 f7       	brne	.-4      	; 0x3304 <Update+0x3aa>
		else    { _delay_us(1.7); PORTD |= 0x80;   _delay_us(.8); }//low
    3308:	00 00       	nop
    330a:	5f 98       	cbi	0x0b, 7	; 11
    330c:	99 0f       	add	r25, r25
    330e:	24 e0       	ldi	r18, 0x04	; 4
    3310:	2a 95       	dec	r18
		PORTD &= ~0x80;//go low	
    3312:	f1 f7       	brne	.-4      	; 0x3310 <Update+0x3b6>
		byte <<= 1;
    3314:	81 50       	subi	r24, 0x01	; 1
    3316:	49 f7       	brne	.-46     	; 0x32ea <Update+0x390>
    3318:	34 e0       	ldi	r19, 0x04	; 4
    331a:	3a 95       	dec	r19
    331c:	f1 f7       	brne	.-4      	; 0x331a <Update+0x3c0>
		if (byte == 0) byte = 0x80; 
		else _delay_us(.5);
	}
	_delay_us(.3);
	byte = 0xb8;
	for (char count=0;count<8;count++)//crc
    331e:	00 00       	nop
    3320:	57 98       	cbi	0x0a, 7	; 10
    3322:	5f 9a       	sbi	0x0b, 7	; 11
    3324:	10 92 8d 03 	sts	0x038D, r1
		PORTD &= ~0x80;//go low	
		byte <<= 1;
		_delay_us(.7);
	}
	_delay_us(.8 );//1.2 us end bit
	DDRD &= ~0x80;//in
    3328:	93 cf       	rjmp	.-218    	; 0x3250 <Update+0x2f6>
	PORTD |= 0x80;//go hi	
    332a:	40 e2       	ldi	r20, 0x20	; 32
	{
		_delay_us(65); 
		if (initRumble) 
		{ 
			send34Eightys();   //must add 1 byte crc 0f b8. 
			initRumble =0;
    332c:	4a 95       	dec	r20
    332e:	f1 f7       	brne	.-4      	; 0x332c <Update+0x3d2>
    3330:	57 9a       	sbi	0x0a, 7	; 10
    3332:	80 e1       	ldi	r24, 0x10	; 16
    3334:	91 e0       	ldi	r25, 0x01	; 1
    3336:	5f 9a       	sbi	0x0b, 7	; 11
}
void send34Zeros()//for now, just use static stuff, not sure we'd evern send all 0's or all 1's
{
	_delay_us(6);
	//time this out.
	DDRD |= 0x80;//out
    3338:	e4 e0       	ldi	r30, 0x04	; 4
    333a:	ea 95       	dec	r30
    333c:	f1 f7       	brne	.-4      	; 0x333a <Update+0x3e0>

	for (int count=0;count<272/*264*/;count++)//33 zeros. but needs 34?
	{
		PORTD |= 0x80;
    333e:	5f 98       	cbi	0x0b, 7	; 11
    3340:	fc e0       	ldi	r31, 0x0C	; 12
    3342:	fa 95       	dec	r31
    3344:	f1 f7       	brne	.-4      	; 0x3342 <Update+0x3e8>
		_delay_us(.7); 	PORTD &= ~0x80;//go low
    3346:	01 97       	sbiw	r24, 0x01	; 1
    3348:	00 97       	sbiw	r24, 0x00	; 0
    334a:	a9 f7       	brne	.-22     	; 0x3336 <Update+0x3dc>
    334c:	25 e0       	ldi	r18, 0x05	; 5
    334e:	2a 95       	dec	r18
{
	_delay_us(6);
	//time this out.
	DDRD |= 0x80;//out

	for (int count=0;count<272/*264*/;count++)//33 zeros. but needs 34?
    3350:	f1 f7       	brne	.-4      	; 0x334e <Update+0x3f4>
    3352:	00 00       	nop
    3354:	57 98       	cbi	0x0a, 7	; 10
    3356:	5f 9a       	sbi	0x0b, 7	; 11
    3358:	7b cf       	rjmp	.-266    	; 0x3250 <Update+0x2f6>
    335a:	83 30       	cpi	r24, 0x03	; 3
		PORTD |= 0x80;
		_delay_us(.7); 	PORTD &= ~0x80;//go low
		_delay_us(2.2);
	}
	_delay_us(1);//1.2 us end bit
	DDRD &= ~0x80;//in
    335c:	31 f5       	brne	.+76     	; 0x33aa <Update+0x450>
	PORTD |= 0x80;//go hi
    335e:	87 ef       	ldi	r24, 0xF7	; 247
    3360:	90 e0       	ldi	r25, 0x00	; 0
		else 
		{
			send34Zeros(); //must add 1 byte crc 0f 0. 
		}		
	} 
	else if ( command == WRITE_CARD_COMMAND) //write command, for rumble we need 3,80,1,1 for on, 3,80,0,0 for off
    3362:	01 97       	sbiw	r24, 0x01	; 1
    3364:	f1 f7       	brne	.-4      	; 0x3362 <Update+0x408>
    3366:	00 c0       	rjmp	.+0      	; 0x3368 <Update+0x40e>
    3368:	00 00       	nop
    336a:	80 e0       	ldi	r24, 0x00	; 0
    336c:	d8 dc       	rcall	.-1616   	; 0x2d1e <read>
    336e:	e8 ed       	ldi	r30, 0xD8	; 216
    3370:	ff e0       	ldi	r31, 0x0F	; 15
	{ 
		_delay_us(62); //jump to our data position. 
		unsigned char rumbling=read(0);
    3372:	31 97       	sbiw	r30, 0x01	; 1
    3374:	f1 f7       	brne	.-4      	; 0x3372 <Update+0x418>
    3376:	80 38       	cpi	r24, 0x80	; 128
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3378:	21 f4       	brne	.+8      	; 0x3382 <Update+0x428>
    337a:	f0 92 8d 03 	sts	0x038D, r15
    337e:	88 eb       	ldi	r24, 0xB8	; 184
		_delay_ms(1.014); //get out of data and quickly reply
		if 		(rumbling == 0x80) { initRumble =1; sendOneByte(0xb8);} //handle the check sum and take no rumble action but expect reply. 
    3380:	12 c0       	rjmp	.+36     	; 0x33a6 <Update+0x44c>
    3382:	8e 3f       	cpi	r24, 0xFE	; 254
    3384:	11 f4       	brne	.+4      	; 0x338a <Update+0x430>
    3386:	81 ee       	ldi	r24, 0xE1	; 225
    3388:	0e c0       	rjmp	.+28     	; 0x33a6 <Update+0x44c>
    338a:	8b 31       	cpi	r24, 0x1B	; 27
		else if (rumbling == 0xfe) sendOneByte(0xe1);  //handle the check sum and take no rumble action but expect reply. This is a memory card prob. 
    338c:	11 f4       	brne	.+4      	; 0x3392 <Update+0x438>
    338e:	80 e0       	ldi	r24, 0x00	; 0
    3390:	0a c0       	rjmp	.+20     	; 0x33a6 <Update+0x44c>
    3392:	81 30       	cpi	r24, 0x01	; 1
		else if (rumbling == 0x1b) sendOneByte(0x00);  //seen in batman give it back 00
    3394:	21 f4       	brne	.+8      	; 0x339e <Update+0x444>
    3396:	00 93 41 03 	sts	0x0341, r16
    339a:	8b ee       	ldi	r24, 0xEB	; 235
		else if (rumbling == 1) {RumbleSmallMotor=255;sendOneByte(0xeb);} //1's means rumble on
    339c:	04 c0       	rjmp	.+8      	; 0x33a6 <Update+0x44c>
    339e:	81 11       	cpse	r24, r1
    33a0:	57 cf       	rjmp	.-338    	; 0x3250 <Update+0x2f6>
    33a2:	10 92 41 03 	sts	0x0341, r1
    33a6:	4e dc       	rcall	.-1892   	; 0x2c44 <sendOneByte>
		else if (rumbling == 0)  {RumbleSmallMotor=0; sendOneByte(0);}    //0's means rumble off
    33a8:	53 cf       	rjmp	.-346    	; 0x3250 <Update+0x2f6>
    33aa:	8e 3f       	cpi	r24, 0xFE	; 254
    33ac:	09 f0       	breq	.+2      	; 0x33b0 <Update+0x456>
    33ae:	50 cf       	rjmp	.-352    	; 0x3250 <Update+0x2f6>
    33b0:	0f 90       	pop	r0
    33b2:	df 91       	pop	r29
    33b4:	cf 91       	pop	r28
	}
	//return out and try later. Some times in menus (everdrive) the n64 makes a 150ms pause in between presses, to prevent double pressing. We will not get fresh 
	else if ( command == NO_COMMAND)  return;//reset or answer for max time. With n64 there can be sequential commands. but if no talk for 2ms, its safe (I think)
    33b6:	1f 91       	pop	r17
    33b8:	0f 91       	pop	r16
    33ba:	ff 90       	pop	r15


	PORTD &= ~0x30; _delay_us(10) ;
	N64Update( 0xff );//always start with a endless wait. Some games only ask for a controller once when it starts. So from the menu to the game we need to sit and wait. 

}
    33bc:	ef 90       	pop	r14
    33be:	df 90       	pop	r13
    33c0:	08 95       	ret

000033c2 <n64GetConsole>:
    33c2:	84 e4       	ldi	r24, 0x44	; 68
    33c4:	91 e0       	ldi	r25, 0x01	; 1
    33c6:	08 95       	ret

000033c8 <doWork>:

/*********** prototypes *************/
static void Init(void);
static void Update(void);
static unsigned char Probe(void);
static void doWork(void){};
    33c8:	08 95       	ret

000033ca <Init>:
static unsigned char _low_state_portd_6button_Second;
static unsigned char _low_state_portd_6button_Second_Third;

void Init(void)
{
	DDRD &= ~0xF3;// in the D pins
    33ca:	8a b1       	in	r24, 0x0a	; 10
    33cc:	8c 70       	andi	r24, 0x0C	; 12
    33ce:	8a b9       	out	0x0a, r24	; 10
	PORTD |= 0xF3;// high 
    33d0:	8b b1       	in	r24, 0x0b	; 11
    33d2:	83 6f       	ori	r24, 0xF3	; 243
    33d4:	8b b9       	out	0x0b, r24	; 11
	
	_low_state_portd_first =
	_low_state_portd_second=
	_low_state_portd_6button_First =
	_low_state_portd_6button_Second =
	_low_state_portd_6button_Second_Third =0xF3; 
    33d6:	83 ef       	ldi	r24, 0xF3	; 243
    33d8:	80 93 11 03 	sts	0x0311, r24
	PORTD |= 0xF3;// high 
	
	_low_state_portd_first =
	_low_state_portd_second=
	_low_state_portd_6button_First =
	_low_state_portd_6button_Second =
    33dc:	80 93 12 03 	sts	0x0312, r24
	DDRD &= ~0xF3;// in the D pins
	PORTD |= 0xF3;// high 
	
	_low_state_portd_first =
	_low_state_portd_second=
	_low_state_portd_6button_First =
    33e0:	80 93 13 03 	sts	0x0313, r24
{
	DDRD &= ~0xF3;// in the D pins
	PORTD |= 0xF3;// high 
	
	_low_state_portd_first =
	_low_state_portd_second=
    33e4:	80 93 14 03 	sts	0x0314, r24
void Init(void)
{
	DDRD &= ~0xF3;// in the D pins
	PORTD |= 0xF3;// high 
	
	_low_state_portd_first =
    33e8:	80 93 15 03 	sts	0x0315, r24
	_low_state_portd_second=
	_low_state_portd_6button_First =
	_low_state_portd_6button_Second =
	_low_state_portd_6button_Second_Third =0xF3; 
	
	PULSE_PORT &= ~PULSE;
    33ec:	46 98       	cbi	0x08, 6	; 8
	DDRC &= ~PULSE;
    33ee:	3e 98       	cbi	0x07, 6	; 7

	_verify_=0;
	
	_CON_TIMER_EXP_SETUP
    33f0:	88 e0       	ldi	r24, 0x08	; 8
    33f2:	80 93 81 00 	sts	0x0081, r24
    33f6:	82 e0       	ldi	r24, 0x02	; 2
    33f8:	80 93 6f 00 	sts	0x006F, r24
    33fc:	8f ef       	ldi	r24, 0xFF	; 255
    33fe:	91 e0       	ldi	r25, 0x01	; 1
    3400:	90 93 89 00 	sts	0x0089, r25
    3404:	80 93 88 00 	sts	0x0088, r24
			
	_verify_=0;
    3408:	10 92 17 03 	sts	0x0317, r1
	skipaPoll=0;
    340c:	10 92 16 03 	sts	0x0316, r1
	_CON_TIMER_EXP_FLAG=false;
    3410:	10 92 42 03 	sts	0x0342, r1
    3414:	08 95       	ret

00003416 <CleanUp>:
}

void CleanUp(void)
{
  _CON_TIMER_EXP_STOP
    3416:	b1 9a       	sbi	0x16, 1	; 22
    3418:	10 92 85 00 	sts	0x0085, r1
    341c:	10 92 84 00 	sts	0x0084, r1
    3420:	10 92 81 00 	sts	0x0081, r1
    3424:	f8 94       	cli
    3426:	08 95       	ret

00003428 <Probe>:
	
	//DDRD was set in it in and high 

	unsigned int timer = 1;	
	
	if ( (PIND & 0xf3) == 0xf3 ) //all pins high check
    3428:	89 b1       	in	r24, 0x09	; 9
    342a:	83 7f       	andi	r24, 0xF3	; 243
    342c:	83 3f       	cpi	r24, 0xF3	; 243
    342e:	09 f0       	breq	.+2      	; 0x3432 <Probe+0xa>
    3430:	08 95       	ret
	{
		//`````|___|``````
		if ( (PULSE_PIN & PULSE) == PULSE ) //line was high
    3432:	8f ef       	ldi	r24, 0xFF	; 255
    3434:	9c e7       	ldi	r25, 0x7C	; 124
    3436:	36 9b       	sbis	0x06, 6	; 6
    3438:	09 c0       	rjmp	.+18     	; 0x344c <Probe+0x24>
		{
			WHILE_PULSE_IS_HI //wait for pulse to go low
    343a:	36 9b       	sbis	0x06, 6	; 6
    343c:	0a c0       	rjmp	.+20     	; 0x3452 <Probe+0x2a>
    343e:	01 97       	sbiw	r24, 0x01	; 1
    3440:	00 97       	sbiw	r24, 0x00	; 0
    3442:	d9 f7       	brne	.-10     	; 0x343a <Probe+0x12>
    3444:	f5 cf       	rjmp	.-22     	; 0x3430 <Probe+0x8>
    3446:	01 97       	sbiw	r24, 0x01	; 1
		}
		
		//_____|~~~~~|______
		else
		{
			WHILE_PULSE_IS_LO //wait for pulse to go high
    3448:	00 97       	sbiw	r24, 0x00	; 0
    344a:	91 f3       	breq	.-28     	; 0x3430 <Probe+0x8>
    344c:	36 9b       	sbis	0x06, 6	; 6
    344e:	fb cf       	rjmp	.-10     	; 0x3446 <Probe+0x1e>
    3450:	0e c0       	rjmp	.+28     	; 0x346e <Probe+0x46>
	{
		//`````|___|``````
		if ( (PULSE_PIN & PULSE) == PULSE ) //line was high
		{
			WHILE_PULSE_IS_HI //wait for pulse to go low
			if ( timer != MAX_TIME && ((PIND & 0xf3) == 0xf3  ))//all pins high and max check
    3452:	89 b1       	in	r24, 0x09	; 9
    3454:	83 7f       	andi	r24, 0xF3	; 243
    3456:	83 3f       	cpi	r24, 0xF3	; 243
    3458:	59 f7       	brne	.-42     	; 0x3430 <Probe+0x8>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    345a:	80 e5       	ldi	r24, 0x50	; 80
    345c:	8a 95       	dec	r24
    345e:	f1 f7       	brne	.-4      	; 0x345c <Probe+0x34>
			{
				_delay_us(15); //skip passed pulse
				if ( (PIND & 0xf3) == 0xf3  && (PULSE_PIN & PULSE) == PULSE)//all pins high check and paluse line high
    3460:	89 b1       	in	r24, 0x09	; 9
    3462:	83 7f       	andi	r24, 0xF3	; 243
    3464:	83 3f       	cpi	r24, 0xF3	; 243
    3466:	21 f7       	brne	.-56     	; 0x3430 <Probe+0x8>
    3468:	36 99       	sbic	0x06, 6	; 6
    346a:	0e c0       	rjmp	.+28     	; 0x3488 <Probe+0x60>
    346c:	e1 cf       	rjmp	.-62     	; 0x3430 <Probe+0x8>
		
		//_____|~~~~~|______
		else
		{
			WHILE_PULSE_IS_LO //wait for pulse to go high
			if ( timer != MAX_TIME && (PIND & 0xf3) == 0xf3  )//all pins high and max check
    346e:	89 b1       	in	r24, 0x09	; 9
    3470:	83 7f       	andi	r24, 0xF3	; 243
    3472:	83 3f       	cpi	r24, 0xF3	; 243
    3474:	e9 f6       	brne	.-70     	; 0x3430 <Probe+0x8>
    3476:	80 e5       	ldi	r24, 0x50	; 80
    3478:	8a 95       	dec	r24
    347a:	f1 f7       	brne	.-4      	; 0x3478 <Probe+0x50>
			{
				_delay_us(15); //skip passed pulse
				if ( (PIND & 0xf3) == 0xf3  && (PULSE_PIN & PULSE) == 0)//all pins high check and paluse line low. 
    347c:	89 b1       	in	r24, 0x09	; 9
    347e:	83 7f       	andi	r24, 0xF3	; 243
    3480:	83 3f       	cpi	r24, 0xF3	; 243
    3482:	b1 f6       	brne	.-84     	; 0x3430 <Probe+0x8>
    3484:	36 99       	sbic	0x06, 6	; 6
    3486:	d4 cf       	rjmp	.-88     	; 0x3430 <Probe+0x8>
    3488:	85 e2       	ldi	r24, 0x25	; 37
    348a:	08 95       	ret

0000348c <pinChange>:
  _CON_TIMER_EXP_STOP
}

bool pinChange( unsigned char state, unsigned char data)
{
	_CON_TIMER_EXP_FLAG=false; //set a flag to cath ISR for no responce. 
    348c:	10 92 42 03 	sts	0x0342, r1
	
_CON_TIMER_EXP_START;//start ISR
    3490:	90 91 81 00 	lds	r25, 0x0081
    3494:	95 60       	ori	r25, 0x05	; 5
    3496:	90 93 81 00 	sts	0x0081, r25
    349a:	78 94       	sei
    349c:	10 92 85 00 	sts	0x0085, r1
    34a0:	10 92 84 00 	sts	0x0084, r1
 
	if (state == line_high) //is high, wait for low
    34a4:	81 30       	cpi	r24, 0x01	; 1
    34a6:	31 f4       	brne	.+12     	; 0x34b4 <start201+0x8>
	{
		asm volatile("mov r31,%0\n start%=:sbic 0x06,6\n rjmp start%=\n out 0x0B,r31\n"::"w"(data):"r31"); 
    34a8:	86 2f       	mov	r24, r22
    34aa:	f8 2f       	mov	r31, r24

000034ac <start201>:
    34ac:	36 99       	sbic	0x06, 6	; 6
    34ae:	fe cf       	rjmp	.-4      	; 0x34ac <start201>
    34b0:	fb b9       	out	0x0b, r31	; 11
    34b2:	05 c0       	rjmp	.+10     	; 0x34be <start210+0x6>
	}
	else //is low wait for high
	{
		asm volatile("mov r31,%0\n start%=:sbis 0x06,6\n rjmp start%=\n out 0x0B,r31\n"::"w"(data):"r31"); 
    34b4:	86 2f       	mov	r24, r22
    34b6:	f8 2f       	mov	r31, r24

000034b8 <start210>:
    34b8:	36 9b       	sbis	0x06, 6	; 6
    34ba:	fe cf       	rjmp	.-4      	; 0x34b8 <start210>
    34bc:	fb b9       	out	0x0b, r31	; 11
	}
	
_CON_TIMER_EXP_STOP;//Stop ISR
    34be:	b1 9a       	sbi	0x16, 1	; 22
    34c0:	10 92 85 00 	sts	0x0085, r1
    34c4:	10 92 84 00 	sts	0x0084, r1
    34c8:	10 92 81 00 	sts	0x0081, r1
    34cc:	f8 94       	cli

	if(_CON_TIMER_EXP_FLAG) //check flag
    34ce:	80 91 42 03 	lds	r24, 0x0342
    34d2:	88 23       	and	r24, r24
    34d4:	69 f0       	breq	.+26     	; 0x34f0 <start210+0x38>
	{
		DDRC &= ~PULSE;//bring line back in. 
    34d6:	3e 98       	cbi	0x07, 6	; 7
    34d8:	8a e6       	ldi	r24, 0x6A	; 106
    34da:	8a 95       	dec	r24
    34dc:	f1 f7       	brne	.-4      	; 0x34da <start210+0x22>
    34de:	00 c0       	rjmp	.+0      	; 0x34e0 <start210+0x28>
	
		//reset wires depending on where the lines rests. one we bring in from abouse it should go to its resting state. 
		_delay_us(20);//give it a bit of time. more than 15 seems to be needed here. 
		
		//resume resting condition. 
		if ( (PULSE_PIN & PULSE) == 0 ) PORTD  &= ~0xC0;//set normal state  
    34e0:	36 99       	sbic	0x06, 6	; 6
    34e2:	03 c0       	rjmp	.+6      	; 0x34ea <start210+0x32>
    34e4:	8b b1       	in	r24, 0x0b	; 11
    34e6:	8f 73       	andi	r24, 0x3F	; 63
    34e8:	02 c0       	rjmp	.+4      	; 0x34ee <start210+0x36>
		else  PORTD |= 0xF3;//set normal state  
    34ea:	8b b1       	in	r24, 0x0b	; 11
    34ec:	83 6f       	ori	r24, 0xF3	; 243
    34ee:	8b b9       	out	0x0b, r24	; 11
	}
	
	return _CON_TIMER_EXP_FLAG;  //for quick return. 
}
    34f0:	80 91 42 03 	lds	r24, 0x0342
    34f4:	08 95       	ret

000034f6 <Poll>:

void Poll(void)
{
	DDRD |= 0xF3;
    34f6:	8a b1       	in	r24, 0x0a	; 10
    34f8:	83 6f       	ori	r24, 0xF3	; 243
    34fa:	8a b9       	out	0x0a, r24	; 10
	//default states - bring low per controller state. 
	_low_state_portd_first =
	_low_state_portd_second=
	_low_state_portd_6button_First =
	_low_state_portd_6button_Second =
	_low_state_portd_6button_Second_Third =0xF3; 
    34fc:	83 ef       	ldi	r24, 0xF3	; 243
    34fe:	80 93 11 03 	sts	0x0311, r24

	//default states - bring low per controller state. 
	_low_state_portd_first =
	_low_state_portd_second=
	_low_state_portd_6button_First =
	_low_state_portd_6button_Second =
    3502:	80 93 12 03 	sts	0x0312, r24
	DDRD |= 0xF3;

	//default states - bring low per controller state. 
	_low_state_portd_first =
	_low_state_portd_second=
	_low_state_portd_6button_First =
    3506:	80 93 13 03 	sts	0x0313, r24
{
	DDRD |= 0xF3;

	//default states - bring low per controller state. 
	_low_state_portd_first =
	_low_state_portd_second=
    350a:	80 93 14 03 	sts	0x0314, r24
void Poll(void)
{
	DDRD |= 0xF3;

	//default states - bring low per controller state. 
	_low_state_portd_first =
    350e:	80 93 15 03 	sts	0x0315, r24
	_low_state_portd_6button_First =
	_low_state_portd_6button_Second =
	_low_state_portd_6button_Second_Third =0xF3; 
	
	//These are the only two that matter during the first pulse other then the detection. 
	if ( reportBuffer[BUTTON_ROW_1] & 0x20) _low_state_portd_first &= ~0x01;//Start
    3512:	80 91 68 03 	lds	r24, 0x0368
    3516:	85 ff       	sbrs	r24, 5
    3518:	03 c0       	rjmp	.+6      	; 0x3520 <Poll+0x2a>
    351a:	92 ef       	ldi	r25, 0xF2	; 242
    351c:	90 93 15 03 	sts	0x0315, r25
	if ( reportBuffer[BUTTON_ROW_1] & 0x01) _low_state_portd_first &= ~0x02;//A
    3520:	80 ff       	sbrs	r24, 0
    3522:	05 c0       	rjmp	.+10     	; 0x352e <Poll+0x38>
    3524:	90 91 15 03 	lds	r25, 0x0315
    3528:	9d 7f       	andi	r25, 0xFD	; 253
    352a:	90 93 15 03 	sts	0x0315, r25

	_low_state_portd_first &= ~0xc0; //controller detection.   
    352e:	90 91 15 03 	lds	r25, 0x0315
    3532:	9f 73       	andi	r25, 0x3F	; 63
    3534:	90 93 15 03 	sts	0x0315, r25

	// these needed to be put back to low, all other need to keep their states
	if ( reportBuffer[BUTTON_ROW_1] & 0x80) _low_state_portd_second &= ~0x01;  //C  now we go low...
    3538:	87 ff       	sbrs	r24, 7
    353a:	03 c0       	rjmp	.+6      	; 0x3542 <Poll+0x4c>
    353c:	92 ef       	ldi	r25, 0xF2	; 242
    353e:	90 93 14 03 	sts	0x0314, r25
	if ( reportBuffer[BUTTON_ROW_1] & 0x02) _low_state_portd_second &= ~0x02; //B  //
    3542:	81 ff       	sbrs	r24, 1
    3544:	05 c0       	rjmp	.+10     	; 0x3550 <Poll+0x5a>
    3546:	80 91 14 03 	lds	r24, 0x0314
    354a:	8d 7f       	andi	r24, 0xFD	; 253
    354c:	80 93 14 03 	sts	0x0314, r24

	con_anagloToDigital();
    3550:	0e 94 4c 09 	call	0x1298	; 0x1298 <con_anagloToDigital>
	
	//directions are like atari, once active keep line active, no pulsing. I'm not sure where sega checks it but it only works if it stays down.
	if ( reportBuffer[HAT] == DPAD_RIGHT || reportBuffer[HAT] == DPAD_DOWNRIGHT|| reportBuffer[HAT] == DPAD_UPRIGHT   ) {_low_state_portd_6button_Second_Third |= 0x80; _low_state_portd_first &= ~0x80; _low_state_portd_second  &= ~0x80; }
    3554:	80 91 6a 03 	lds	r24, 0x036A
    3558:	9f ef       	ldi	r25, 0xFF	; 255
    355a:	98 0f       	add	r25, r24
    355c:	93 30       	cpi	r25, 0x03	; 3
    355e:	78 f4       	brcc	.+30     	; 0x357e <Poll+0x88>
    3560:	90 91 11 03 	lds	r25, 0x0311
    3564:	90 68       	ori	r25, 0x80	; 128
    3566:	90 93 11 03 	sts	0x0311, r25
    356a:	90 91 15 03 	lds	r25, 0x0315
    356e:	9f 77       	andi	r25, 0x7F	; 127
    3570:	90 93 15 03 	sts	0x0315, r25
    3574:	90 91 14 03 	lds	r25, 0x0314
    3578:	9f 77       	andi	r25, 0x7F	; 127
    357a:	90 93 14 03 	sts	0x0314, r25
	if ( reportBuffer[HAT] == DPAD_LEFT  || reportBuffer[HAT] == DPAD_DOWNLEFT || reportBuffer[HAT] == DPAD_UPLEFT    ) {_low_state_portd_6button_Second_Third |= 0x40; _low_state_portd_first &= ~0x40; _low_state_portd_second  &= ~0x40; }
    357e:	9b ef       	ldi	r25, 0xFB	; 251
    3580:	98 0f       	add	r25, r24
    3582:	93 30       	cpi	r25, 0x03	; 3
    3584:	90 f4       	brcc	.+36     	; 0x35aa <Poll+0xb4>
    3586:	90 91 11 03 	lds	r25, 0x0311
    358a:	90 64       	ori	r25, 0x40	; 64
    358c:	90 93 11 03 	sts	0x0311, r25
    3590:	90 91 15 03 	lds	r25, 0x0315
    3594:	9f 7b       	andi	r25, 0xBF	; 191
    3596:	90 93 15 03 	sts	0x0315, r25
    359a:	90 91 14 03 	lds	r25, 0x0314
    359e:	9f 7b       	andi	r25, 0xBF	; 191
    35a0:	90 93 14 03 	sts	0x0314, r25
	if ( reportBuffer[HAT] == DPAD_UP    || reportBuffer[HAT] == DPAD_UPLEFT   || reportBuffer[HAT] == DPAD_UPRIGHT   ) {_low_state_portd_6button_Second_Third |= 0x10; _low_state_portd_first &= ~0x10; _low_state_portd_second  &= ~0x10; }
    35a4:	87 30       	cpi	r24, 0x07	; 7
    35a6:	99 f4       	brne	.+38     	; 0x35ce <Poll+0xd8>
    35a8:	02 c0       	rjmp	.+4      	; 0x35ae <Poll+0xb8>
    35aa:	81 11       	cpse	r24, r1
    35ac:	10 c0       	rjmp	.+32     	; 0x35ce <Poll+0xd8>
    35ae:	90 91 11 03 	lds	r25, 0x0311
    35b2:	90 61       	ori	r25, 0x10	; 16
    35b4:	90 93 11 03 	sts	0x0311, r25
    35b8:	90 91 15 03 	lds	r25, 0x0315
    35bc:	9f 7e       	andi	r25, 0xEF	; 239
    35be:	90 93 15 03 	sts	0x0315, r25
    35c2:	90 91 14 03 	lds	r25, 0x0314
    35c6:	9f 7e       	andi	r25, 0xEF	; 239
    35c8:	90 93 14 03 	sts	0x0314, r25
    35cc:	02 c0       	rjmp	.+4      	; 0x35d2 <Poll+0xdc>
    35ce:	81 30       	cpi	r24, 0x01	; 1
    35d0:	71 f3       	breq	.-36     	; 0x35ae <Poll+0xb8>
	if ( reportBuffer[HAT] == DPAD_DOWN  || reportBuffer[HAT] == DPAD_DOWNLEFT || reportBuffer[HAT] == DPAD_DOWNRIGHT ) {_low_state_portd_6button_Second_Third |= 0x20; _low_state_portd_first &= ~0x20; _low_state_portd_second  &= ~0x20; }
    35d2:	83 50       	subi	r24, 0x03	; 3
    35d4:	83 30       	cpi	r24, 0x03	; 3
    35d6:	78 f4       	brcc	.+30     	; 0x35f6 <Poll+0x100>
    35d8:	80 91 11 03 	lds	r24, 0x0311
    35dc:	80 62       	ori	r24, 0x20	; 32
    35de:	80 93 11 03 	sts	0x0311, r24
    35e2:	80 91 15 03 	lds	r24, 0x0315
    35e6:	8f 7d       	andi	r24, 0xDF	; 223
    35e8:	80 93 15 03 	sts	0x0315, r24
    35ec:	80 91 14 03 	lds	r24, 0x0314
    35f0:	8f 7d       	andi	r24, 0xDF	; 223
    35f2:	80 93 14 03 	sts	0x0314, r24


	if ( reportBuffer[BUTTON_ROW_1] & 0x40) _low_state_portd_6button_Second  &= ~0x10;//z
    35f6:	80 91 68 03 	lds	r24, 0x0368
    35fa:	86 ff       	sbrs	r24, 6
    35fc:	05 c0       	rjmp	.+10     	; 0x3608 <Poll+0x112>
    35fe:	90 91 12 03 	lds	r25, 0x0312
    3602:	9f 7e       	andi	r25, 0xEF	; 239
    3604:	90 93 12 03 	sts	0x0312, r25
	if ( reportBuffer[BUTTON_ROW_1] & 0x08) _low_state_portd_6button_Second  &= ~0x20;//y
    3608:	83 ff       	sbrs	r24, 3
    360a:	05 c0       	rjmp	.+10     	; 0x3616 <Poll+0x120>
    360c:	90 91 12 03 	lds	r25, 0x0312
    3610:	9f 7d       	andi	r25, 0xDF	; 223
    3612:	90 93 12 03 	sts	0x0312, r25
	if ( reportBuffer[BUTTON_ROW_1] & 0x04) _low_state_portd_6button_Second  &= ~0x40;//x
    3616:	82 ff       	sbrs	r24, 2
    3618:	05 c0       	rjmp	.+10     	; 0x3624 <Poll+0x12e>
    361a:	90 91 12 03 	lds	r25, 0x0312
    361e:	9f 7b       	andi	r25, 0xBF	; 191
    3620:	90 93 12 03 	sts	0x0312, r25
	if ( reportBuffer[BUTTON_ROW_1] & 0x10) _low_state_portd_6button_Second  &= ~0x80;//mode
    3624:	84 ff       	sbrs	r24, 4
    3626:	05 c0       	rjmp	.+10     	; 0x3632 <Poll+0x13c>
    3628:	80 91 12 03 	lds	r24, 0x0312
    362c:	8f 77       	andi	r24, 0x7F	; 127
    362e:	80 93 12 03 	sts	0x0312, r24
//if below is needed 
//OCR1AL=255;	OCR1AH=0; //set to 16 ms. 
	
	//reverse mode..
	if ( (PULSE_PIN & PULSE) == 0 ) 
    3632:	36 99       	sbic	0x06, 6	; 6
    3634:	0a c0       	rjmp	.+20     	; 0x364a <Poll+0x154>
	{//_____|```|______
		if ( pinChange( line_low,  _low_state_portd_second)) return; //no reply, refresh data and come back in.
    3636:	60 91 14 03 	lds	r22, 0x0314
    363a:	80 e0       	ldi	r24, 0x00	; 0
    363c:	27 df       	rcall	.-434    	; 0x348c <pinChange>
    363e:	81 11       	cpse	r24, r1
    3640:	0d c0       	rjmp	.+26     	; 0x365c <Poll+0x166>
    3642:	60 91 15 03 	lds	r22, 0x0315
//this could be used but is not needed currently		
//OCR1AL=1;	OCR1AH=0; //set to 175 us. 
		
		if ( pinChange( line_high,  _low_state_portd_first)) return;  //no reply, refresh data and come back in.
    3646:	81 e0       	ldi	r24, 0x01	; 1
    3648:	08 c0       	rjmp	.+16     	; 0x365a <Poll+0x164>
    364a:	60 91 15 03 	lds	r22, 0x0315

	}
	else 
	{//`````|___|``````
	
		if ( pinChange( line_high,  _low_state_portd_first)) return;  //no reply, refresh data and come back in.
    364e:	81 e0       	ldi	r24, 0x01	; 1
    3650:	1d df       	rcall	.-454    	; 0x348c <pinChange>
    3652:	81 11       	cpse	r24, r1
    3654:	03 c0       	rjmp	.+6      	; 0x365c <Poll+0x166>
    3656:	60 91 14 03 	lds	r22, 0x0314
//this could be used but is not needed currently		
//OCR1AL=1;	OCR1AH=0; //set to 175 us. 
		
		if ( pinChange( line_low ,  _low_state_portd_second)) return;  //no reply, refresh data and come back in.
    365a:	18 cf       	rjmp	.-464    	; 0x348c <pinChange>
    365c:	08 95       	ret

0000365e <Update>:
    365e:	4b cf       	rjmp	.-362    	; 0x34f6 <Poll>

00003660 <genGetConsole>:
    3660:	8e e4       	ldi	r24, 0x4E	; 78
    3662:	91 e0       	ldi	r25, 0x01	; 1
};

ConsoleFound *genGetConsole(void)
{
	return &GEN_Console;
}
    3664:	08 95       	ret

00003666 <doWork>:
 
/*********** prototypes *************/
static void Init(void);
static void Update(void);
static unsigned char Probe(void);
static void doWork(void){};
    3666:	08 95       	ret

00003668 <Init>:
static unsigned char MODE;
static unsigned char MOUSE_CHECK;

void Init(void)
{
	MOUSE_CHECK=0;
    3668:	10 92 18 03 	sts	0x0318, r1
	MODE = pad_cnt;
    366c:	81 e0       	ldi	r24, 0x01	; 1
    366e:	80 93 19 03 	sts	0x0319, r24
	DDRD &= ~0x80;// in
    3672:	57 98       	cbi	0x0a, 7	; 10
	DDRD &= ~0x40;// in
    3674:	56 98       	cbi	0x0a, 6	; 10
	DDRD &= ~0x30;// will be our out but keep it in for now
    3676:	8a b1       	in	r24, 0x0a	; 10
    3678:	8f 7c       	andi	r24, 0xCF	; 207
    367a:	8a b9       	out	0x0a, r24	; 10
	DDRC &= ~0x40;// extra data
    367c:	3e 98       	cbi	0x07, 6	; 7
	PORTD |= 0x40;// latch
    367e:	5e 9a       	sbi	0x0b, 6	; 11
	PORTD |= 0x80;// clock
    3680:	5f 9a       	sbi	0x0b, 7	; 11
	PORTD |= 0x30;// data
    3682:	8b b1       	in	r24, 0x0b	; 11
    3684:	80 63       	ori	r24, 0x30	; 48
    3686:	8b b9       	out	0x0b, r24	; 11
	PORTC |= 0x40;// extra data
    3688:	46 9a       	sbi	0x08, 6	; 8
    368a:	08 95       	ret

0000368c <CleanUp>:
}
void CleanUp(void)
{
    368c:	08 95       	ret

0000368e <Probe>:
}
 unsigned char Probe(void)
{
	unsigned char type=0;
	int   timer = 1; 
	WHILE_LATCH_IS_LO
    368e:	4e 9b       	sbis	0x09, 6	; 9
    3690:	fe cf       	rjmp	.-4      	; 0x368e <Probe>
    3692:	8f ec       	ldi	r24, 0xCF	; 207
    3694:	97 e0       	ldi	r25, 0x07	; 7
    3696:	01 97       	sbiw	r24, 0x01	; 1
    3698:	f1 f7       	brne	.-4      	; 0x3696 <Probe+0x8>
    369a:	00 c0       	rjmp	.+0      	; 0x369c <Probe+0xe>
    369c:	00 00       	nop
	if (timer==MAX_TIME) return 0;
	_delay_us(500);//move out of data transition
		
	//now test to make sure we hit an ok spot
	//clock lo                latch hi
	if ((PIND & CLOCK)==0x00 || (PIND & LATCH)==0x40) return 0;//wrong condition.
    369e:	4f 9b       	sbis	0x09, 7	; 9
    36a0:	14 c0       	rjmp	.+40     	; 0x36ca <Probe+0x3c>
    36a2:	4e 99       	sbic	0x09, 6	; 9
    36a4:	12 c0       	rjmp	.+36     	; 0x36ca <Probe+0x3c>

	//now sync at the beginning
	timer = 1;	
	WHILE_LATCH_IS_LO
    36a6:	4e 9b       	sbis	0x09, 6	; 9
    36a8:	fe cf       	rjmp	.-4      	; 0x36a6 <Probe+0x18>
	if (timer==MAX_TIME) return 0;
	
	//move to end of latch		
	timer = 1;
	WHILE_CLOCK_IS_HI 
    36aa:	4f 99       	sbic	0x09, 7	; 9
    36ac:	fe cf       	rjmp	.-4      	; 0x36aa <Probe+0x1c>
    36ae:	8f e8       	ldi	r24, 0x8F	; 143
    36b0:	91 e0       	ldi	r25, 0x01	; 1
    36b2:	01 97       	sbiw	r24, 0x01	; 1
    36b4:	f1 f7       	brne	.-4      	; 0x36b2 <Probe+0x24>
    36b6:	00 c0       	rjmp	.+0      	; 0x36b8 <Probe+0x2a>
    36b8:	00 00       	nop
    _delay_us(100); 
	if ((PIND & CLOCK)==0x00)  type =  SNES;//if its low here  its a SNES 
    36ba:	4f 9b       	sbis	0x09, 7	; 9
    36bc:	02 c0       	rjmp	.+4      	; 0x36c2 <Probe+0x34>
		WHILE_LATCH_IS_LO_1MS 
	}
}
 unsigned char Probe(void)
{
	unsigned char type=0;
    36be:	80 e0       	ldi	r24, 0x00	; 0
    36c0:	01 c0       	rjmp	.+2      	; 0x36c4 <Probe+0x36>
	
	//move to end of latch		
	timer = 1;
	WHILE_CLOCK_IS_HI 
    _delay_us(100); 
	if ((PIND & CLOCK)==0x00)  type =  SNES;//if its low here  its a SNES 
    36c2:	8f e2       	ldi	r24, 0x2F	; 47
	if ((PIND & CLOCK)==CLOCK) type = NES;//if its hi here  its a NES 
    36c4:	4f 99       	sbic	0x09, 7	; 9
    36c6:	03 c0       	rjmp	.+6      	; 0x36ce <Probe+0x40>
    36c8:	08 95       	ret
	if (timer==MAX_TIME) return 0;
	_delay_us(500);//move out of data transition
		
	//now test to make sure we hit an ok spot
	//clock lo                latch hi
	if ((PIND & CLOCK)==0x00 || (PIND & LATCH)==0x40) return 0;//wrong condition.
    36ca:	80 e0       	ldi	r24, 0x00	; 0
    36cc:	08 95       	ret
	//move to end of latch		
	timer = 1;
	WHILE_CLOCK_IS_HI 
    _delay_us(100); 
	if ((PIND & CLOCK)==0x00)  type =  SNES;//if its low here  its a SNES 
	if ((PIND & CLOCK)==CLOCK) type = NES;//if its hi here  its a NES 
    36ce:	81 e2       	ldi	r24, 0x21	; 33
	//TODO VB
	if (timer==MAX_TIME) return 0; else return type ;

} 
    36d0:	08 95       	ret

000036d2 <shiftOut>:
	_delay_us(50);//finish waveform

}

void shiftOut( bool _short)
{
    36d2:	ef 92       	push	r14
    36d4:	ff 92       	push	r15
    36d6:	0f 93       	push	r16
    36d8:	1f 93       	push	r17
    36da:	cf 93       	push	r28
    36dc:	df 93       	push	r29
    36de:	1f 92       	push	r1
    36e0:	cd b7       	in	r28, 0x3d	; 61
    36e2:	de b7       	in	r29, 0x3e	; 62
	unsigned int timer=1;
	int AUX1Buffer=0,AUX2Buffer=0;
	int mouse_data=0;
	bool readStickRight=0;
	
	if (Console.Type  == NES || Console.Type  == SNES ) con_anagloToDigital();//let analogs controler d-pad, good idea? - Intest
    36e4:	90 91 65 03 	lds	r25, 0x0365
    36e8:	91 32       	cpi	r25, 0x21	; 33
    36ea:	11 f0       	breq	.+4      	; 0x36f0 <shiftOut+0x1e>
    36ec:	9f 32       	cpi	r25, 0x2F	; 47
    36ee:	39 f4       	brne	.+14     	; 0x36fe <shiftOut+0x2c>
    36f0:	89 83       	std	Y+1, r24	; 0x01
    36f2:	0e 94 4c 09 	call	0x1298	; 0x1298 <con_anagloToDigital>
}

void shiftOut( bool _short)
{
	//a,b,s,s,u,d,l,r
	int buttonBuffer = 0;
    36f6:	20 e0       	ldi	r18, 0x00	; 0
    36f8:	30 e0       	ldi	r19, 0x00	; 0
	unsigned int timer=1;
	int AUX1Buffer=0,AUX2Buffer=0;
	int mouse_data=0;
	bool readStickRight=0;
	
	if (Console.Type  == NES || Console.Type  == SNES ) con_anagloToDigital();//let analogs controler d-pad, good idea? - Intest
    36fa:	89 81       	ldd	r24, Y+1	; 0x01
    36fc:	62 c0       	rjmp	.+196    	; 0x37c2 <shiftOut+0xf0>
	else if (Console.Type  == V_BOY )
    36fe:	9f 31       	cpi	r25, 0x1F	; 31
    3700:	09 f0       	breq	.+2      	; 0x3704 <shiftOut+0x32>
    3702:	4b c0       	rjmp	.+150    	; 0x379a <shiftOut+0xc8>
	{
			 if ( L_ANALOG_UP   && L_ANALOG_LEFT ) reportBuffer[HAT] = DPAD_UPLEFT; 
    3704:	20 91 6c 03 	lds	r18, 0x036C
    3708:	90 91 6b 03 	lds	r25, 0x036B
    370c:	2e 34       	cpi	r18, 0x4E	; 78
    370e:	20 f4       	brcc	.+8      	; 0x3718 <shiftOut+0x46>
    3710:	9e 34       	cpi	r25, 0x4E	; 78
    3712:	40 f4       	brcc	.+16     	; 0x3724 <shiftOut+0x52>
    3714:	97 e0       	ldi	r25, 0x07	; 7
    3716:	1e c0       	rjmp	.+60     	; 0x3754 <shiftOut+0x82>
		else if ( L_ANALOG_DOWN && L_ANALOG_LEFT ) reportBuffer[HAT] = DPAD_DOWNLEFT; 
    3718:	23 3b       	cpi	r18, 0xB3	; 179
    371a:	60 f0       	brcs	.+24     	; 0x3734 <shiftOut+0x62>
    371c:	9e 34       	cpi	r25, 0x4E	; 78
    371e:	30 f4       	brcc	.+12     	; 0x372c <shiftOut+0x5a>
    3720:	95 e0       	ldi	r25, 0x05	; 5
    3722:	18 c0       	rjmp	.+48     	; 0x3754 <shiftOut+0x82>
		else if ( L_ANALOG_UP   && L_ANALOG_RIGHT) reportBuffer[HAT] = DPAD_UPRIGHT; 
    3724:	93 3b       	cpi	r25, 0xB3	; 179
    3726:	30 f0       	brcs	.+12     	; 0x3734 <shiftOut+0x62>
    3728:	91 e0       	ldi	r25, 0x01	; 1
    372a:	14 c0       	rjmp	.+40     	; 0x3754 <shiftOut+0x82>
		else if ( L_ANALOG_DOWN && L_ANALOG_RIGHT) reportBuffer[HAT] = DPAD_DOWNRIGHT; 
    372c:	93 3b       	cpi	r25, 0xB3	; 179
    372e:	10 f0       	brcs	.+4      	; 0x3734 <shiftOut+0x62>
    3730:	93 e0       	ldi	r25, 0x03	; 3
    3732:	10 c0       	rjmp	.+32     	; 0x3754 <shiftOut+0x82>
		else if	( L_ANALOG_LEFT 				)  reportBuffer[HAT] = DPAD_LEFT;
    3734:	9e 34       	cpi	r25, 0x4E	; 78
    3736:	10 f4       	brcc	.+4      	; 0x373c <shiftOut+0x6a>
    3738:	96 e0       	ldi	r25, 0x06	; 6
    373a:	0c c0       	rjmp	.+24     	; 0x3754 <shiftOut+0x82>
		else if ( L_ANALOG_RIGHT 				)  reportBuffer[HAT] = DPAD_RIGHT;
    373c:	93 3b       	cpi	r25, 0xB3	; 179
    373e:	10 f0       	brcs	.+4      	; 0x3744 <shiftOut+0x72>
    3740:	92 e0       	ldi	r25, 0x02	; 2
    3742:	08 c0       	rjmp	.+16     	; 0x3754 <shiftOut+0x82>
		else if ( L_ANALOG_UP 					)  reportBuffer[HAT] = DPAD_UP;
    3744:	2e 34       	cpi	r18, 0x4E	; 78
    3746:	18 f4       	brcc	.+6      	; 0x374e <shiftOut+0x7c>
    3748:	10 92 6a 03 	sts	0x036A, r1
    374c:	05 c0       	rjmp	.+10     	; 0x3758 <shiftOut+0x86>
		else if ( L_ANALOG_DOWN 				)  reportBuffer[HAT] = DPAD_DOWN;
    374e:	23 3b       	cpi	r18, 0xB3	; 179
    3750:	18 f0       	brcs	.+6      	; 0x3758 <shiftOut+0x86>
    3752:	94 e0       	ldi	r25, 0x04	; 4
    3754:	90 93 6a 03 	sts	0x036A, r25
		
			 if ( R_ANALOG_UP   && R_ANALOG_LEFT ) buttonBuffer = 0x22; 
    3758:	20 91 6e 03 	lds	r18, 0x036E
    375c:	90 91 6d 03 	lds	r25, 0x036D
    3760:	2e 34       	cpi	r18, 0x4E	; 78
    3762:	18 f4       	brcc	.+6      	; 0x376a <shiftOut+0x98>
    3764:	9e 34       	cpi	r25, 0x4E	; 78
    3766:	e0 f0       	brcs	.+56     	; 0x37a0 <shiftOut+0xce>
    3768:	05 c0       	rjmp	.+10     	; 0x3774 <shiftOut+0xa2>
		else if ( R_ANALOG_DOWN && R_ANALOG_LEFT ) buttonBuffer = 0x03; 
    376a:	23 3b       	cpi	r18, 0xB3	; 179
    376c:	40 f0       	brcs	.+16     	; 0x377e <shiftOut+0xac>
    376e:	9e 34       	cpi	r25, 0x4E	; 78
    3770:	d0 f0       	brcs	.+52     	; 0x37a6 <shiftOut+0xd4>
    3772:	03 c0       	rjmp	.+6      	; 0x377a <shiftOut+0xa8>
		else if ( R_ANALOG_UP   && R_ANALOG_RIGHT) buttonBuffer = 0x30; 
    3774:	93 3b       	cpi	r25, 0xB3	; 179
    3776:	18 f5       	brcc	.+70     	; 0x37be <shiftOut+0xec>
    3778:	02 c0       	rjmp	.+4      	; 0x377e <shiftOut+0xac>
		else if ( R_ANALOG_DOWN && R_ANALOG_RIGHT) buttonBuffer = 0x11; 
    377a:	93 3b       	cpi	r25, 0xB3	; 179
    377c:	b8 f4       	brcc	.+46     	; 0x37ac <shiftOut+0xda>
		else if	( R_ANALOG_LEFT 				)  buttonBuffer = 0x02;
    377e:	9e 34       	cpi	r25, 0x4E	; 78
    3780:	c0 f0       	brcs	.+48     	; 0x37b2 <shiftOut+0xe0>
		else if ( R_ANALOG_RIGHT 				)  buttonBuffer = 0x10;
    3782:	93 3b       	cpi	r25, 0xB3	; 179
    3784:	c8 f4       	brcc	.+50     	; 0x37b8 <shiftOut+0xe6>
		else if ( R_ANALOG_UP 					)  buttonBuffer = 0x30;
    3786:	2e 34       	cpi	r18, 0x4E	; 78
    3788:	d0 f0       	brcs	.+52     	; 0x37be <shiftOut+0xec>
		else if ( R_ANALOG_DOWN 				)  buttonBuffer = 0x01;
    378a:	41 e0       	ldi	r20, 0x01	; 1
    378c:	90 e0       	ldi	r25, 0x00	; 0
    378e:	23 3b       	cpi	r18, 0xB3	; 179
    3790:	08 f4       	brcc	.+2      	; 0x3794 <shiftOut+0xc2>
    3792:	40 e0       	ldi	r20, 0x00	; 0
}

void shiftOut( bool _short)
{
	//a,b,s,s,u,d,l,r
	int buttonBuffer = 0;
    3794:	24 2f       	mov	r18, r20
    3796:	39 2f       	mov	r19, r25
    3798:	14 c0       	rjmp	.+40     	; 0x37c2 <shiftOut+0xf0>
    379a:	20 e0       	ldi	r18, 0x00	; 0
    379c:	30 e0       	ldi	r19, 0x00	; 0
    379e:	11 c0       	rjmp	.+34     	; 0x37c2 <shiftOut+0xf0>
		else if	( L_ANALOG_LEFT 				)  reportBuffer[HAT] = DPAD_LEFT;
		else if ( L_ANALOG_RIGHT 				)  reportBuffer[HAT] = DPAD_RIGHT;
		else if ( L_ANALOG_UP 					)  reportBuffer[HAT] = DPAD_UP;
		else if ( L_ANALOG_DOWN 				)  reportBuffer[HAT] = DPAD_DOWN;
		
			 if ( R_ANALOG_UP   && R_ANALOG_LEFT ) buttonBuffer = 0x22; 
    37a0:	22 e2       	ldi	r18, 0x22	; 34
    37a2:	30 e0       	ldi	r19, 0x00	; 0
    37a4:	0e c0       	rjmp	.+28     	; 0x37c2 <shiftOut+0xf0>
		else if ( R_ANALOG_DOWN && R_ANALOG_LEFT ) buttonBuffer = 0x03; 
    37a6:	23 e0       	ldi	r18, 0x03	; 3
    37a8:	30 e0       	ldi	r19, 0x00	; 0
    37aa:	0b c0       	rjmp	.+22     	; 0x37c2 <shiftOut+0xf0>
		else if ( R_ANALOG_UP   && R_ANALOG_RIGHT) buttonBuffer = 0x30; 
		else if ( R_ANALOG_DOWN && R_ANALOG_RIGHT) buttonBuffer = 0x11; 
    37ac:	21 e1       	ldi	r18, 0x11	; 17
    37ae:	30 e0       	ldi	r19, 0x00	; 0
    37b0:	08 c0       	rjmp	.+16     	; 0x37c2 <shiftOut+0xf0>
		else if	( R_ANALOG_LEFT 				)  buttonBuffer = 0x02;
    37b2:	22 e0       	ldi	r18, 0x02	; 2
    37b4:	30 e0       	ldi	r19, 0x00	; 0
    37b6:	05 c0       	rjmp	.+10     	; 0x37c2 <shiftOut+0xf0>
		else if ( R_ANALOG_RIGHT 				)  buttonBuffer = 0x10;
    37b8:	20 e1       	ldi	r18, 0x10	; 16
    37ba:	30 e0       	ldi	r19, 0x00	; 0
    37bc:	02 c0       	rjmp	.+4      	; 0x37c2 <shiftOut+0xf0>
		else if ( L_ANALOG_UP 					)  reportBuffer[HAT] = DPAD_UP;
		else if ( L_ANALOG_DOWN 				)  reportBuffer[HAT] = DPAD_DOWN;
		
			 if ( R_ANALOG_UP   && R_ANALOG_LEFT ) buttonBuffer = 0x22; 
		else if ( R_ANALOG_DOWN && R_ANALOG_LEFT ) buttonBuffer = 0x03; 
		else if ( R_ANALOG_UP   && R_ANALOG_RIGHT) buttonBuffer = 0x30; 
    37be:	20 e3       	ldi	r18, 0x30	; 48
    37c0:	30 e0       	ldi	r19, 0x00	; 0
		else if ( R_ANALOG_RIGHT 				)  buttonBuffer = 0x10;
		else if ( R_ANALOG_UP 					)  buttonBuffer = 0x30;
		else if ( R_ANALOG_DOWN 				)  buttonBuffer = 0x01;
	}
	//map buttons to buffer
	if (reportBuffer[HAT] == DPAD_UP	   )buttonBuffer |= 0x10;
    37c2:	90 91 6a 03 	lds	r25, 0x036A
    37c6:	91 11       	cpse	r25, r1
    37c8:	02 c0       	rjmp	.+4      	; 0x37ce <shiftOut+0xfc>
    37ca:	20 61       	ori	r18, 0x10	; 16
    37cc:	1b c0       	rjmp	.+54     	; 0x3804 <shiftOut+0x132>
	if (reportBuffer[HAT] == DPAD_DOWN	   )buttonBuffer |= 0x20;
    37ce:	94 30       	cpi	r25, 0x04	; 4
    37d0:	11 f4       	brne	.+4      	; 0x37d6 <shiftOut+0x104>
    37d2:	20 62       	ori	r18, 0x20	; 32
    37d4:	17 c0       	rjmp	.+46     	; 0x3804 <shiftOut+0x132>
	if (reportBuffer[HAT] == DPAD_LEFT	   )buttonBuffer |= 0x40;
    37d6:	96 30       	cpi	r25, 0x06	; 6
    37d8:	11 f4       	brne	.+4      	; 0x37de <shiftOut+0x10c>
    37da:	20 64       	ori	r18, 0x40	; 64
    37dc:	13 c0       	rjmp	.+38     	; 0x3804 <shiftOut+0x132>
	if (reportBuffer[HAT] == DPAD_RIGHT	   )buttonBuffer |= 0x80;
    37de:	92 30       	cpi	r25, 0x02	; 2
    37e0:	11 f4       	brne	.+4      	; 0x37e6 <shiftOut+0x114>
    37e2:	20 68       	ori	r18, 0x80	; 128
    37e4:	0f c0       	rjmp	.+30     	; 0x3804 <shiftOut+0x132>
	if (reportBuffer[HAT] == DPAD_UPLEFT   )buttonBuffer |= 0x50;
    37e6:	97 30       	cpi	r25, 0x07	; 7
    37e8:	11 f4       	brne	.+4      	; 0x37ee <shiftOut+0x11c>
    37ea:	20 65       	ori	r18, 0x50	; 80
    37ec:	0b c0       	rjmp	.+22     	; 0x3804 <shiftOut+0x132>
	if (reportBuffer[HAT] == DPAD_DOWNLEFT )buttonBuffer |= 0x60;
    37ee:	95 30       	cpi	r25, 0x05	; 5
    37f0:	11 f4       	brne	.+4      	; 0x37f6 <shiftOut+0x124>
    37f2:	20 66       	ori	r18, 0x60	; 96
    37f4:	07 c0       	rjmp	.+14     	; 0x3804 <shiftOut+0x132>
	if (reportBuffer[HAT] == DPAD_UPRIGHT  )buttonBuffer |= 0x90;
    37f6:	91 30       	cpi	r25, 0x01	; 1
    37f8:	11 f4       	brne	.+4      	; 0x37fe <shiftOut+0x12c>
    37fa:	20 69       	ori	r18, 0x90	; 144
    37fc:	03 c0       	rjmp	.+6      	; 0x3804 <shiftOut+0x132>
	if (reportBuffer[HAT] == DPAD_DOWNRIGHT)buttonBuffer |= 0xA0;
    37fe:	93 30       	cpi	r25, 0x03	; 3
    3800:	09 f4       	brne	.+2      	; 0x3804 <shiftOut+0x132>
    3802:	20 6a       	ori	r18, 0xA0	; 160
	if (reportBuffer[BUTTON_ROW_1] & 0x20)  buttonBuffer |= 0x08;	//start
    3804:	90 91 68 03 	lds	r25, 0x0368
    3808:	95 fd       	sbrc	r25, 5
    380a:	28 60       	ori	r18, 0x08	; 8
	if (reportBuffer[BUTTON_ROW_1] & 0x10)  buttonBuffer |= 0x04;	//select
    380c:	94 fd       	sbrc	r25, 4
    380e:	24 60       	ori	r18, 0x04	; 4
	
	if (Console.Type  == NES)
    3810:	40 91 65 03 	lds	r20, 0x0365
    3814:	41 32       	cpi	r20, 0x21	; 33
    3816:	a9 f5       	brne	.+106    	; 0x3882 <shiftOut+0x1b0>
	{
		if (reportBuffer[BUTTON_ROW_1] & 0x02)  buttonBuffer |= 0x01;	//A
    3818:	91 fd       	sbrc	r25, 1
    381a:	21 60       	ori	r18, 0x01	; 1
		if (reportBuffer[BUTTON_ROW_1] & 0x01)  buttonBuffer |= 0x02;	//B
    381c:	90 fd       	sbrc	r25, 0
    381e:	22 60       	ori	r18, 0x02	; 2

		
		/////////////////////////////
		// Support for other types //
		/////////////////////////////	
		if      (reportBuffer[DIAL] > 0)   AUX2Buffer = reportBuffer[DIAL]  ;
    3820:	40 91 6f 03 	lds	r20, 0x036F
    3824:	41 11       	cpse	r20, r1
    3826:	0f c0       	rjmp	.+30     	; 0x3846 <shiftOut+0x174>
		else if (reportBuffer[SLIDER] > 0) AUX2Buffer = reportBuffer[SLIDER]  ;
    3828:	40 91 70 03 	lds	r20, 0x0370
    382c:	41 11       	cpse	r20, r1
    382e:	0b c0       	rjmp	.+22     	; 0x3846 <shiftOut+0x174>
		else if ( !Controller.DpadOnly )   AUX2Buffer =reportBuffer[X_MAIN_STICK];
    3830:	40 91 83 03 	lds	r20, 0x0383
    3834:	41 11       	cpse	r20, r1
    3836:	a1 c1       	rjmp	.+834    	; 0x3b7a <shiftOut+0x4a8>
    3838:	40 91 6b 03 	lds	r20, 0x036B
    383c:	50 e0       	ldi	r21, 0x00	; 0
		
		//ark and gun use this as a pin not as data, so its 0 or 0xff in some cases test bot both 1,2 buttons
		if ( AUX2Buffer )
    383e:	41 15       	cp	r20, r1
    3840:	51 05       	cpc	r21, r1
    3842:	09 f4       	brne	.+2      	; 0x3846 <shiftOut+0x174>
    3844:	97 c1       	rjmp	.+814    	; 0x3b74 <shiftOut+0x4a2>
		{
			if (  reportBuffer[BUTTON_ROW_1] & 0x03)  AUX1Buffer = 0; else AUX1Buffer = 0xffff; //if we see analog data, and we pressed a button
    3846:	93 70       	andi	r25, 0x03	; 3
    3848:	61 e0       	ldi	r22, 0x01	; 1
    384a:	70 e0       	ldi	r23, 0x00	; 0
    384c:	11 f0       	breq	.+4      	; 0x3852 <shiftOut+0x180>
    384e:	60 e0       	ldi	r22, 0x00	; 0
    3850:	70 e0       	ldi	r23, 0x00	; 0
    3852:	71 95       	neg	r23
    3854:	61 95       	neg	r22
    3856:	71 09       	sbc	r23, r1
			AUX2Buffer = __builtin_avr_insert_bits(0x01234567,(AUX2Buffer^ 0xff)-30,0);//invert and push, so we can reach the edge. 
    3858:	91 ee       	ldi	r25, 0xE1	; 225
    385a:	94 1b       	sub	r25, r20
    385c:	99 0f       	add	r25, r25
    385e:	91 1d       	adc	r25, r1
    3860:	49 2f       	mov	r20, r25
    3862:	91 fb       	bst	r25, 1
    3864:	47 f9       	bld	r20, 7
    3866:	92 fb       	bst	r25, 2
    3868:	46 f9       	bld	r20, 6
    386a:	93 fb       	bst	r25, 3
    386c:	45 f9       	bld	r20, 5
    386e:	95 fb       	bst	r25, 5
    3870:	43 f9       	bld	r20, 3
    3872:	96 fb       	bst	r25, 6
    3874:	42 f9       	bld	r20, 2
    3876:	97 fb       	bst	r25, 7
    3878:	41 f9       	bld	r20, 1
    387a:	50 e0       	ldi	r21, 0x00	; 0
{
	//a,b,s,s,u,d,l,r
	int buttonBuffer = 0;
	unsigned int timer=1;
	int AUX1Buffer=0,AUX2Buffer=0;
	int mouse_data=0;
    387c:	e0 e0       	ldi	r30, 0x00	; 0
    387e:	f0 e0       	ldi	r31, 0x00	; 0
    3880:	82 c1       	rjmp	.+772    	; 0x3b86 <shiftOut+0x4b4>
			AUX2Buffer = __builtin_avr_insert_bits(0x01234567,(AUX2Buffer^ 0xff)-30,0);//invert and push, so we can reach the edge. 
		}
		//gun - gun tech are not all the same, no value here.
		//pad - and use what. ddrs? its not using the same buttons.
	}
	else if (Console.Type  == V_BOY)
    3882:	4f 31       	cpi	r20, 0x1F	; 31
    3884:	b1 f4       	brne	.+44     	; 0x38b2 <shiftOut+0x1e0>
			13 - A                            0
			14 - Always 1                     0
			15 - Battery voltage;             0
			*/
			
		if (reportBuffer[BUTTON_ROW_1] & 0x01)  buttonBuffer |= 0x1000;	//to VB B
    3886:	90 fd       	sbrc	r25, 0
    3888:	30 61       	ori	r19, 0x10	; 16
		if (reportBuffer[BUTTON_ROW_1] & 0x02)  buttonBuffer |= 0x2000;	//to VB A
    388a:	91 fd       	sbrc	r25, 1
    388c:	30 62       	ori	r19, 0x20	; 32
		if (reportBuffer[BUTTON_ROW_1] & 0x04)  buttonBuffer |=   0x02;	//to VB L
    388e:	59 2f       	mov	r21, r25
    3890:	54 70       	andi	r21, 0x04	; 4
    3892:	92 fd       	sbrc	r25, 2
    3894:	22 60       	ori	r18, 0x02	; 2
		if (reportBuffer[BUTTON_ROW_1] & 0x08)  buttonBuffer |=   0x01;	//to VB D
    3896:	49 2f       	mov	r20, r25
    3898:	48 70       	andi	r20, 0x08	; 8
    389a:	93 fd       	sbrc	r25, 3
    389c:	21 60       	ori	r18, 0x01	; 1
		if (reportBuffer[BUTTON_ROW_1] & 0x04)  buttonBuffer |=  0x200;	//to VB U
    389e:	51 11       	cpse	r21, r1
    38a0:	32 60       	ori	r19, 0x02	; 2
		if (reportBuffer[BUTTON_ROW_1] & 0x08)  buttonBuffer |=  0x100;	//to VB R
    38a2:	41 11       	cpse	r20, r1
    38a4:	31 60       	ori	r19, 0x01	; 1
		if (reportBuffer[BUTTON_ROW_1] & 0x40)  buttonBuffer |=  0x400;	//L (same as snes)
    38a6:	96 fd       	sbrc	r25, 6
    38a8:	34 60       	ori	r19, 0x04	; 4
		if (reportBuffer[BUTTON_ROW_1] & 0x80)  buttonBuffer |=  0x800;	//R (same as snes)
    38aa:	97 fd       	sbrc	r25, 7
    38ac:	38 60       	ori	r19, 0x08	; 8
		
		//alalogs mapped from above. 
	
		//VB controller right pad is not OEM so mapping is needed here. 
		 buttonBuffer |= 0x4000; //VB key always on 
		 buttonBuffer |= 0x8000; //basttery - not this has to be on but why not. 
    38ae:	30 6c       	ori	r19, 0xC0	; 192
    38b0:	64 c1       	rjmp	.+712    	; 0x3b7a <shiftOut+0x4a8>
	}
	else if (Console.Type  == SNES)
    38b2:	4f 32       	cpi	r20, 0x2F	; 47
    38b4:	09 f0       	breq	.+2      	; 0x38b8 <shiftOut+0x1e6>
    38b6:	61 c1       	rjmp	.+706    	; 0x3b7a <shiftOut+0x4a8>
	{   //snes b,y,sl,st,u,d,l,r,a,x,l,r,1,1,1,1
		// if data is active its low, if the controller is unplugged obviously its all low
		// so the controller holds everything  high as a default. Note the last for represent
		// no button so tey are always high, and some games look for that. i.e the cart menu, dk1
		//note that the mouse the last is low (1110)
		if (reportBuffer[BUTTON_ROW_1] & 0x01)  buttonBuffer |= 0x01;	//B
    38b8:	90 fd       	sbrc	r25, 0
    38ba:	21 60       	ori	r18, 0x01	; 1
		if (reportBuffer[BUTTON_ROW_1] & 0x04)  buttonBuffer |= 0x02;	//Y
    38bc:	92 fd       	sbrc	r25, 2
    38be:	22 60       	ori	r18, 0x02	; 2
		if (reportBuffer[BUTTON_ROW_1] & 0x08)  buttonBuffer |= 0x100;	//A
    38c0:	93 fd       	sbrc	r25, 3
    38c2:	31 60       	ori	r19, 0x01	; 1
		if (reportBuffer[BUTTON_ROW_1] & 0x02)  buttonBuffer |= 0x200;	//X
    38c4:	91 fd       	sbrc	r25, 1
    38c6:	32 60       	ori	r19, 0x02	; 2
		if (reportBuffer[BUTTON_ROW_1] & 0x40)  buttonBuffer |= 0x400;	//L
    38c8:	96 fd       	sbrc	r25, 6
    38ca:	34 60       	ori	r19, 0x04	; 4
		if (reportBuffer[BUTTON_ROW_1] & 0x80)  buttonBuffer |= 0x800;	//R
    38cc:	97 ff       	sbrs	r25, 7
    38ce:	02 c0       	rjmp	.+4      	; 0x38d4 <shiftOut+0x202>
    38d0:	38 60       	ori	r19, 0x08	; 8
    38d2:	53 c1       	rjmp	.+678    	; 0x3b7a <shiftOut+0x4a8>
		// buttonBuffer &= ~0xf000; //this is high anyways for a controller, some games check this, other do not. 

		
		else if (MODE != pad_mse ) //if we are not in mouse mode, do a periodic check.
    38d4:	40 91 19 03 	lds	r20, 0x0319
    38d8:	90 91 83 03 	lds	r25, 0x0383
    38dc:	44 30       	cpi	r20, 0x04	; 4
    38de:	c1 f1       	breq	.+112    	; 0x3950 <shiftOut+0x27e>
		{
			if (!Controller.DpadOnly) MOUSE_CHECK++;//only if we have analogs. 
    38e0:	91 11       	cpse	r25, r1
    38e2:	05 c0       	rjmp	.+10     	; 0x38ee <shiftOut+0x21c>
    38e4:	90 91 18 03 	lds	r25, 0x0318
    38e8:	9f 5f       	subi	r25, 0xFF	; 255
    38ea:	90 93 18 03 	sts	0x0318, r25
			if (MOUSE_CHECK > 50) 
    38ee:	90 91 18 03 	lds	r25, 0x0318
    38f2:	93 33       	cpi	r25, 0x33	; 51
    38f4:	10 f1       	brcs	.+68     	; 0x393a <shiftOut+0x268>
			{
				if ( abs  (reportBuffer[X_MAIN_STICK]) > 10 ||  abs  (reportBuffer[X_SECONDARY_STICK]) > 10  ||
    38f6:	40 91 6b 03 	lds	r20, 0x036B
    38fa:	50 e0       	ldi	r21, 0x00	; 0
    38fc:	4b 30       	cpi	r20, 0x0B	; 11
    38fe:	51 05       	cpc	r21, r1
    3900:	cc f4       	brge	.+50     	; 0x3934 <shiftOut+0x262>
    3902:	40 91 6d 03 	lds	r20, 0x036D
    3906:	50 e0       	ldi	r21, 0x00	; 0
    3908:	4b 30       	cpi	r20, 0x0B	; 11
    390a:	51 05       	cpc	r21, r1
    390c:	9c f4       	brge	.+38     	; 0x3934 <shiftOut+0x262>
					 abs  (reportBuffer[Y_MAIN_STICK]) > 10 ||  abs  (reportBuffer[Y_SECONDARY_STICK]) > 10  ||
    390e:	40 91 6c 03 	lds	r20, 0x036C
    3912:	50 e0       	ldi	r21, 0x00	; 0
		else if (MODE != pad_mse ) //if we are not in mouse mode, do a periodic check.
		{
			if (!Controller.DpadOnly) MOUSE_CHECK++;//only if we have analogs. 
			if (MOUSE_CHECK > 50) 
			{
				if ( abs  (reportBuffer[X_MAIN_STICK]) > 10 ||  abs  (reportBuffer[X_SECONDARY_STICK]) > 10  ||
    3914:	4b 30       	cpi	r20, 0x0B	; 11
    3916:	51 05       	cpc	r21, r1
    3918:	6c f4       	brge	.+26     	; 0x3934 <shiftOut+0x262>
					 abs  (reportBuffer[Y_MAIN_STICK]) > 10 ||  abs  (reportBuffer[Y_SECONDARY_STICK]) > 10  ||
    391a:	40 91 6e 03 	lds	r20, 0x036E
    391e:	50 e0       	ldi	r21, 0x00	; 0
    3920:	4b 30       	cpi	r20, 0x0B	; 11
    3922:	51 05       	cpc	r21, r1
    3924:	3c f4       	brge	.+14     	; 0x3934 <shiftOut+0x262>
    3926:	90 91 6f 03 	lds	r25, 0x036F
    392a:	91 11       	cpse	r25, r1
    392c:	03 c0       	rjmp	.+6      	; 0x3934 <shiftOut+0x262>
					 reportBuffer[DIAL] > 0 || reportBuffer[SLIDER] > 0) //if at rest do not check.		   
    392e:	90 91 70 03 	lds	r25, 0x0370
    3932:	91 11       	cpse	r25, r1
				buttonBuffer |= 0x8000;	
    3934:	30 68       	ori	r19, 0x80	; 128
				MOUSE_CHECK = 0;//reset 
    3936:	10 92 18 03 	sts	0x0318, r1
			}
			//reset walls
			TopWallLimit=100;
    393a:	44 e6       	ldi	r20, 0x64	; 100
    393c:	40 93 1d 03 	sts	0x031D, r20
			BottomWallLimit=160;
    3940:	90 ea       	ldi	r25, 0xA0	; 160
    3942:	90 93 1c 03 	sts	0x031C, r25
			LeftWallLimit=100;
    3946:	40 93 1b 03 	sts	0x031B, r20
			RightWallLimit= 160;
    394a:	90 93 1a 03 	sts	0x031A, r25
    394e:	15 c1       	rjmp	.+554    	; 0x3b7a <shiftOut+0x4a8>
			////////////////////////
			// for Mouse use	  //
			////////////////////////	
			unsigned char mouseX_now=128,mouseY_now=128;//init to 128, as that is at reset, otherwise the < 0 check below will get hit.

			buttonBuffer |= 0x8000; //mouse ID
    3950:	30 68       	ori	r19, 0x80	; 128
			
			if (Controller.DpadOnly)  //check for digital controller
    3952:	99 23       	and	r25, r25
    3954:	51 f0       	breq	.+20     	; 0x396a <shiftOut+0x298>
			{
				MODE = pad_cnt;//change back
    3956:	91 e0       	ldi	r25, 0x01	; 1
    3958:	90 93 19 03 	sts	0x0319, r25
				buttonBuffer &= ~0x8000; 
    395c:	3f 77       	andi	r19, 0x7F	; 127
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    395e:	ef e3       	ldi	r30, 0x3F	; 63
    3960:	fc e9       	ldi	r31, 0x9C	; 156
    3962:	31 97       	sbiw	r30, 0x01	; 1
    3964:	f1 f7       	brne	.-4      	; 0x3962 <shiftOut+0x290>
    3966:	00 c0       	rjmp	.+0      	; 0x3968 <shiftOut+0x296>
    3968:	00 00       	nop
				_delay_ms(10);//the next poll will be a mouse poll so skip it. at least more then 5....but not 16
			}
			
			if (reportBuffer[DIAL] > 0)		mouseX_now = reportBuffer[DIAL];
    396a:	a0 91 6f 03 	lds	r26, 0x036F
    396e:	90 91 68 03 	lds	r25, 0x0368
    3972:	e0 91 86 03 	lds	r30, 0x0386
    3976:	a1 11       	cpse	r26, r1
    3978:	30 c0       	rjmp	.+96     	; 0x39da <shiftOut+0x308>
			else if (reportBuffer[SLIDER] > 0) 	mouseX_now = reportBuffer[SLIDER];
    397a:	a0 91 70 03 	lds	r26, 0x0370
    397e:	a1 11       	cpse	r26, r1
    3980:	2c c0       	rjmp	.+88     	; 0x39da <shiftOut+0x308>
			else 
			{
				//Use L and R to mute analogs. So that we cna force use one or the other. 
				if (reportBuffer[BUTTON_ROW_1] & 0x40 || Controller.Type ==	69 ) reportBuffer[X_SECONDARY_STICK]=reportBuffer[Y_SECONDARY_STICK]=128;//L was pressed
    3982:	96 fd       	sbrc	r25, 6
    3984:	02 c0       	rjmp	.+4      	; 0x398a <shiftOut+0x2b8>
    3986:	e5 34       	cpi	r30, 0x45	; 69
    3988:	29 f4       	brne	.+10     	; 0x3994 <shiftOut+0x2c2>
    398a:	40 e8       	ldi	r20, 0x80	; 128
    398c:	40 93 6e 03 	sts	0x036E, r20
    3990:	40 93 6d 03 	sts	0x036D, r20
				if (reportBuffer[BUTTON_ROW_1] & 0x80						   ) reportBuffer[X_MAIN_STICK     ]=reportBuffer[Y_MAIN_STICK     ]=128;///R was pressed
    3994:	97 ff       	sbrs	r25, 7
    3996:	05 c0       	rjmp	.+10     	; 0x39a2 <shiftOut+0x2d0>
    3998:	40 e8       	ldi	r20, 0x80	; 128
    399a:	40 93 6c 03 	sts	0x036C, r20
    399e:	40 93 6b 03 	sts	0x036B, r20
			
				//now see what analog moved the most. NOTE seconday does not use walls (better for paint)			
				if ( abs  (reportBuffer[X_MAIN_STICK])  >= abs  (reportBuffer[X_SECONDARY_STICK])  ) mouseX_now = reportBuffer[X_MAIN_STICK]; else {readStickRight = true;mouseX_now = reportBuffer[X_SECONDARY_STICK];}
    39a2:	f0 91 6b 03 	lds	r31, 0x036B
    39a6:	a0 91 6d 03 	lds	r26, 0x036D
    39aa:	6f 2f       	mov	r22, r31
    39ac:	70 e0       	ldi	r23, 0x00	; 0
    39ae:	4a 2f       	mov	r20, r26
    39b0:	50 e0       	ldi	r21, 0x00	; 0
    39b2:	64 17       	cp	r22, r20
    39b4:	75 07       	cpc	r23, r21
    39b6:	1c f0       	brlt	.+6      	; 0x39be <shiftOut+0x2ec>
    39b8:	af 2f       	mov	r26, r31
	//a,b,s,s,u,d,l,r
	int buttonBuffer = 0;
	unsigned int timer=1;
	int AUX1Buffer=0,AUX2Buffer=0;
	int mouse_data=0;
	bool readStickRight=0;
    39ba:	10 e0       	ldi	r17, 0x00	; 0
    39bc:	01 c0       	rjmp	.+2      	; 0x39c0 <shiftOut+0x2ee>
				//Use L and R to mute analogs. So that we cna force use one or the other. 
				if (reportBuffer[BUTTON_ROW_1] & 0x40 || Controller.Type ==	69 ) reportBuffer[X_SECONDARY_STICK]=reportBuffer[Y_SECONDARY_STICK]=128;//L was pressed
				if (reportBuffer[BUTTON_ROW_1] & 0x80						   ) reportBuffer[X_MAIN_STICK     ]=reportBuffer[Y_MAIN_STICK     ]=128;///R was pressed
			
				//now see what analog moved the most. NOTE seconday does not use walls (better for paint)			
				if ( abs  (reportBuffer[X_MAIN_STICK])  >= abs  (reportBuffer[X_SECONDARY_STICK])  ) mouseX_now = reportBuffer[X_MAIN_STICK]; else {readStickRight = true;mouseX_now = reportBuffer[X_SECONDARY_STICK];}
    39be:	11 e0       	ldi	r17, 0x01	; 1
				if ( abs  (reportBuffer[Y_MAIN_STICK])  >= abs  (reportBuffer[Y_SECONDARY_STICK])  ) mouseY_now = reportBuffer[Y_MAIN_STICK]; else   mouseY_now = reportBuffer[Y_SECONDARY_STICK]; 
    39c0:	f0 91 6c 03 	lds	r31, 0x036C
    39c4:	b0 91 6e 03 	lds	r27, 0x036E
    39c8:	6f 2f       	mov	r22, r31
    39ca:	70 e0       	ldi	r23, 0x00	; 0
    39cc:	4b 2f       	mov	r20, r27
    39ce:	50 e0       	ldi	r21, 0x00	; 0
    39d0:	64 17       	cp	r22, r20
    39d2:	75 07       	cpc	r23, r21
    39d4:	24 f0       	brlt	.+8      	; 0x39de <shiftOut+0x30c>
    39d6:	bf 2f       	mov	r27, r31
    39d8:	02 c0       	rjmp	.+4      	; 0x39de <shiftOut+0x30c>
		else   //otherwise its a mouse
		{
			////////////////////////
			// for Mouse use	  //
			////////////////////////	
			unsigned char mouseX_now=128,mouseY_now=128;//init to 128, as that is at reset, otherwise the < 0 check below will get hit.
    39da:	b0 e8       	ldi	r27, 0x80	; 128
	//a,b,s,s,u,d,l,r
	int buttonBuffer = 0;
	unsigned int timer=1;
	int AUX1Buffer=0,AUX2Buffer=0;
	int mouse_data=0;
	bool readStickRight=0;
    39dc:	10 e0       	ldi	r17, 0x00	; 0
			}

			//////////////////////////////
			// wall boundrie exclusions //
			//////////////////////////////
			bool useWalls =  ( Controller.Type ==	68 || //do not use walls with a wii hero, its endless.
    39de:	e4 54       	subi	r30, 0x44	; 68
							   Controller.Type ==	69 || //do not use walls with a wii tablet, its endless.
							   readStickRight			) //do not use walls if sensitivy is not set. I think this is best	
												  ? 0:1;//use or do not use walls
    39e0:	e2 30       	cpi	r30, 0x02	; 2
    39e2:	18 f0       	brcs	.+6      	; 0x39ea <shiftOut+0x318>
    39e4:	41 e0       	ldi	r20, 0x01	; 1
    39e6:	41 27       	eor	r20, r17
    39e8:	01 c0       	rjmp	.+2      	; 0x39ec <shiftOut+0x31a>
    39ea:	40 e0       	ldi	r20, 0x00	; 0
			}

			//////////////////////////////
			// wall boundrie exclusions //
			//////////////////////////////
			bool useWalls =  ( Controller.Type ==	68 || //do not use walls with a wii hero, its endless.
    39ec:	e4 2f       	mov	r30, r20
    39ee:	e1 70       	andi	r30, 0x01	; 1
							   Controller.Type ==	69 || //do not use walls with a wii tablet, its endless.
							   readStickRight			) //do not use walls if sensitivy is not set. I think this is best	
												  ? 0:1;//use or do not use walls
												  
			if (mouseY_now > BottomWallLimit) BottomWallLimit = mouseY_now; //push botton wall
    39f0:	40 91 1c 03 	lds	r20, 0x031C
    39f4:	4b 17       	cp	r20, r27
    39f6:	10 f4       	brcc	.+4      	; 0x39fc <shiftOut+0x32a>
    39f8:	b0 93 1c 03 	sts	0x031C, r27
			if (mouseY_now < TopWallLimit) TopWallLimit = mouseY_now;		//push top wall
    39fc:	40 91 1d 03 	lds	r20, 0x031D
    3a00:	b4 17       	cp	r27, r20
    3a02:	10 f4       	brcc	.+4      	; 0x3a08 <shiftOut+0x336>
    3a04:	b0 93 1d 03 	sts	0x031D, r27
			if (mouseX_now > RightWallLimit) RightWallLimit = mouseX_now;	//push right wall
    3a08:	40 91 1a 03 	lds	r20, 0x031A
    3a0c:	4a 17       	cp	r20, r26
    3a0e:	10 f4       	brcc	.+4      	; 0x3a14 <shiftOut+0x342>
    3a10:	a0 93 1a 03 	sts	0x031A, r26
			if (mouseX_now < LeftWallLimit) LeftWallLimit = mouseX_now;		//push left wall
    3a14:	40 91 1b 03 	lds	r20, 0x031B
    3a18:	a4 17       	cp	r26, r20
    3a1a:	10 f4       	brcc	.+4      	; 0x3a20 <shiftOut+0x34e>
    3a1c:	a0 93 1b 03 	sts	0x031B, r26

				
			//////////////////
			// apply data Y //
			//////////////////
			if (useWalls && mouseY_now >     (BottomWallLimit-15)) mouse_data = 0xFE;
    3a20:	ee 23       	and	r30, r30
    3a22:	a1 f0       	breq	.+40     	; 0x3a4c <shiftOut+0x37a>
    3a24:	6b 2f       	mov	r22, r27
    3a26:	70 e0       	ldi	r23, 0x00	; 0
    3a28:	40 91 1c 03 	lds	r20, 0x031C
    3a2c:	50 e0       	ldi	r21, 0x00	; 0
    3a2e:	4e 50       	subi	r20, 0x0E	; 14
    3a30:	51 09       	sbc	r21, r1
    3a32:	64 17       	cp	r22, r20
    3a34:	75 07       	cpc	r23, r21
    3a36:	0c f0       	brlt	.+2      	; 0x3a3a <shiftOut+0x368>
    3a38:	6d c1       	rjmp	.+730    	; 0x3d14 <shiftOut+0x642>
			else if (useWalls && mouseY_now <(TopWallLimit+ 15)) mouse_data = 0xFF;
    3a3a:	40 91 1d 03 	lds	r20, 0x031D
    3a3e:	50 e0       	ldi	r21, 0x00	; 0
    3a40:	42 5f       	subi	r20, 0xF2	; 242
    3a42:	5f 4f       	sbci	r21, 0xFF	; 255
    3a44:	46 17       	cp	r20, r22
    3a46:	57 07       	cpc	r21, r23
    3a48:	0c f0       	brlt	.+2      	; 0x3a4c <shiftOut+0x37a>
    3a4a:	67 c1       	rjmp	.+718    	; 0x3d1a <shiftOut+0x648>
			else if (mouseY_now > mouseY_old) 
    3a4c:	40 91 1e 03 	lds	r20, 0x031E
    3a50:	4b 17       	cp	r20, r27
    3a52:	d0 f4       	brcc	.+52     	; 0x3a88 <shiftOut+0x3b6>
			{
				unsigned char temp = mouseY_now - mouseY_old;
    3a54:	fb 2f       	mov	r31, r27
    3a56:	f4 1b       	sub	r31, r20
    3a58:	4f 2f       	mov	r20, r31
				if (temp > 200) temp=0; //watch for flip over code ( going past 255 flips to 0)
    3a5a:	f9 3c       	cpi	r31, 0xC9	; 201
    3a5c:	08 f0       	brcs	.+2      	; 0x3a60 <shiftOut+0x38e>
    3a5e:	40 e0       	ldi	r20, 0x00	; 0
				if ( readStickRight ) temp >>=1; //less sensitive - should take care of jitter. 
    3a60:	11 11       	cpse	r17, r1
    3a62:	46 95       	lsr	r20
				
				mouse_data = __builtin_avr_insert_bits(0x01234567,temp,0);// set distance moved for below. 
    3a64:	44 0f       	add	r20, r20
    3a66:	41 1d       	adc	r20, r1
    3a68:	04 2e       	mov	r0, r20
    3a6a:	01 fa       	bst	r0, 1
    3a6c:	47 f9       	bld	r20, 7
    3a6e:	02 fa       	bst	r0, 2
    3a70:	46 f9       	bld	r20, 6
    3a72:	03 fa       	bst	r0, 3
    3a74:	45 f9       	bld	r20, 5
    3a76:	05 fa       	bst	r0, 5
    3a78:	43 f9       	bld	r20, 3
    3a7a:	06 fa       	bst	r0, 6
    3a7c:	42 f9       	bld	r20, 2
    3a7e:	07 fa       	bst	r0, 7
    3a80:	41 f9       	bld	r20, 1
    3a82:	50 e0       	ldi	r21, 0x00	; 0
				mouse_data &= ~0x01; //up is a 0
    3a84:	4e 7f       	andi	r20, 0xFE	; 254
    3a86:	18 c0       	rjmp	.+48     	; 0x3ab8 <shiftOut+0x3e6>
			}
			else  
			{
				unsigned char temp = mouseY_old - mouseY_now;
    3a88:	4b 1b       	sub	r20, r27
				if (temp > 200) temp=0;//watch for flip over code ( going past 255 flips to 0)
    3a8a:	49 3c       	cpi	r20, 0xC9	; 201
    3a8c:	08 f0       	brcs	.+2      	; 0x3a90 <shiftOut+0x3be>
    3a8e:	40 e0       	ldi	r20, 0x00	; 0
				if ( readStickRight ) temp >>=1; //less sensitive - should take care of jitter. 
    3a90:	11 11       	cpse	r17, r1
    3a92:	46 95       	lsr	r20
				
				mouse_data =  __builtin_avr_insert_bits(0x01234567,temp,0);// set distance moved for below.  
    3a94:	44 0f       	add	r20, r20
    3a96:	41 1d       	adc	r20, r1
    3a98:	54 2f       	mov	r21, r20
    3a9a:	41 fb       	bst	r20, 1
    3a9c:	57 f9       	bld	r21, 7
    3a9e:	42 fb       	bst	r20, 2
    3aa0:	56 f9       	bld	r21, 6
    3aa2:	43 fb       	bst	r20, 3
    3aa4:	55 f9       	bld	r21, 5
    3aa6:	45 fb       	bst	r20, 5
    3aa8:	53 f9       	bld	r21, 3
    3aaa:	46 fb       	bst	r20, 6
    3aac:	52 f9       	bld	r21, 2
    3aae:	47 fb       	bst	r20, 7
    3ab0:	51 f9       	bld	r21, 1
				mouse_data |= 0x01; //down is a 1
    3ab2:	51 60       	ori	r21, 0x01	; 1
    3ab4:	45 2f       	mov	r20, r21
    3ab6:	50 e0       	ldi	r21, 0x00	; 0
			}
			
			//////////////////
			// apply data X //
			//////////////////	
			if (useWalls && mouseX_now >     (RightWallLimit-15)) mouse_data |= 0xFE00;
    3ab8:	ee 23       	and	r30, r30
    3aba:	b1 f0       	breq	.+44     	; 0x3ae8 <shiftOut+0x416>
    3abc:	ea 2f       	mov	r30, r26
    3abe:	f0 e0       	ldi	r31, 0x00	; 0
    3ac0:	60 91 1a 03 	lds	r22, 0x031A
    3ac4:	70 e0       	ldi	r23, 0x00	; 0
    3ac6:	6e 50       	subi	r22, 0x0E	; 14
    3ac8:	71 09       	sbc	r23, r1
    3aca:	e6 17       	cp	r30, r22
    3acc:	f7 07       	cpc	r31, r23
    3ace:	14 f0       	brlt	.+4      	; 0x3ad4 <shiftOut+0x402>
    3ad0:	5e 6f       	ori	r21, 0xFE	; 254
    3ad2:	3f c0       	rjmp	.+126    	; 0x3b52 <shiftOut+0x480>
			else if (useWalls && mouseX_now <(LeftWallLimit +15)) mouse_data |= 0xFF00;
    3ad4:	60 91 1b 03 	lds	r22, 0x031B
    3ad8:	70 e0       	ldi	r23, 0x00	; 0
    3ada:	62 5f       	subi	r22, 0xF2	; 242
    3adc:	7f 4f       	sbci	r23, 0xFF	; 255
    3ade:	6e 17       	cp	r22, r30
    3ae0:	7f 07       	cpc	r23, r31
    3ae2:	14 f0       	brlt	.+4      	; 0x3ae8 <shiftOut+0x416>
    3ae4:	5f 6f       	ori	r21, 0xFF	; 255
    3ae6:	35 c0       	rjmp	.+106    	; 0x3b52 <shiftOut+0x480>
			else if (mouseX_now > mouseX_old) 
    3ae8:	60 91 1f 03 	lds	r22, 0x031F
    3aec:	6a 17       	cp	r22, r26
    3aee:	d0 f4       	brcc	.+52     	; 0x3b24 <shiftOut+0x452>
			{
				unsigned char temp = mouseX_now - mouseX_old;
    3af0:	7a 2f       	mov	r23, r26
    3af2:	76 1b       	sub	r23, r22
    3af4:	67 2f       	mov	r22, r23
				if (temp > 200) temp=0;//watch for flip over code ( going past 255 flips to 0)
    3af6:	79 3c       	cpi	r23, 0xC9	; 201
    3af8:	08 f0       	brcs	.+2      	; 0x3afc <shiftOut+0x42a>
    3afa:	60 e0       	ldi	r22, 0x00	; 0
				if ( readStickRight ) temp >>=1; //less sensitive - should take care of jitter. 
    3afc:	11 11       	cpse	r17, r1
    3afe:	66 95       	lsr	r22
				
				mouse_data |= __builtin_avr_insert_bits(0x01234567,temp,0) <<8;// set distance moved for below. 
    3b00:	66 0f       	add	r22, r22
    3b02:	61 1d       	adc	r22, r1
    3b04:	06 2e       	mov	r0, r22
    3b06:	01 fa       	bst	r0, 1
    3b08:	67 f9       	bld	r22, 7
    3b0a:	02 fa       	bst	r0, 2
    3b0c:	66 f9       	bld	r22, 6
    3b0e:	03 fa       	bst	r0, 3
    3b10:	65 f9       	bld	r22, 5
    3b12:	05 fa       	bst	r0, 5
    3b14:	63 f9       	bld	r22, 3
    3b16:	06 fa       	bst	r0, 6
    3b18:	62 f9       	bld	r22, 2
    3b1a:	07 fa       	bst	r0, 7
    3b1c:	61 f9       	bld	r22, 1
    3b1e:	56 2b       	or	r21, r22
				mouse_data &= ~0x0100; //left is a 0
    3b20:	5e 7f       	andi	r21, 0xFE	; 254
    3b22:	17 c0       	rjmp	.+46     	; 0x3b52 <shiftOut+0x480>
			}
			else  
			{
				unsigned char temp = mouseX_old - mouseX_now;
    3b24:	6a 1b       	sub	r22, r26
				if (temp > 200) temp=0;//watch for flip over code ( going past 255 flips to 0)
    3b26:	69 3c       	cpi	r22, 0xC9	; 201
    3b28:	08 f0       	brcs	.+2      	; 0x3b2c <shiftOut+0x45a>
    3b2a:	60 e0       	ldi	r22, 0x00	; 0
				if ( readStickRight ) temp >>=1; //less sensitive - should take care of jitter. 
    3b2c:	11 11       	cpse	r17, r1
    3b2e:	66 95       	lsr	r22
				
				mouse_data |=  __builtin_avr_insert_bits(0x01234567,temp,0)<<8;// set distance moved for below. 
    3b30:	66 0f       	add	r22, r22
    3b32:	61 1d       	adc	r22, r1
    3b34:	06 2e       	mov	r0, r22
    3b36:	01 fa       	bst	r0, 1
    3b38:	67 f9       	bld	r22, 7
    3b3a:	02 fa       	bst	r0, 2
    3b3c:	66 f9       	bld	r22, 6
    3b3e:	03 fa       	bst	r0, 3
    3b40:	65 f9       	bld	r22, 5
    3b42:	05 fa       	bst	r0, 5
    3b44:	63 f9       	bld	r22, 3
    3b46:	06 fa       	bst	r0, 6
    3b48:	62 f9       	bld	r22, 2
    3b4a:	07 fa       	bst	r0, 7
    3b4c:	61 f9       	bld	r22, 1
    3b4e:	51 60       	ori	r21, 0x01	; 1
				mouse_data |= 0x0100; //right is a 1
    3b50:	56 2b       	or	r21, r22
				
			}
			
			mouseY_old = mouseY_now;//backup stick position up for later
    3b52:	b0 93 1e 03 	sts	0x031E, r27
			mouseX_old = mouseX_now;//backp stick position up for later
    3b56:	a0 93 1f 03 	sts	0x031F, r26
			

			//Most SNES games do not work of the last bit is use, nor should they. You will never move the mouse that fast.
			//some games move the wrong way if the 5th bit is even used, so just mask it out. 
			mouse_data &= ~0x0202; // If the 40 (5th) bit is on it overrides and goes left or up regardless of the direction
    3b5a:	fa 01       	movw	r30, r20
    3b5c:	ed 7f       	andi	r30, 0xFD	; 253
    3b5e:	fd 7f       	andi	r31, 0xFD	; 253

			//I do not really see a point in using sensitivity, we have analog sticks and many buttons. Right is low and left is high.
		
			buttonBuffer &= ~0xfff;//clear out what we have but leave ID
    3b60:	22 27       	eor	r18, r18
    3b62:	30 7f       	andi	r19, 0xF0	; 240

			//Left mouse-button is fire/select, and Right mouse-button is pause
			if (reportBuffer[BUTTON_ROW_1] & 0x0F)  buttonBuffer |= 0x200;  //0x200 snes X is left (use BB any button)
    3b64:	49 2f       	mov	r20, r25
    3b66:	4f 70       	andi	r20, 0x0F	; 15
    3b68:	09 f0       	breq	.+2      	; 0x3b6c <shiftOut+0x49a>
    3b6a:	32 60       	ori	r19, 0x02	; 2
			if (reportBuffer[BUTTON_ROW_1] & 0x20)  buttonBuffer |= 0x100;  //0x100 snes A is right (use BB start)		
    3b6c:	95 ff       	sbrs	r25, 5
    3b6e:	07 c0       	rjmp	.+14     	; 0x3b7e <shiftOut+0x4ac>
    3b70:	31 60       	ori	r19, 0x01	; 1
    3b72:	05 c0       	rjmp	.+10     	; 0x3b7e <shiftOut+0x4ac>
{
	//a,b,s,s,u,d,l,r
	int buttonBuffer = 0;
	unsigned int timer=1;
	int AUX1Buffer=0,AUX2Buffer=0;
	int mouse_data=0;
    3b74:	e0 e0       	ldi	r30, 0x00	; 0
    3b76:	f0 e0       	ldi	r31, 0x00	; 0
    3b78:	04 c0       	rjmp	.+8      	; 0x3b82 <shiftOut+0x4b0>
    3b7a:	e0 e0       	ldi	r30, 0x00	; 0
    3b7c:	f0 e0       	ldi	r31, 0x00	; 0
void shiftOut( bool _short)
{
	//a,b,s,s,u,d,l,r
	int buttonBuffer = 0;
	unsigned int timer=1;
	int AUX1Buffer=0,AUX2Buffer=0;
    3b7e:	40 e0       	ldi	r20, 0x00	; 0
    3b80:	50 e0       	ldi	r21, 0x00	; 0
    3b82:	60 e0       	ldi	r22, 0x00	; 0
    3b84:	70 e0       	ldi	r23, 0x00	; 0
	//// 5/5 us with a 12us latch, like the net talks about.	  //// 
	//////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////
	int bit=1; 
	char length = 8;
	if (Console.Type  == SNES || Console.Type  == V_BOY  ) length = 16;
    3b86:	90 91 65 03 	lds	r25, 0x0365
    3b8a:	9f 32       	cpi	r25, 0x2F	; 47
    3b8c:	21 f0       	breq	.+8      	; 0x3b96 <shiftOut+0x4c4>
    3b8e:	9f 31       	cpi	r25, 0x1F	; 31
    3b90:	11 f0       	breq	.+4      	; 0x3b96 <shiftOut+0x4c4>
	//// is more like .5 us blips. snes has a much nicer clock    //// 
	//// 5/5 us with a 12us latch, like the net talks about.	  //// 
	//////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////
	int bit=1; 
	char length = 8;
    3b92:	18 e0       	ldi	r17, 0x08	; 8
    3b94:	01 c0       	rjmp	.+2      	; 0x3b98 <shiftOut+0x4c6>
	if (Console.Type  == SNES || Console.Type  == V_BOY  ) length = 16;
    3b96:	10 e1       	ldi	r17, 0x10	; 16


	timer=1;//we need to grab the latch, these will return from code if not seen.
	if ( _short ) { WHILE_LATCH_IS_LO_500MS }// for second poll, it is up to the game. Not all games do this, so we need to test for the second poll
    3b98:	81 11       	cpse	r24, r1
    3b9a:	03 c0       	rjmp	.+6      	; 0x3ba2 <shiftOut+0x4d0>
    3b9c:	af e0       	ldi	r26, 0x0F	; 15
    3b9e:	b4 ea       	ldi	r27, 0xA4	; 164
    3ba0:	0c c0       	rjmp	.+24     	; 0x3bba <shiftOut+0x4e8>
    3ba2:	a3 ef       	ldi	r26, 0xF3	; 243
    3ba4:	b1 e0       	ldi	r27, 0x01	; 1
    3ba6:	4e 99       	sbic	0x09, 6	; 9
    3ba8:	0a c0       	rjmp	.+20     	; 0x3bbe <shiftOut+0x4ec>
    3baa:	11 97       	sbiw	r26, 0x01	; 1
    3bac:	10 97       	sbiw	r26, 0x00	; 0
    3bae:	d9 f7       	brne	.-10     	; 0x3ba6 <shiftOut+0x4d4>
    3bb0:	b7 c0       	rjmp	.+366    	; 0x3d20 <shiftOut+0x64e>
    3bb2:	11 97       	sbiw	r26, 0x01	; 1
	else {WHILE_LATCH_IS_LO_16MS}
    3bb4:	10 97       	sbiw	r26, 0x00	; 0
    3bb6:	09 f4       	brne	.+2      	; 0x3bba <shiftOut+0x4e8>
    3bb8:	b3 c0       	rjmp	.+358    	; 0x3d20 <shiftOut+0x64e>
    3bba:	4e 9b       	sbis	0x09, 6	; 9
    3bbc:	fa cf       	rjmp	.-12     	; 0x3bb2 <shiftOut+0x4e0>

	PORTD |= 0x30; //BOTH but why not the 40 bit?
    3bbe:	ab b1       	in	r26, 0x0b	; 11
    3bc0:	a0 63       	ori	r26, 0x30	; 48
    3bc2:	ab b9       	out	0x0b, r26	; 11
	for (unsigned char d=0; d<length; d++)
    3bc4:	00 e0       	ldi	r16, 0x00	; 0
	//// The latch with nes is short like 3us or so and the clock //// 
	//// is more like .5 us blips. snes has a much nicer clock    //// 
	//// 5/5 us with a 12us latch, like the net talks about.	  //// 
	//////////////////////////////////////////////////////////////////
	//////////////////////////////////////////////////////////////////
	int bit=1; 
    3bc6:	a1 e0       	ldi	r26, 0x01	; 1
    3bc8:	b0 e0       	ldi	r27, 0x00	; 0

	PORTD |= 0x30; //BOTH but why not the 40 bit?
	for (unsigned char d=0; d<length; d++)
	{
		
		if (buttonBuffer & bit) PORTD &= ~DATA1; else PORTD |= DATA1; 
    3bca:	7d 01       	movw	r14, r26
    3bcc:	e2 22       	and	r14, r18
    3bce:	f3 22       	and	r15, r19
    3bd0:	ef 28       	or	r14, r15
    3bd2:	11 f0       	breq	.+4      	; 0x3bd8 <shiftOut+0x506>
    3bd4:	5d 98       	cbi	0x0b, 5	; 11
    3bd6:	01 c0       	rjmp	.+2      	; 0x3bda <shiftOut+0x508>
    3bd8:	5d 9a       	sbi	0x0b, 5	; 11
		if (AUX1Buffer   & bit) PORTD &= ~DATA2; else PORTD |= DATA2; //used for nes but 
    3bda:	7d 01       	movw	r14, r26
    3bdc:	e6 22       	and	r14, r22
    3bde:	f7 22       	and	r15, r23
    3be0:	ef 28       	or	r14, r15
    3be2:	11 f0       	breq	.+4      	; 0x3be8 <shiftOut+0x516>
    3be4:	5c 98       	cbi	0x0b, 4	; 11
    3be6:	01 c0       	rjmp	.+2      	; 0x3bea <shiftOut+0x518>
    3be8:	5c 9a       	sbi	0x0b, 4	; 11
		if (AUX2Buffer   & bit) PORTC &= ~DATA3; else PORTC |= DATA3; //does not hurt for snes. 
    3bea:	7d 01       	movw	r14, r26
    3bec:	e4 22       	and	r14, r20
    3bee:	f5 22       	and	r15, r21
    3bf0:	ef 28       	or	r14, r15
    3bf2:	11 f0       	breq	.+4      	; 0x3bf8 <shiftOut+0x526>
    3bf4:	46 98       	cbi	0x08, 6	; 8
    3bf6:	01 c0       	rjmp	.+2      	; 0x3bfa <shiftOut+0x528>
    3bf8:	46 9a       	sbi	0x08, 6	; 8
		 bit <<= 1;
    3bfa:	aa 0f       	add	r26, r26
    3bfc:	bb 1f       	adc	r27, r27
		WHILE_CLOCK_IS_HI_NT//found clock.	
    3bfe:	4f 99       	sbic	0x09, 7	; 9
    3c00:	fe cf       	rjmp	.-4      	; 0x3bfe <shiftOut+0x52c>
		if (Console.Type  == SNES) WHILE_CLOCK_IS_LO_NT//clock is longer so we need to wait it out. (not needed for VB on nes, maybe needded for VB on VB. 
    3c02:	9f 32       	cpi	r25, 0x2F	; 47
    3c04:	11 f4       	brne	.+4      	; 0x3c0a <shiftOut+0x538>
    3c06:	4f 9b       	sbis	0x09, 7	; 9
    3c08:	fe cf       	rjmp	.-4      	; 0x3c06 <shiftOut+0x534>
	timer=1;//we need to grab the latch, these will return from code if not seen.
	if ( _short ) { WHILE_LATCH_IS_LO_500MS }// for second poll, it is up to the game. Not all games do this, so we need to test for the second poll
	else {WHILE_LATCH_IS_LO_16MS}

	PORTD |= 0x30; //BOTH but why not the 40 bit?
	for (unsigned char d=0; d<length; d++)
    3c0a:	0f 5f       	subi	r16, 0xFF	; 255
    3c0c:	01 17       	cp	r16, r17
    3c0e:	e8 f2       	brcs	.-70     	; 0x3bca <shiftOut+0x4f8>
		WHILE_CLOCK_IS_HI_NT//found clock.	
		if (Console.Type  == SNES) WHILE_CLOCK_IS_LO_NT//clock is longer so we need to wait it out. (not needed for VB on nes, maybe needded for VB on VB. 
	}

	//Vboy check
	if ( Console.Type  == NES)
    3c10:	91 32       	cpi	r25, 0x21	; 33
    3c12:	41 f4       	brne	.+16     	; 0x3c24 <shiftOut+0x552>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3c14:	90 e5       	ldi	r25, 0x50	; 80
    3c16:	9a 95       	dec	r25
    3c18:	f1 f7       	brne	.-4      	; 0x3c16 <shiftOut+0x544>
	{ 
		_delay_us(15);
		if (! (PIND & CLOCK)) Console.Type = V_BOY;
    3c1a:	4f 99       	sbic	0x09, 7	; 9
    3c1c:	03 c0       	rjmp	.+6      	; 0x3c24 <shiftOut+0x552>
    3c1e:	9f e1       	ldi	r25, 0x1F	; 31
    3c20:	90 93 65 03 	sts	0x0365, r25
	}
 
	//note if snes games poll twice like nes for castleV then we need to rethink this,. 
	if ( buttonBuffer & 0x8000 && _short) //this is the mouse ID bit. (no need to do this twice so use short to know.
    3c24:	37 ff       	sbrs	r19, 7
    3c26:	72 c0       	rjmp	.+228    	; 0x3d0c <shiftOut+0x63a>
    3c28:	88 23       	and	r24, r24
    3c2a:	09 f4       	brne	.+2      	; 0x3c2e <shiftOut+0x55c>
    3c2c:	6f c0       	rjmp	.+222    	; 0x3d0c <shiftOut+0x63a>
	{
		if (MODE == pad_cnt) getMouseSensitivity(); //we do not really use this but the game is expecting it.
    3c2e:	80 91 19 03 	lds	r24, 0x0319
    3c32:	81 30       	cpi	r24, 0x01	; 1
    3c34:	09 f0       	breq	.+2      	; 0x3c38 <shiftOut+0x566>
    3c36:	3d c0       	rjmp	.+122    	; 0x3cb2 <shiftOut+0x5e0>
    3c38:	e5 e0       	ldi	r30, 0x05	; 5
    3c3a:	ea 95       	dec	r30
    3c3c:	f1 f7       	brne	.-4      	; 0x3c3a <shiftOut+0x568>
    3c3e:	00 00       	nop
	// mario point  - I see this strange 31 clock and latch pulse but I do not see any setting of the sensitivity.
	//
	_delay_us(1);//we can not have a long wait here 
	int bit;
	int timer=1;
	MODE = pad_cnt;//unset, so we can see if digital pas has been inserted. 
    3c40:	80 93 19 03 	sts	0x0319, r24
    3c44:	8b e7       	ldi	r24, 0x7B	; 123
    3c46:	95 e1       	ldi	r25, 0x15	; 21
	//So if we see a clock only, its not being set but is mouse code. 
	//will exit loop if latch is found, will return if timer expires, and return as mouse found if clock only is found. 
	while ( (PIND & LATCH)==0x00 ) 
	{
		timer++; 
		if (! (PIND & CLOCK))  MODE = pad_mse; //will also return after timer is done. 
    3c48:	24 e0       	ldi	r18, 0x04	; 4


	//this check is for the start of sensitivy latch fall but some games do not use this. 
	//So if we see a clock only, its not being set but is mouse code. 
	//will exit loop if latch is found, will return if timer expires, and return as mouse found if clock only is found. 
	while ( (PIND & LATCH)==0x00 ) 
    3c4a:	4e 99       	sbic	0x09, 6	; 9
    3c4c:	07 c0       	rjmp	.+14     	; 0x3c5c <shiftOut+0x58a>
	{
		timer++; 
		if (! (PIND & CLOCK))  MODE = pad_mse; //will also return after timer is done. 
    3c4e:	4f 9b       	sbis	0x09, 7	; 9
    3c50:	20 93 19 03 	sts	0x0319, r18
    3c54:	01 97       	sbiw	r24, 0x01	; 1
		if (timer == 5500) return;  // > 3ms
    3c56:	00 97       	sbiw	r24, 0x00	; 0
    3c58:	c1 f7       	brne	.-16     	; 0x3c4a <shiftOut+0x578>
    3c5a:	62 c0       	rjmp	.+196    	; 0x3d20 <shiftOut+0x64e>


	//this check is for the start of sensitivy latch fall but some games do not use this. 
	//So if we see a clock only, its not being set but is mouse code. 
	//will exit loop if latch is found, will return if timer expires, and return as mouse found if clock only is found. 
	while ( (PIND & LATCH)==0x00 ) 
    3c5c:	80 e0       	ldi	r24, 0x00	; 0
    3c5e:	90 e0       	ldi	r25, 0x00	; 0
			bit <<= 1;
			WHILE_CLOCK_IS_HI_NT//found clock.
			
		}
		
		MODE = pad_mse;
    3c60:	74 e0       	ldi	r23, 0x04	; 4
    3c62:	f5 e0       	ldi	r31, 0x05	; 5
    3c64:	fa 95       	dec	r31
    3c66:	f1 f7       	brne	.-4      	; 0x3c64 <shiftOut+0x592>
    3c68:	00 00       	nop
    3c6a:	6c e0       	ldi	r22, 0x0C	; 12
	//            |  -   (400)
	//             | -   (000)
	//            00 -   (800)  Ark set this, and this game should be high I think? We'd need more game data to understand this but it is not need
		_delay_us(1); 

		bit=1;
    3c6c:	21 e0       	ldi	r18, 0x01	; 1
    3c6e:	30 e0       	ldi	r19, 0x00	; 0
		for (unsigned char d=0; d<12; d++)
		{
			if ( (sensitivity ) & bit) PORTD &= ~DATA1; else PORTD |= DATA1;
    3c70:	a9 01       	movw	r20, r18
    3c72:	48 23       	and	r20, r24
    3c74:	59 23       	and	r21, r25
    3c76:	45 2b       	or	r20, r21
    3c78:	11 f0       	breq	.+4      	; 0x3c7e <shiftOut+0x5ac>
    3c7a:	5d 98       	cbi	0x0b, 5	; 11
    3c7c:	01 c0       	rjmp	.+2      	; 0x3c80 <shiftOut+0x5ae>
    3c7e:	5d 9a       	sbi	0x0b, 5	; 11
			bit <<= 1;
    3c80:	22 0f       	add	r18, r18
    3c82:	33 1f       	adc	r19, r19
			WHILE_CLOCK_IS_HI_NT//found clock.
    3c84:	4f 99       	sbic	0x09, 7	; 9
    3c86:	fe cf       	rjmp	.-4      	; 0x3c84 <shiftOut+0x5b2>
    3c88:	61 50       	subi	r22, 0x01	; 1
	//             | -   (000)
	//            00 -   (800)  Ark set this, and this game should be high I think? We'd need more game data to understand this but it is not need
		_delay_us(1); 

		bit=1;
		for (unsigned char d=0; d<12; d++)
    3c8a:	91 f7       	brne	.-28     	; 0x3c70 <shiftOut+0x59e>
			bit <<= 1;
			WHILE_CLOCK_IS_HI_NT//found clock.
			
		}
		
		MODE = pad_mse;
    3c8c:	70 93 19 03 	sts	0x0319, r23
		sensitivity += 0x400; //0, 400, 800 (h, m, l
    3c90:	9c 5f       	subi	r25, 0xFC	; 252
		PORTD |= DATA1;
    3c92:	5d 9a       	sbi	0x0b, 5	; 11
    3c94:	23 e8       	ldi	r18, 0x83	; 131
    3c96:	33 e0       	ldi	r19, 0x03	; 3
		timer=1;
		WHILE_LATCH_IS_LO_1MS 
    3c98:	4e 99       	sbic	0x09, 6	; 9
    3c9a:	06 c0       	rjmp	.+12     	; 0x3ca8 <shiftOut+0x5d6>
    3c9c:	21 50       	subi	r18, 0x01	; 1
    3c9e:	31 09       	sbc	r19, r1
    3ca0:	21 15       	cp	r18, r1
    3ca2:	31 05       	cpc	r19, r1
    3ca4:	c9 f7       	brne	.-14     	; 0x3c98 <shiftOut+0x5c6>
    3ca6:	3c c0       	rjmp	.+120    	; 0x3d20 <shiftOut+0x64e>
		if (timer == 5500) return;  // > 3ms
	}	


	//cycle thru sensitivities
	for (unsigned char MOUSE_SENSITIVITY=0; MOUSE_SENSITIVITY<3; MOUSE_SENSITIVITY++)
    3ca8:	81 15       	cp	r24, r1
    3caa:	2c e0       	ldi	r18, 0x0C	; 12
    3cac:	92 07       	cpc	r25, r18
    3cae:	c9 f6       	brne	.-78     	; 0x3c62 <shiftOut+0x590>
    3cb0:	37 c0       	rjmp	.+110    	; 0x3d20 <shiftOut+0x64e>
    3cb2:	55 e0       	ldi	r21, 0x05	; 5
    3cb4:	5a 95       	dec	r21
    3cb6:	f1 f7       	brne	.-4      	; 0x3cb4 <shiftOut+0x5e2>
    3cb8:	00 00       	nop
	/////////////////////////////////////////////////////////////////	
	/////////////////////////////////////////////////////////////////
	
	//wait for clock and clock out the payload 	
	_delay_us(1);//clear poll
	MODE = pad_cnt;//unset as it may stop clocking 
    3cba:	81 e0       	ldi	r24, 0x01	; 1
    3cbc:	80 93 19 03 	sts	0x0319, r24
    3cc0:	80 e1       	ldi	r24, 0x10	; 16
    3cc2:	90 e0       	ldi	r25, 0x00	; 0
	unsigned int timer = 1; 			

	//this clock is very fast but there is just enough to check for a clock. The clock is also not consistant. 
	unsigned int bit=1;
    3cc4:	21 e0       	ldi	r18, 0x01	; 1
    3cc6:	30 e0       	ldi	r19, 0x00	; 0
	for ( int b = 0; b <  16; b ++) 
	{
		if ( data & bit) PORTD &= ~DATA1; else PORTD |= DATA1; 		
    3cc8:	a9 01       	movw	r20, r18
    3cca:	4e 23       	and	r20, r30
    3ccc:	5f 23       	and	r21, r31
    3cce:	45 2b       	or	r20, r21
    3cd0:	21 f0       	breq	.+8      	; 0x3cda <shiftOut+0x608>
    3cd2:	5d 98       	cbi	0x0b, 5	; 11
	_delay_us(1);//clear poll
	MODE = pad_cnt;//unset as it may stop clocking 
	unsigned int timer = 1; 			

	//this clock is very fast but there is just enough to check for a clock. The clock is also not consistant. 
	unsigned int bit=1;
    3cd4:	41 e0       	ldi	r20, 0x01	; 1
    3cd6:	50 e0       	ldi	r21, 0x00	; 0
    3cd8:	02 c0       	rjmp	.+4      	; 0x3cde <shiftOut+0x60c>
	for ( int b = 0; b <  16; b ++) 
	{
		if ( data & bit) PORTD &= ~DATA1; else PORTD |= DATA1; 		
    3cda:	5d 9a       	sbi	0x0b, 5	; 11
    3cdc:	fb cf       	rjmp	.-10     	; 0x3cd4 <shiftOut+0x602>
		while (PIND & CLOCK) {timer++;} //look for clock
    3cde:	4f 9b       	sbis	0x09, 7	; 9
    3ce0:	03 c0       	rjmp	.+6      	; 0x3ce8 <shiftOut+0x616>
    3ce2:	4f 5f       	subi	r20, 0xFF	; 255
    3ce4:	5f 4f       	sbci	r21, 0xFF	; 255
    3ce6:	fb cf       	rjmp	.-10     	; 0x3cde <shiftOut+0x60c>
		if (timer > 15000 )  return;  //just exit out if expired after 4ms or so (had to extend for cannon fodder) was 8000
    3ce8:	49 39       	cpi	r20, 0x99	; 153
    3cea:	5a 43       	sbci	r21, 0x3A	; 58
    3cec:	c8 f4       	brcc	.+50     	; 0x3d20 <shiftOut+0x64e>
		timer = 1; 	//reset count. NOTE the first count is much longer 
		bit <<= 1;
    3cee:	22 0f       	add	r18, r18
    3cf0:	33 1f       	adc	r19, r19
    3cf2:	01 97       	sbiw	r24, 0x01	; 1
	MODE = pad_cnt;//unset as it may stop clocking 
	unsigned int timer = 1; 			

	//this clock is very fast but there is just enough to check for a clock. The clock is also not consistant. 
	unsigned int bit=1;
	for ( int b = 0; b <  16; b ++) 
    3cf4:	00 97       	sbiw	r24, 0x00	; 0
    3cf6:	41 f7       	brne	.-48     	; 0x3cc8 <shiftOut+0x5f6>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3cf8:	8f e9       	ldi	r24, 0x9F	; 159
    3cfa:	9f e0       	ldi	r25, 0x0F	; 15
    3cfc:	01 97       	sbiw	r24, 0x01	; 1
    3cfe:	f1 f7       	brne	.-4      	; 0x3cfc <shiftOut+0x62a>
    3d00:	00 c0       	rjmp	.+0      	; 0x3d02 <shiftOut+0x630>
    3d02:	00 00       	nop
		if (timer > 15000 )  return;  //just exit out if expired after 4ms or so (had to extend for cannon fodder) was 8000
		timer = 1; 	//reset count. NOTE the first count is much longer 
		bit <<= 1;
	}
	_delay_ms(1); //some games try to reset sensitivity, we do not need this, so skip it.
	MODE = pad_mse;//good read reset
    3d04:	84 e0       	ldi	r24, 0x04	; 4
    3d06:	80 93 19 03 	sts	0x0319, r24
    3d0a:	0a c0       	rjmp	.+20     	; 0x3d20 <shiftOut+0x64e>
	}

	//(? not sure why we'd want to do this, if somethign goes wrong then all button get ressed? - does it not make more send to leave high?) 
	//we do not do this on return if no data seen, so that will leave it high and that is good but I just do not see why to go low?
	//leaving like this for now, I'm guessing we coppied the controller?
	PORTD &= ~DATA1;//bring DATA1 lines low. 
    3d0c:	5d 98       	cbi	0x0b, 5	; 11
	PORTD &= ~DATA2;
    3d0e:	5c 98       	cbi	0x0b, 4	; 11
	PORTC &= ~DATA3;
    3d10:	46 98       	cbi	0x08, 6	; 8
    3d12:	06 c0       	rjmp	.+12     	; 0x3d20 <shiftOut+0x64e>

				
			//////////////////
			// apply data Y //
			//////////////////
			if (useWalls && mouseY_now >     (BottomWallLimit-15)) mouse_data = 0xFE;
    3d14:	4e ef       	ldi	r20, 0xFE	; 254
    3d16:	50 e0       	ldi	r21, 0x00	; 0
    3d18:	d1 ce       	rjmp	.-606    	; 0x3abc <shiftOut+0x3ea>
			else if (useWalls && mouseY_now <(TopWallLimit+ 15)) mouse_data = 0xFF;
    3d1a:	4f ef       	ldi	r20, 0xFF	; 255
    3d1c:	50 e0       	ldi	r21, 0x00	; 0
    3d1e:	ce ce       	rjmp	.-612    	; 0x3abc <shiftOut+0x3ea>
	//we do not do this on return if no data seen, so that will leave it high and that is good but I just do not see why to go low?
	//leaving like this for now, I'm guessing we coppied the controller?
	PORTD &= ~DATA1;//bring DATA1 lines low. 
	PORTD &= ~DATA2;
	PORTC &= ~DATA3;
}
    3d20:	0f 90       	pop	r0
    3d22:	df 91       	pop	r29
    3d24:	cf 91       	pop	r28
    3d26:	1f 91       	pop	r17
    3d28:	0f 91       	pop	r16
    3d2a:	ff 90       	pop	r15
    3d2c:	ef 90       	pop	r14
    3d2e:	08 95       	ret

00003d30 <Update>:
  
}

void Update(void)
{
	DDRD  |= DATA1;// out
    3d30:	55 9a       	sbi	0x0a, 5	; 10
	DDRD  |= DATA2;// out
    3d32:	54 9a       	sbi	0x0a, 4	; 10
	DDRC  |= DATA3;// out
    3d34:	3e 9a       	sbi	0x07, 6	; 7
		
	shiftOut(0);
    3d36:	80 e0       	ldi	r24, 0x00	; 0
    3d38:	90 e0       	ldi	r25, 0x00	; 0
    3d3a:	cb dc       	rcall	.-1642   	; 0x36d2 <shiftOut>
    3d3c:	80 91 65 03 	lds	r24, 0x0365

	if (Console.Type  == NES) shiftOut(1);//redundant check
    3d40:	81 32       	cpi	r24, 0x21	; 33
    3d42:	19 f4       	brne	.+6      	; 0x3d4a <Update+0x1a>
    3d44:	81 e0       	ldi	r24, 0x01	; 1
    3d46:	90 e0       	ldi	r25, 0x00	; 0
    3d48:	c4 dc       	rcall	.-1656   	; 0x36d2 <shiftOut>
    3d4a:	80 91 65 03 	lds	r24, 0x0365
	if (Console.Type  == NES) shiftOut(1);//redundant check 2 //punchout does 4 total...
    3d4e:	81 32       	cpi	r24, 0x21	; 33
    3d50:	19 f4       	brne	.+6      	; 0x3d58 <Update+0x28>
    3d52:	81 e0       	ldi	r24, 0x01	; 1
    3d54:	90 e0       	ldi	r25, 0x00	; 0
    3d56:	bd dc       	rcall	.-1670   	; 0x36d2 <shiftOut>
    3d58:	80 91 65 03 	lds	r24, 0x0365
    3d5c:	81 32       	cpi	r24, 0x21	; 33
	if (Console.Type  == NES) shiftOut(1);//redundant check 3 //punchout does 4 total...
    3d5e:	19 f4       	brne	.+6      	; 0x3d66 <Update+0x36>
    3d60:	81 e0       	ldi	r24, 0x01	; 1
    3d62:	90 e0       	ldi	r25, 0x00	; 0
    3d64:	b6 dc       	rcall	.-1684   	; 0x36d2 <shiftOut>
    3d66:	87 ec       	ldi	r24, 0xC7	; 199
    3d68:	90 e0       	ldi	r25, 0x00	; 0
    3d6a:	01 97       	sbiw	r24, 0x01	; 1
    3d6c:	f1 f7       	brne	.-4      	; 0x3d6a <Update+0x3a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    3d6e:	00 c0       	rjmp	.+0      	; 0x3d70 <Update+0x40>
    3d70:	00 00       	nop
    3d72:	08 95       	ret

00003d74 <nesGetConsole>:
    3d74:	88 e5       	ldi	r24, 0x58	; 88
    3d76:	91 e0       	ldi	r25, 0x01	; 1
    3d78:	08 95       	ret

00003d7a <DoWork>:

/*********** prototypes *************/
static void Init(void); 
static void Update(void);
static unsigned char Probe(void);
static void DoWork(void){};
    3d7a:	08 95       	ret

00003d7c <Init>:
static unsigned int timer=1;
static unsigned device;

void Init(void)
{
	DDRD &= ~_dataIn_bit_;// in data
    3d7c:	51 98       	cbi	0x0a, 1	; 10
	_dataIn_port_ |= _dataIn_bit_;// high 
    3d7e:	59 9a       	sbi	0x0b, 1	; 11
	DDRC &= ~_clock_bit_; 
    3d80:	3e 98       	cbi	0x07, 6	; 7
	_clock_port_ |= _clock_bit_; 
    3d82:	46 9a       	sbi	0x08, 6	; 8
	DDRD |= _dataOut_bit_;//out
    3d84:	50 9a       	sbi	0x0a, 0	; 10
	device = _digital_mode_;
    3d86:	10 92 21 03 	sts	0x0321, r1
    3d8a:	10 92 20 03 	sts	0x0320, r1
    3d8e:	08 95       	ret

00003d90 <CleanUp>:
}
 void CleanUp(void)
{
    3d90:	08 95       	ret

00003d92 <SendData>:
   
}
void SendData (unsigned char data, unsigned char size)
{
	for ( unsigned int d = size  ; d ; d >>= 1 )   //timing was tight here, int allows for a 0, other methods dint work
    3d92:	70 e0       	ldi	r23, 0x00	; 0
	{
		if ( data & d ) _dataOut_port_ |= _dataOut_bit_; else _dataOut_port_&= ~_dataOut_bit_;WHILE_PULSE_IS_LO;WHILE_PULSE_IS_HI ;//D
    3d94:	90 e0       	ldi	r25, 0x00	; 0
{
   
}
void SendData (unsigned char data, unsigned char size)
{
	for ( unsigned int d = size  ; d ; d >>= 1 )   //timing was tight here, int allows for a 0, other methods dint work
    3d96:	61 15       	cp	r22, r1
    3d98:	71 05       	cpc	r23, r1
    3d9a:	69 f1       	breq	.+90     	; 0x3df6 <SendData+0x64>
	{
		if ( data & d ) _dataOut_port_ |= _dataOut_bit_; else _dataOut_port_&= ~_dataOut_bit_;WHILE_PULSE_IS_LO;WHILE_PULSE_IS_HI ;//D
    3d9c:	9b 01       	movw	r18, r22
    3d9e:	28 23       	and	r18, r24
    3da0:	39 23       	and	r19, r25
    3da2:	23 2b       	or	r18, r19
    3da4:	11 f0       	breq	.+4      	; 0x3daa <SendData+0x18>
    3da6:	58 9a       	sbi	0x0b, 0	; 11
    3da8:	0a c0       	rjmp	.+20     	; 0x3dbe <SendData+0x2c>
    3daa:	58 98       	cbi	0x0b, 0	; 11
    3dac:	08 c0       	rjmp	.+16     	; 0x3dbe <SendData+0x2c>
    3dae:	36 99       	sbic	0x06, 6	; 6
    3db0:	17 c0       	rjmp	.+46     	; 0x3de0 <SendData+0x4e>
    3db2:	2f 5f       	subi	r18, 0xFF	; 255
    3db4:	3f 4f       	sbci	r19, 0xFF	; 255
    3db6:	30 93 6d 01 	sts	0x016D, r19
    3dba:	20 93 6c 01 	sts	0x016C, r18
    3dbe:	20 91 6c 01 	lds	r18, 0x016C
    3dc2:	30 91 6d 01 	lds	r19, 0x016D
    3dc6:	28 38       	cpi	r18, 0x88	; 136
    3dc8:	40 e9       	ldi	r20, 0x90	; 144
    3dca:	34 07       	cpc	r19, r20
    3dcc:	80 f3       	brcs	.-32     	; 0x3dae <SendData+0x1c>
    3dce:	08 c0       	rjmp	.+16     	; 0x3de0 <SendData+0x4e>
    3dd0:	36 9b       	sbis	0x06, 6	; 6
    3dd2:	0e c0       	rjmp	.+28     	; 0x3df0 <SendData+0x5e>
    3dd4:	2f 5f       	subi	r18, 0xFF	; 255
    3dd6:	3f 4f       	sbci	r19, 0xFF	; 255
    3dd8:	30 93 6d 01 	sts	0x016D, r19
    3ddc:	20 93 6c 01 	sts	0x016C, r18
    3de0:	20 91 6c 01 	lds	r18, 0x016C
    3de4:	30 91 6d 01 	lds	r19, 0x016D
    3de8:	28 38       	cpi	r18, 0x88	; 136
    3dea:	40 e9       	ldi	r20, 0x90	; 144
    3dec:	34 07       	cpc	r19, r20
    3dee:	80 f3       	brcs	.-32     	; 0x3dd0 <SendData+0x3e>
{
   
}
void SendData (unsigned char data, unsigned char size)
{
	for ( unsigned int d = size  ; d ; d >>= 1 )   //timing was tight here, int allows for a 0, other methods dint work
    3df0:	76 95       	lsr	r23
    3df2:	67 95       	ror	r22
    3df4:	d0 cf       	rjmp	.-96     	; 0x3d96 <SendData+0x4>
	{
		if ( data & d ) _dataOut_port_ |= _dataOut_bit_; else _dataOut_port_&= ~_dataOut_bit_;WHILE_PULSE_IS_LO;WHILE_PULSE_IS_HI ;//D
		
	} _dataOut_port_&= ~_dataOut_bit_;//alweays leave low.
    3df6:	58 98       	cbi	0x0b, 0	; 11
    3df8:	08 95       	ret

00003dfa <Update>:
}	

void Update(void)
{	//info https://3dodev.com/documentation/hardware/opera/pbus
    3dfa:	df 92       	push	r13
    3dfc:	ef 92       	push	r14
    3dfe:	ff 92       	push	r15
    3e00:	0f 93       	push	r16
    3e02:	1f 93       	push	r17
    3e04:	cf 93       	push	r28
    3e06:	df 93       	push	r29

	//the Joystick ID is 0001, 0010 or 0011  . The controller can not press both (00). 
	 
	unsigned int data=0x8000; 
	unsigned int analogButtons; 
	int x = reportBuffer[X_MAIN_STICK];
    3e08:	d0 90 6b 03 	lds	r13, 0x036B
	int y = reportBuffer[Y_MAIN_STICK];
    3e0c:	e0 90 6c 03 	lds	r14, 0x036C
	int t = reportBuffer[SLIDER];
    3e10:	f0 90 70 03 	lds	r15, 0x0370
 
	//why didnt the flighgt stick work as digital, did we bust digital?
	if (Controller.DpadOnly) device = _digital_mode_;
    3e14:	80 91 83 03 	lds	r24, 0x0383
    3e18:	88 23       	and	r24, r24
    3e1a:	29 f0       	breq	.+10     	; 0x3e26 <Update+0x2c>
    3e1c:	10 92 21 03 	sts	0x0321, r1
    3e20:	10 92 20 03 	sts	0x0320, r1
    3e24:	0a c0       	rjmp	.+20     	; 0x3e3a <Update+0x40>
 	else if ( (reportBuffer[X_MAIN_STICK] > 200 || reportBuffer[X_MAIN_STICK] < 50)  ) device = _analog_mode_;
    3e26:	8e ec       	ldi	r24, 0xCE	; 206
    3e28:	8d 0d       	add	r24, r13
    3e2a:	87 39       	cpi	r24, 0x97	; 151
    3e2c:	30 f0       	brcs	.+12     	; 0x3e3a <Update+0x40>
    3e2e:	81 e0       	ldi	r24, 0x01	; 1
    3e30:	90 e0       	ldi	r25, 0x00	; 0
    3e32:	90 93 21 03 	sts	0x0321, r25
    3e36:	80 93 20 03 	sts	0x0320, r24
 
 
	if (device == _analog_mode_) 
    3e3a:	80 91 20 03 	lds	r24, 0x0320
    3e3e:	90 91 21 03 	lds	r25, 0x0321
    3e42:	20 91 6a 03 	lds	r18, 0x036A
    3e46:	30 91 68 03 	lds	r19, 0x0368
    3e4a:	40 91 69 03 	lds	r20, 0x0369
    3e4e:	01 97       	sbiw	r24, 0x01	; 1
    3e50:	41 f5       	brne	.+80     	; 0x3ea2 <Update+0xa8>
		// S B C are on stick
		// 4th buttton is trigger ( on stick back)
		// (l) (s)
		// (r) (p)
		//this is a tru hat.
		if (reportBuffer[HAT] == DPAD_DOWN	 )    analogButtons |=0x0400;//D
    3e52:	24 30       	cpi	r18, 0x04	; 4
    3e54:	49 f0       	breq	.+18     	; 0x3e68 <Update+0x6e>
		else if (reportBuffer[HAT] == DPAD_UP	) analogButtons |=0x0800;//U
    3e56:	22 23       	and	r18, r18
    3e58:	51 f0       	breq	.+20     	; 0x3e6e <Update+0x74>
		else if (reportBuffer[HAT] == DPAD_RIGHT) analogButtons |= 0x200;//R
    3e5a:	22 30       	cpi	r18, 0x02	; 2
    3e5c:	59 f0       	breq	.+22     	; 0x3e74 <Update+0x7a>
		else if (reportBuffer[HAT] == DPAD_LEFT	) analogButtons |= 0x100;//L
    3e5e:	26 30       	cpi	r18, 0x06	; 6
    3e60:	61 f0       	breq	.+24     	; 0x3e7a <Update+0x80>
 
 
	if (device == _analog_mode_) 
	{
		data = 0x017b; //ID goes in digital  buttons. 
		analogButtons=0;
    3e62:	00 e0       	ldi	r16, 0x00	; 0
    3e64:	10 e0       	ldi	r17, 0x00	; 0
    3e66:	0b c0       	rjmp	.+22     	; 0x3e7e <Update+0x84>
		// S B C are on stick
		// 4th buttton is trigger ( on stick back)
		// (l) (s)
		// (r) (p)
		//this is a tru hat.
		if (reportBuffer[HAT] == DPAD_DOWN	 )    analogButtons |=0x0400;//D
    3e68:	00 e0       	ldi	r16, 0x00	; 0
    3e6a:	14 e0       	ldi	r17, 0x04	; 4
    3e6c:	08 c0       	rjmp	.+16     	; 0x3e7e <Update+0x84>
		else if (reportBuffer[HAT] == DPAD_UP	) analogButtons |=0x0800;//U
    3e6e:	00 e0       	ldi	r16, 0x00	; 0
    3e70:	18 e0       	ldi	r17, 0x08	; 8
    3e72:	05 c0       	rjmp	.+10     	; 0x3e7e <Update+0x84>
		else if (reportBuffer[HAT] == DPAD_RIGHT) analogButtons |= 0x200;//R
    3e74:	00 e0       	ldi	r16, 0x00	; 0
    3e76:	12 e0       	ldi	r17, 0x02	; 2
    3e78:	02 c0       	rjmp	.+4      	; 0x3e7e <Update+0x84>
		else if (reportBuffer[HAT] == DPAD_LEFT	) analogButtons |= 0x100;//L
    3e7a:	00 e0       	ldi	r16, 0x00	; 0
    3e7c:	11 e0       	ldi	r17, 0x01	; 1
		
		if (reportBuffer[BUTTON_ROW_1] & 0x01)    analogButtons |=0x4000;//A
    3e7e:	30 fd       	sbrc	r19, 0
    3e80:	10 64       	ori	r17, 0x40	; 64
		if (reportBuffer[BUTTON_ROW_1] & 0x02)    analogButtons |=0x1000;//B
    3e82:	31 fd       	sbrc	r19, 1
    3e84:	10 61       	ori	r17, 0x10	; 16
		                                         
		if (reportBuffer[BUTTON_ROW_1] & 0x40)    analogButtons |=0x8000;//fire	- mocking BB, coudl also maybe use L and chane on BB for consistancy
    3e86:	36 fd       	sbrc	r19, 6
    3e88:	10 68       	ori	r17, 0x80	; 128
		if (reportBuffer[BUTTON_ROW_1] & 0x80)    analogButtons |=0x1000;//C
    3e8a:	37 fd       	sbrc	r19, 7
    3e8c:	10 61       	ori	r17, 0x10	; 16
		if (reportBuffer[BUTTON_ROW_1] & 0x20)    analogButtons |=  0x80;//P
    3e8e:	35 fd       	sbrc	r19, 5
    3e90:	00 68       	ori	r16, 0x80	; 128
		if (reportBuffer[BUTTON_ROW_1] & 0x10)    analogButtons |=  0x40;//X
    3e92:	34 fd       	sbrc	r19, 4
    3e94:	00 64       	ori	r16, 0x40	; 64
		if (reportBuffer[BUTTON_ROW_2] & 0x02)    analogButtons |=  0x10;//R
    3e96:	41 fd       	sbrc	r20, 1
    3e98:	00 61       	ori	r16, 0x10	; 16
		if (reportBuffer[BUTTON_ROW_2] & 0x01)    analogButtons |=  0x20;//L
    3e9a:	40 ff       	sbrs	r20, 0
    3e9c:	37 c0       	rjmp	.+110    	; 0x3f0c <Update+0x112>
    3e9e:	00 62       	ori	r16, 0x20	; 32
    3ea0:	35 c0       	rjmp	.+106    	; 0x3f0c <Update+0x112>
		//10 bits X
		//10 bits Y
	}*/
	else //could also use bit juggler code....
	{
		if (reportBuffer[HAT] == DPAD_DOWNLEFT )data |= 0x2200;
    3ea2:	25 30       	cpi	r18, 0x05	; 5
    3ea4:	09 f4       	brne	.+2      	; 0x3ea8 <Update+0xae>
    3ea6:	04 c1       	rjmp	.+520    	; 0x40b0 <Update+0x2b6>
		if (reportBuffer[HAT] == DPAD_UPLEFT   )data |= 0x2400;
    3ea8:	27 30       	cpi	r18, 0x07	; 7
    3eaa:	09 f4       	brne	.+2      	; 0x3eae <Update+0xb4>
    3eac:	04 c1       	rjmp	.+520    	; 0x40b6 <Update+0x2bc>
		if (reportBuffer[HAT] == DPAD_UPRIGHT  )data |= 0x1400;
    3eae:	21 30       	cpi	r18, 0x01	; 1
    3eb0:	59 f0       	breq	.+22     	; 0x3ec8 <Update+0xce>
		if (reportBuffer[HAT] == DPAD_DOWNRIGHT)data |= 0x1200;
    3eb2:	23 30       	cpi	r18, 0x03	; 3
    3eb4:	b1 f0       	breq	.+44     	; 0x3ee2 <Update+0xe8>
		
		if (reportBuffer[HAT] == DPAD_DOWN	 )  data |=0x1000;//D
    3eb6:	24 30       	cpi	r18, 0x04	; 4
    3eb8:	b9 f0       	breq	.+46     	; 0x3ee8 <Update+0xee>
void Update(void)
{	//info https://3dodev.com/documentation/hardware/opera/pbus

	//the Joystick ID is 0001, 0010 or 0011  . The controller can not press both (00). 
	 
	unsigned int data=0x8000; 
    3eba:	c0 e0       	ldi	r28, 0x00	; 0
    3ebc:	d0 e8       	ldi	r29, 0x80	; 128
		if (reportBuffer[HAT] == DPAD_UPLEFT   )data |= 0x2400;
		if (reportBuffer[HAT] == DPAD_UPRIGHT  )data |= 0x1400;
		if (reportBuffer[HAT] == DPAD_DOWNRIGHT)data |= 0x1200;
		
		if (reportBuffer[HAT] == DPAD_DOWN	 )  data |=0x1000;//D
		if (reportBuffer[HAT] == DPAD_UP	 )  data |=0x0800;//U
    3ebe:	21 11       	cpse	r18, r1
    3ec0:	06 c0       	rjmp	.+12     	; 0x3ece <Update+0xd4>
    3ec2:	c0 e0       	ldi	r28, 0x00	; 0
    3ec4:	d8 e8       	ldi	r29, 0x88	; 136
    3ec6:	12 c0       	rjmp	.+36     	; 0x3eec <Update+0xf2>
	}*/
	else //could also use bit juggler code....
	{
		if (reportBuffer[HAT] == DPAD_DOWNLEFT )data |= 0x2200;
		if (reportBuffer[HAT] == DPAD_UPLEFT   )data |= 0x2400;
		if (reportBuffer[HAT] == DPAD_UPRIGHT  )data |= 0x1400;
    3ec8:	c0 e0       	ldi	r28, 0x00	; 0
    3eca:	d4 e9       	ldi	r29, 0x94	; 148
    3ecc:	0f c0       	rjmp	.+30     	; 0x3eec <Update+0xf2>
		if (reportBuffer[HAT] == DPAD_DOWNRIGHT)data |= 0x1200;
		
		if (reportBuffer[HAT] == DPAD_DOWN	 )  data |=0x1000;//D
		if (reportBuffer[HAT] == DPAD_UP	 )  data |=0x0800;//U
		if (reportBuffer[HAT] == DPAD_RIGHT	 )  data |= 0x400;//R
    3ece:	22 30       	cpi	r18, 0x02	; 2
    3ed0:	19 f4       	brne	.+6      	; 0x3ed8 <Update+0xde>
    3ed2:	c0 e0       	ldi	r28, 0x00	; 0
    3ed4:	d4 e8       	ldi	r29, 0x84	; 132
    3ed6:	0a c0       	rjmp	.+20     	; 0x3eec <Update+0xf2>
		if (reportBuffer[HAT] == DPAD_LEFT	 )  data |= 0x200;//L
    3ed8:	26 30       	cpi	r18, 0x06	; 6
    3eda:	41 f4       	brne	.+16     	; 0x3eec <Update+0xf2>
    3edc:	c0 e0       	ldi	r28, 0x00	; 0
    3ede:	d2 e8       	ldi	r29, 0x82	; 130
    3ee0:	05 c0       	rjmp	.+10     	; 0x3eec <Update+0xf2>
	else //could also use bit juggler code....
	{
		if (reportBuffer[HAT] == DPAD_DOWNLEFT )data |= 0x2200;
		if (reportBuffer[HAT] == DPAD_UPLEFT   )data |= 0x2400;
		if (reportBuffer[HAT] == DPAD_UPRIGHT  )data |= 0x1400;
		if (reportBuffer[HAT] == DPAD_DOWNRIGHT)data |= 0x1200;
    3ee2:	c0 e0       	ldi	r28, 0x00	; 0
    3ee4:	d2 e9       	ldi	r29, 0x92	; 146
    3ee6:	02 c0       	rjmp	.+4      	; 0x3eec <Update+0xf2>
		
		if (reportBuffer[HAT] == DPAD_DOWN	 )  data |=0x1000;//D
    3ee8:	c0 e0       	ldi	r28, 0x00	; 0
    3eea:	d0 e9       	ldi	r29, 0x90	; 144
		if (reportBuffer[HAT] == DPAD_UP	 )  data |=0x0800;//U
		if (reportBuffer[HAT] == DPAD_RIGHT	 )  data |= 0x400;//R
		if (reportBuffer[HAT] == DPAD_LEFT	 )  data |= 0x200;//L
		if (reportBuffer[BUTTON_ROW_1] & 0x01)  data |= 0x100;//A
    3eec:	30 fd       	sbrc	r19, 0
    3eee:	d1 60       	ori	r29, 0x01	; 1
		if (reportBuffer[BUTTON_ROW_1] & 0x02)  data |= 0x80;//B
    3ef0:	31 fd       	sbrc	r19, 1
    3ef2:	c0 68       	ori	r28, 0x80	; 128
												 				
		if (reportBuffer[BUTTON_ROW_1] & 0x80)  data |=  0x40;//C
    3ef4:	37 fd       	sbrc	r19, 7
    3ef6:	c0 64       	ori	r28, 0x40	; 64
		if (reportBuffer[BUTTON_ROW_1] & 0x20)  data |=  0x20;//P
    3ef8:	35 fd       	sbrc	r19, 5
    3efa:	c0 62       	ori	r28, 0x20	; 32
		if (reportBuffer[BUTTON_ROW_1] & 0x10)  data |=  0x10;//X
    3efc:	34 fd       	sbrc	r19, 4
    3efe:	c0 61       	ori	r28, 0x10	; 16
		if (reportBuffer[BUTTON_ROW_2] & 0x02)  data |=  0x08;//R
    3f00:	41 fd       	sbrc	r20, 1
    3f02:	c8 60       	ori	r28, 0x08	; 8
		if (reportBuffer[BUTTON_ROW_2] & 0x01)  data |=  0x04;//L
    3f04:	40 ff       	sbrs	r20, 0
    3f06:	04 c0       	rjmp	.+8      	; 0x3f10 <Update+0x116>
    3f08:	c4 60       	ori	r28, 0x04	; 4
    3f0a:	02 c0       	rjmp	.+4      	; 0x3f10 <Update+0x116>
 	else if ( (reportBuffer[X_MAIN_STICK] > 200 || reportBuffer[X_MAIN_STICK] < 50)  ) device = _analog_mode_;
 
 
	if (device == _analog_mode_) 
	{
		data = 0x017b; //ID goes in digital  buttons. 
    3f0c:	cb e7       	ldi	r28, 0x7B	; 123
    3f0e:	d1 e0       	ldi	r29, 0x01	; 1
    3f10:	20 ed       	ldi	r18, 0xD0	; 208
    3f12:	37 e0       	ldi	r19, 0x07	; 7
	//clock    :_____~~~~~__~_~_~_~_~_~_~_~_~_~_
	//data out :          |data|
    //data in  :          |____________________|
	
	//the best way to find the end is just to use the n64 trick (4 consequtive lows. We need to reply only on clock. Best to do this here to waste time with BB instead of in here. 
	unsigned char line=0;
    3f14:	80 e0       	ldi	r24, 0x00	; 0
	int to=0;
 
	while (line < 5)//use 5 hits
	{//this code must be less then 1us to work
		if (! (_clock_pin_ & _clock_bit_) ) line++; else line = 0; //look for 4, in a row.
    3f16:	36 99       	sbic	0x06, 6	; 6
    3f18:	02 c0       	rjmp	.+4      	; 0x3f1e <Update+0x124>
    3f1a:	8f 5f       	subi	r24, 0xFF	; 255
    3f1c:	01 c0       	rjmp	.+2      	; 0x3f20 <Update+0x126>
    3f1e:	80 e0       	ldi	r24, 0x00	; 0
    3f20:	90 e1       	ldi	r25, 0x10	; 16
    3f22:	9a 95       	dec	r25
    3f24:	f1 f7       	brne	.-4      	; 0x3f22 <Update+0x128>
    3f26:	21 50       	subi	r18, 0x01	; 1
    3f28:	31 09       	sbc	r19, r1
		to++;
		_delay_us(3);//bits are 3/4 us
		if (to == 2000) {return;}//something is bad wrong...
    3f2a:	21 15       	cp	r18, r1
    3f2c:	31 05       	cpc	r19, r1
    3f2e:	09 f4       	brne	.+2      	; 0x3f32 <Update+0x138>
    3f30:	c5 c0       	rjmp	.+394    	; 0x40bc <Update+0x2c2>
	
	//the best way to find the end is just to use the n64 trick (4 consequtive lows. We need to reply only on clock. Best to do this here to waste time with BB instead of in here. 
	unsigned char line=0;
	int to=0;
 
	while (line < 5)//use 5 hits
    3f32:	85 30       	cpi	r24, 0x05	; 5
    3f34:	80 f3       	brcs	.-32     	; 0x3f16 <Update+0x11c>

 
	////////////////////////
	// lead in signatur   //
	////////////////////////
	DDRD |= _dataOut_bit_;//out
    3f36:	50 9a       	sbi	0x0a, 0	; 10
	WHILE_PULSE_IS_LO 				//wait during low
    3f38:	20 91 6c 01 	lds	r18, 0x016C
    3f3c:	30 91 6d 01 	lds	r19, 0x016D
    3f40:	28 38       	cpi	r18, 0x88	; 136
    3f42:	80 e9       	ldi	r24, 0x90	; 144
    3f44:	38 07       	cpc	r19, r24
    3f46:	48 f4       	brcc	.+18     	; 0x3f5a <Update+0x160>
    3f48:	36 99       	sbic	0x06, 6	; 6
    3f4a:	13 c0       	rjmp	.+38     	; 0x3f72 <Update+0x178>
    3f4c:	2f 5f       	subi	r18, 0xFF	; 255
    3f4e:	3f 4f       	sbci	r19, 0xFF	; 255
    3f50:	30 93 6d 01 	sts	0x016D, r19
    3f54:	20 93 6c 01 	sts	0x016C, r18
    3f58:	ef cf       	rjmp	.-34     	; 0x3f38 <Update+0x13e>
	if (timer == MAX_TIME) return;  //just to be sure.
    3f5a:	28 38       	cpi	r18, 0x88	; 136
    3f5c:	30 49       	sbci	r19, 0x90	; 144
    3f5e:	49 f4       	brne	.+18     	; 0x3f72 <Update+0x178>
    3f60:	ad c0       	rjmp	.+346    	; 0x40bc <Update+0x2c2>
	WHILE_PULSE_IS_HI;				//end of latch in, data starts in 500 us 	
    3f62:	36 9b       	sbis	0x06, 6	; 6
    3f64:	0e c0       	rjmp	.+28     	; 0x3f82 <Update+0x188>
    3f66:	2f 5f       	subi	r18, 0xFF	; 255
    3f68:	3f 4f       	sbci	r19, 0xFF	; 255
    3f6a:	30 93 6d 01 	sts	0x016D, r19
    3f6e:	20 93 6c 01 	sts	0x016C, r18
    3f72:	20 91 6c 01 	lds	r18, 0x016C
    3f76:	30 91 6d 01 	lds	r19, 0x016D
    3f7a:	28 38       	cpi	r18, 0x88	; 136
    3f7c:	80 e9       	ldi	r24, 0x90	; 144
    3f7e:	38 07       	cpc	r19, r24
    3f80:	80 f3       	brcs	.-32     	; 0x3f62 <Update+0x168>
	//this is actully a bit and does need to go low for some mode that the analog conrtoller uses, maybe mouse too.
	if (device == _analog_mode_)   _dataOut_port_ &= ~_dataOut_bit_; else _dataOut_port_ |= _dataOut_bit_; 
    3f82:	80 91 20 03 	lds	r24, 0x0320
    3f86:	90 91 21 03 	lds	r25, 0x0321
    3f8a:	01 97       	sbiw	r24, 0x01	; 1
    3f8c:	11 f4       	brne	.+4      	; 0x3f92 <Update+0x198>
    3f8e:	58 98       	cbi	0x0b, 0	; 11
    3f90:	0a c0       	rjmp	.+20     	; 0x3fa6 <Update+0x1ac>
    3f92:	58 9a       	sbi	0x0b, 0	; 11
    3f94:	08 c0       	rjmp	.+16     	; 0x3fa6 <Update+0x1ac>
	WHILE_PULSE_IS_LO				//sync 
    3f96:	36 99       	sbic	0x06, 6	; 6
    3f98:	0e c0       	rjmp	.+28     	; 0x3fb6 <Update+0x1bc>
    3f9a:	2f 5f       	subi	r18, 0xFF	; 255
    3f9c:	3f 4f       	sbci	r19, 0xFF	; 255
    3f9e:	30 93 6d 01 	sts	0x016D, r19
    3fa2:	20 93 6c 01 	sts	0x016C, r18
    3fa6:	20 91 6c 01 	lds	r18, 0x016C
    3faa:	30 91 6d 01 	lds	r19, 0x016D
    3fae:	28 38       	cpi	r18, 0x88	; 136
    3fb0:	90 e9       	ldi	r25, 0x90	; 144
    3fb2:	39 07       	cpc	r19, r25
    3fb4:	80 f3       	brcs	.-32     	; 0x3f96 <Update+0x19c>

	timer=1; //needed to prevent mature timeouts. 
    3fb6:	81 e0       	ldi	r24, 0x01	; 1
    3fb8:	90 e0       	ldi	r25, 0x00	; 0
    3fba:	90 93 6d 01 	sts	0x016D, r25
    3fbe:	80 93 6c 01 	sts	0x016C, r24
	
	if (data & 0x8000)  _dataOut_port_ |= _dataOut_bit_; else _dataOut_port_ &= ~_dataOut_bit_; //set first bit.
    3fc2:	d7 ff       	sbrs	r29, 7
    3fc4:	02 c0       	rjmp	.+4      	; 0x3fca <Update+0x1d0>
    3fc6:	58 9a       	sbi	0x0b, 0	; 11
    3fc8:	01 c0       	rjmp	.+2      	; 0x3fcc <Update+0x1d2>
    3fca:	58 98       	cbi	0x0b, 0	; 11
    3fcc:	85 e1       	ldi	r24, 0x15	; 21
    3fce:	8a 95       	dec	r24
    3fd0:	f1 f7       	brne	.-4      	; 0x3fce <Update+0x1d4>
    3fd2:	00 00       	nop
	_delay_us(4); //send off first bit. Only way to time it right and to check we are talking.
	if ((_clock_pin_ & _clock_bit_) != 0x00 ) //if its not low here, we are in the wrong place. 
    3fd4:	36 99       	sbic	0x06, 6	; 6
    3fd6:	6a c0       	rjmp	.+212    	; 0x40ac <Update+0x2b2>
		return;// no more to do.
	}
	////////////////////////
	// Player one digital //
	////////////////////////
	SendData (data>>8, _SIZE7); //send buttons omit first bit as we did it abouve
    3fd8:	60 e4       	ldi	r22, 0x40	; 64
    3fda:	8d 2f       	mov	r24, r29
    3fdc:	da de       	rcall	.-588    	; 0x3d92 <SendData>
    3fde:	60 e8       	ldi	r22, 0x80	; 128
	SendData (data, _SIZE8); // 
    3fe0:	8c 2f       	mov	r24, r28
    3fe2:	d7 de       	rcall	.-594    	; 0x3d92 <SendData>
    3fe4:	20 91 20 03 	lds	r18, 0x0320
	// Player two digital //
	//////////////////////// not uysed.
	//_dataOut_port_ &= ~ _dataOut_bit_; 
	//for ( d = 0 ; d < 16; d++ ) { WHILE_PULSE_IS_LO;WHILE_PULSE_IS_HI ;} //player 2 
	
	if (device == _digital_mode_) 
    3fe8:	30 91 21 03 	lds	r19, 0x0321
    3fec:	23 2b       	or	r18, r19
    3fee:	09 f4       	brne	.+2      	; 0x3ff2 <Update+0x1f8>
    3ff0:	5d c0       	rjmp	.+186    	; 0x40ac <Update+0x2b2>
    3ff2:	60 e8       	ldi	r22, 0x80	; 128
    3ff4:	88 e0       	ldi	r24, 0x08	; 8
	}
	 
	///////////////////////////
	//  Extended mode length //
	///////////////////////////
	SendData (8, _SIZE8); //send size
    3ff6:	cd de       	rcall	.-614    	; 0x3d92 <SendData>
    3ff8:	60 e8       	ldi	r22, 0x80	; 128
    3ffa:	8d 2d       	mov	r24, r13
    3ffc:	ca de       	rcall	.-620    	; 0x3d92 <SendData>

	SendData (x, _SIZE8); //send x
    3ffe:	82 e0       	ldi	r24, 0x02	; 2
    4000:	20 91 6c 01 	lds	r18, 0x016C
    4004:	30 91 6d 01 	lds	r19, 0x016D
	for ( char d = 0 ; d < 2; d ++)  { WHILE_PULSE_IS_LO;WHILE_PULSE_IS_HI ; }//padding
    4008:	28 38       	cpi	r18, 0x88	; 136
    400a:	90 e9       	ldi	r25, 0x90	; 144
    400c:	39 07       	cpc	r19, r25
    400e:	88 f4       	brcc	.+34     	; 0x4032 <Update+0x238>
    4010:	36 99       	sbic	0x06, 6	; 6
    4012:	0f c0       	rjmp	.+30     	; 0x4032 <Update+0x238>
    4014:	2f 5f       	subi	r18, 0xFF	; 255
    4016:	3f 4f       	sbci	r19, 0xFF	; 255
    4018:	30 93 6d 01 	sts	0x016D, r19
    401c:	20 93 6c 01 	sts	0x016C, r18
    4020:	ef cf       	rjmp	.-34     	; 0x4000 <Update+0x206>
    4022:	36 9b       	sbis	0x06, 6	; 6
    4024:	0e c0       	rjmp	.+28     	; 0x4042 <Update+0x248>
    4026:	2f 5f       	subi	r18, 0xFF	; 255
    4028:	3f 4f       	sbci	r19, 0xFF	; 255
    402a:	30 93 6d 01 	sts	0x016D, r19
    402e:	20 93 6c 01 	sts	0x016C, r18
    4032:	20 91 6c 01 	lds	r18, 0x016C
    4036:	30 91 6d 01 	lds	r19, 0x016D
    403a:	28 38       	cpi	r18, 0x88	; 136
    403c:	90 e9       	ldi	r25, 0x90	; 144
    403e:	39 07       	cpc	r19, r25
    4040:	80 f3       	brcs	.-32     	; 0x4022 <Update+0x228>
    4042:	81 50       	subi	r24, 0x01	; 1
    4044:	e9 f6       	brne	.-70     	; 0x4000 <Update+0x206>
    4046:	60 e8       	ldi	r22, 0x80	; 128
    4048:	8e 2d       	mov	r24, r14
    404a:	a3 de       	rcall	.-698    	; 0x3d92 <SendData>
    404c:	82 e0       	ldi	r24, 0x02	; 2
	
	SendData (y, _SIZE8); //send Y 
    404e:	20 91 6c 01 	lds	r18, 0x016C
    4052:	30 91 6d 01 	lds	r19, 0x016D
    4056:	28 38       	cpi	r18, 0x88	; 136
	for ( char d = 0 ; d < 2; d ++)  { WHILE_PULSE_IS_LO;WHILE_PULSE_IS_HI ; }//padding
    4058:	90 e9       	ldi	r25, 0x90	; 144
    405a:	39 07       	cpc	r19, r25
    405c:	88 f4       	brcc	.+34     	; 0x4080 <Update+0x286>
    405e:	36 99       	sbic	0x06, 6	; 6
    4060:	0f c0       	rjmp	.+30     	; 0x4080 <Update+0x286>
    4062:	2f 5f       	subi	r18, 0xFF	; 255
    4064:	3f 4f       	sbci	r19, 0xFF	; 255
    4066:	30 93 6d 01 	sts	0x016D, r19
    406a:	20 93 6c 01 	sts	0x016C, r18
    406e:	ef cf       	rjmp	.-34     	; 0x404e <Update+0x254>
    4070:	36 9b       	sbis	0x06, 6	; 6
    4072:	0e c0       	rjmp	.+28     	; 0x4090 <Update+0x296>
    4074:	2f 5f       	subi	r18, 0xFF	; 255
    4076:	3f 4f       	sbci	r19, 0xFF	; 255
    4078:	30 93 6d 01 	sts	0x016D, r19
    407c:	20 93 6c 01 	sts	0x016C, r18
    4080:	20 91 6c 01 	lds	r18, 0x016C
    4084:	30 91 6d 01 	lds	r19, 0x016D
    4088:	28 38       	cpi	r18, 0x88	; 136
    408a:	90 e9       	ldi	r25, 0x90	; 144
    408c:	39 07       	cpc	r19, r25
    408e:	80 f3       	brcs	.-32     	; 0x4070 <Update+0x276>
    4090:	81 50       	subi	r24, 0x01	; 1
    4092:	e9 f6       	brne	.-70     	; 0x404e <Update+0x254>
    4094:	60 e8       	ldi	r22, 0x80	; 128
    4096:	8f 2d       	mov	r24, r15
    4098:	7c de       	rcall	.-776    	; 0x3d92 <SendData>
    409a:	68 e0       	ldi	r22, 0x08	; 8
    409c:	82 e0       	ldi	r24, 0x02	; 2
	
	SendData (t, _SIZE8); //send throttle
    409e:	79 de       	rcall	.-782    	; 0x3d92 <SendData>
    40a0:	60 e8       	ldi	r22, 0x80	; 128
    40a2:	81 2f       	mov	r24, r17
    40a4:	76 de       	rcall	.-788    	; 0x3d92 <SendData>
	
	SendData (2, _SIZE4); //send static 32
    40a6:	60 e8       	ldi	r22, 0x80	; 128
    40a8:	80 2f       	mov	r24, r16
    40aa:	73 de       	rcall	.-794    	; 0x3d92 <SendData>
    40ac:	58 9a       	sbi	0x0b, 0	; 11
 
	SendData (analogButtons >> 8, _SIZE8); //send buttons
    40ae:	06 c0       	rjmp	.+12     	; 0x40bc <Update+0x2c2>
    40b0:	c0 e0       	ldi	r28, 0x00	; 0
    40b2:	d2 ea       	ldi	r29, 0xA2	; 162
    40b4:	1b cf       	rjmp	.-458    	; 0x3eec <Update+0xf2>
	SendData (analogButtons, _SIZE8); // 
    40b6:	c0 e0       	ldi	r28, 0x00	; 0
    40b8:	d4 ea       	ldi	r29, 0xA4	; 164
    40ba:	18 cf       	rjmp	.-464    	; 0x3eec <Update+0xf2>
    40bc:	df 91       	pop	r29

	_dataOut_port_ |= _dataOut_bit_;//leave up 
    40be:	cf 91       	pop	r28
    40c0:	1f 91       	pop	r17
		//10 bits X
		//10 bits Y
	}*/
	else //could also use bit juggler code....
	{
		if (reportBuffer[HAT] == DPAD_DOWNLEFT )data |= 0x2200;
    40c2:	0f 91       	pop	r16
    40c4:	ff 90       	pop	r15
    40c6:	ef 90       	pop	r14
		if (reportBuffer[HAT] == DPAD_UPLEFT   )data |= 0x2400;
    40c8:	df 90       	pop	r13
    40ca:	08 95       	ret

000040cc <Probe>:
    40cc:	81 e0       	ldi	r24, 0x01	; 1
	SendData (analogButtons >> 8, _SIZE8); //send buttons
	SendData (analogButtons, _SIZE8); // 

	_dataOut_port_ |= _dataOut_bit_;//leave up 
 
}
    40ce:	90 e0       	ldi	r25, 0x00	; 0
    40d0:	90 93 6d 01 	sts	0x016D, r25
    40d4:	80 93 6c 01 	sts	0x016C, r24
    40d8:	80 91 6c 01 	lds	r24, 0x016C
    40dc:	90 91 6d 01 	lds	r25, 0x016D
	/// lead    500 500  clocks...
	// latch ~~~~~~~~~~~____
	// clock ___~~~~____||||
	//idea here is to catch this 500/500 us lead in.
	timer = 1;
	WHILE_PULSE_IS_LO//find transition
    40e0:	88 38       	cpi	r24, 0x88	; 136
    40e2:	20 e9       	ldi	r18, 0x90	; 144
    40e4:	92 07       	cpc	r25, r18
    40e6:	20 f4       	brcc	.+8      	; 0x40f0 <Probe+0x24>
    40e8:	36 99       	sbic	0x06, 6	; 6
    40ea:	07 c0       	rjmp	.+14     	; 0x40fa <Probe+0x2e>
    40ec:	01 96       	adiw	r24, 0x01	; 1
    40ee:	f0 cf       	rjmp	.-32     	; 0x40d0 <Probe+0x4>
    if ( timer == MAX_TIME) return 0;	 
    40f0:	88 38       	cpi	r24, 0x88	; 136
    40f2:	90 49       	sbci	r25, 0x90	; 144
    40f4:	11 f4       	brne	.+4      	; 0x40fa <Probe+0x2e>
    40f6:	80 e0       	ldi	r24, 0x00	; 0
    40f8:	08 95       	ret
    40fa:	87 e9       	ldi	r24, 0x97	; 151
    40fc:	98 e0       	ldi	r25, 0x08	; 8
    40fe:	01 97       	sbiw	r24, 0x01	; 1
    4100:	f1 f7       	brne	.-4      	; 0x40fe <Probe+0x32>
    4102:	00 c0       	rjmp	.+0      	; 0x4104 <Probe+0x38>
    4104:	00 00       	nop
	_delay_us(550);//move out. this should be a low here
	if ( (_clock_pin_ & _clock_bit_) != 0x00) return 0;
    4106:	36 99       	sbic	0x06, 6	; 6
    4108:	f6 cf       	rjmp	.-20     	; 0x40f6 <Probe+0x2a>
 
	timer = 1;//find again
    410a:	81 e0       	ldi	r24, 0x01	; 1
    410c:	90 e0       	ldi	r25, 0x00	; 0
	WHILE_PULSE_IS_LO	
    410e:	90 93 6d 01 	sts	0x016D, r25
    4112:	80 93 6c 01 	sts	0x016C, r24
    4116:	80 91 6c 01 	lds	r24, 0x016C
    411a:	90 91 6d 01 	lds	r25, 0x016D
    411e:	88 38       	cpi	r24, 0x88	; 136
    4120:	20 e9       	ldi	r18, 0x90	; 144
    4122:	92 07       	cpc	r25, r18
    4124:	20 f4       	brcc	.+8      	; 0x412e <Probe+0x62>
    4126:	36 99       	sbic	0x06, 6	; 6
    4128:	05 c0       	rjmp	.+10     	; 0x4134 <Probe+0x68>
    412a:	01 96       	adiw	r24, 0x01	; 1
    412c:	f0 cf       	rjmp	.-32     	; 0x410e <Probe+0x42>
	if ( timer == MAX_TIME) return 0;
    412e:	88 38       	cpi	r24, 0x88	; 136
    4130:	90 49       	sbci	r25, 0x90	; 144
    4132:	09 f3       	breq	.-62     	; 0x40f6 <Probe+0x2a>

	if (_dataIn_pin_ & _dataIn_bit_)
    4134:	49 9b       	sbis	0x09, 1	; 9
    4136:	df cf       	rjmp	.-66     	; 0x40f6 <Probe+0x2a>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4138:	8f ed       	ldi	r24, 0xDF	; 223
    413a:	9e e2       	ldi	r25, 0x2E	; 46
    413c:	01 97       	sbiw	r24, 0x01	; 1
    413e:	f1 f7       	brne	.-4      	; 0x413c <Probe+0x70>
    4140:	00 c0       	rjmp	.+0      	; 0x4142 <Probe+0x76>
    4142:	00 00       	nop
	{	//latch will fall in about 250 us, Could read the latch line if we need to. 
		//jump out. 	
		_delay_ms(3);	
		if ((PIND & 0x80)==0) return 0; //sega should be higher herem, TG16 will be low. 
    4144:	4f 9b       	sbis	0x09, 7	; 9
    4146:	d7 cf       	rjmp	.-82     	; 0x40f6 <Probe+0x2a>
		return THREE_DO; 
    4148:	8b e2       	ldi	r24, 0x2B	; 43
	} else 	return 0;
 
	
 
	
}
    414a:	08 95       	ret

0000414c <tdoGetConsole>:
};

ConsoleFound *tdoGetConsole(void)
{
	return &TDO_Console;
}
    414c:	82 e6       	ldi	r24, 0x62	; 98
    414e:	91 e0       	ldi	r25, 0x01	; 1
    4150:	08 95       	ret

00004152 <DoWork>:

/*********** prototypes *************/
static void Init(void);
static void Update(void);
static unsigned char Probe(void);
static void DoWork(void){};
    4152:	08 95       	ret

00004154 <Init>:
 
static FORCE_NO_PADDLES_SMS;

void Init(void)
{
	mode=NONE;
    4154:	10 92 92 03 	sts	0x0392, r1
    4158:	10 92 91 03 	sts	0x0391, r1
    415c:	08 95       	ret

0000415e <CleanUp>:
}
void CleanUp(void)
{
    415e:	08 95       	ret

00004160 <Probe>:
unsigned char Probe(void)
{
	//using key 15 - note PC6 is held high on atari/7800 (pull up for button).
		 
	//negate promotion using casting
	if ( (unsigned char )(~PINB)  ==  (unsigned char )0x01 )  {mode = ATARI; FORCE_NO_PADDLES_SMS = 1; return STANDARD;}
    4160:	83 b1       	in	r24, 0x03	; 3
    4162:	8e 3f       	cpi	r24, 0xFE	; 254
    4164:	59 f4       	brne	.+22     	; 0x417c <Probe+0x1c>
    4166:	81 e0       	ldi	r24, 0x01	; 1
    4168:	90 e0       	ldi	r25, 0x00	; 0
    416a:	90 93 92 03 	sts	0x0392, r25
    416e:	80 93 91 03 	sts	0x0391, r24
    4172:	90 93 23 03 	sts	0x0323, r25
    4176:	80 93 22 03 	sts	0x0322, r24
    417a:	0f c0       	rjmp	.+30     	; 0x419a <Probe+0x3a>
	if ( (unsigned char )(~PINB)  ==  (unsigned char )0x03 )  {mode = ATARI; FORCE_NO_PADDLES_SMS = 0; return STANDARD;} //tells flashback that paddles are not connected. (this is also sms)
    417c:	83 b1       	in	r24, 0x03	; 3
    417e:	8c 3f       	cpi	r24, 0xFC	; 252
    4180:	59 f4       	brne	.+22     	; 0x4198 <Probe+0x38>
    4182:	81 e0       	ldi	r24, 0x01	; 1
    4184:	90 e0       	ldi	r25, 0x00	; 0
    4186:	90 93 92 03 	sts	0x0392, r25
    418a:	80 93 91 03 	sts	0x0391, r24
    418e:	10 92 23 03 	sts	0x0323, r1
    4192:	10 92 22 03 	sts	0x0322, r1
    4196:	01 c0       	rjmp	.+2      	; 0x419a <Probe+0x3a>
    4198:	08 95       	ret
    419a:	81 e3       	ldi	r24, 0x31	; 49

	//the default mode. Not sure we want this just yet, looping for con is kinda nice.
	//return 1;
} 
    419c:	08 95       	ret

0000419e <Update>:
void Update(void)
{
	//make some storage, so we change all at once. 
	unsigned char BITSB=0x00,BITSC=0x00,BITSD=0x00; //default to in

	con_anagloToDigital();
    419e:	0e 94 4c 09 	call	0x1298	; 0x1298 <con_anagloToDigital>
	
	if 		(reportBuffer[HAT] == DPAD_DOWN)     BITSD |= 0x40; 
    41a2:	80 91 6a 03 	lds	r24, 0x036A
    41a6:	84 30       	cpi	r24, 0x04	; 4
    41a8:	81 f0       	breq	.+32     	; 0x41ca <Update+0x2c>
	else if (reportBuffer[HAT] == DPAD_RIGHT)    BITSD |= 0x10; 
    41aa:	82 30       	cpi	r24, 0x02	; 2
    41ac:	81 f0       	breq	.+32     	; 0x41ce <Update+0x30>
	else if (reportBuffer[HAT] == DPAD_UP)       BITSD |= 0x80; 
    41ae:	88 23       	and	r24, r24
    41b0:	81 f0       	breq	.+32     	; 0x41d2 <Update+0x34>
	else if (reportBuffer[HAT] == DPAD_LEFT)     BITSD |= 0x20;                                 
    41b2:	86 30       	cpi	r24, 0x06	; 6
    41b4:	81 f0       	breq	.+32     	; 0x41d6 <Update+0x38>
    else if (reportBuffer[HAT] == DPAD_UPLEFT   )BITSD |= 0xA0;
    41b6:	87 30       	cpi	r24, 0x07	; 7
    41b8:	81 f0       	breq	.+32     	; 0x41da <Update+0x3c>
	else if (reportBuffer[HAT] == DPAD_DOWNLEFT )BITSD |= 0x60;
    41ba:	85 30       	cpi	r24, 0x05	; 5
    41bc:	81 f0       	breq	.+32     	; 0x41de <Update+0x40>
	else if (reportBuffer[HAT] == DPAD_UPRIGHT  )BITSD |= 0x90;
    41be:	81 30       	cpi	r24, 0x01	; 1
    41c0:	81 f0       	breq	.+32     	; 0x41e2 <Update+0x44>
	else if (reportBuffer[HAT] == DPAD_DOWNRIGHT)BITSD |= 0x50;  
    41c2:	83 30       	cpi	r24, 0x03	; 3
    41c4:	81 f0       	breq	.+32     	; 0x41e6 <Update+0x48>


void Update(void)
{
	//make some storage, so we change all at once. 
	unsigned char BITSB=0x00,BITSC=0x00,BITSD=0x00; //default to in
    41c6:	20 e0       	ldi	r18, 0x00	; 0
    41c8:	0f c0       	rjmp	.+30     	; 0x41e8 <Update+0x4a>

	con_anagloToDigital();
	
	if 		(reportBuffer[HAT] == DPAD_DOWN)     BITSD |= 0x40; 
    41ca:	20 e4       	ldi	r18, 0x40	; 64
    41cc:	0d c0       	rjmp	.+26     	; 0x41e8 <Update+0x4a>
	else if (reportBuffer[HAT] == DPAD_RIGHT)    BITSD |= 0x10; 
    41ce:	20 e1       	ldi	r18, 0x10	; 16
    41d0:	0b c0       	rjmp	.+22     	; 0x41e8 <Update+0x4a>
	else if (reportBuffer[HAT] == DPAD_UP)       BITSD |= 0x80; 
    41d2:	20 e8       	ldi	r18, 0x80	; 128
    41d4:	09 c0       	rjmp	.+18     	; 0x41e8 <Update+0x4a>
	else if (reportBuffer[HAT] == DPAD_LEFT)     BITSD |= 0x20;                                 
    41d6:	20 e2       	ldi	r18, 0x20	; 32
    41d8:	07 c0       	rjmp	.+14     	; 0x41e8 <Update+0x4a>
    else if (reportBuffer[HAT] == DPAD_UPLEFT   )BITSD |= 0xA0;
    41da:	20 ea       	ldi	r18, 0xA0	; 160
    41dc:	05 c0       	rjmp	.+10     	; 0x41e8 <Update+0x4a>
	else if (reportBuffer[HAT] == DPAD_DOWNLEFT )BITSD |= 0x60;
    41de:	20 e6       	ldi	r18, 0x60	; 96
    41e0:	03 c0       	rjmp	.+6      	; 0x41e8 <Update+0x4a>
	else if (reportBuffer[HAT] == DPAD_UPRIGHT  )BITSD |= 0x90;
    41e2:	20 e9       	ldi	r18, 0x90	; 144
    41e4:	01 c0       	rjmp	.+2      	; 0x41e8 <Update+0x4a>
	else if (reportBuffer[HAT] == DPAD_DOWNRIGHT)BITSD |= 0x50;  
    41e6:	20 e5       	ldi	r18, 0x50	; 80
	
	if (reportBuffer[BUTTON_ROW_1] & 0x01)  BITSC |= 0x40; 
    41e8:	40 91 68 03 	lds	r20, 0x0368
    41ec:	64 2f       	mov	r22, r20
    41ee:	61 70       	andi	r22, 0x01	; 1
    41f0:	40 fd       	sbrc	r20, 0
    41f2:	02 c0       	rjmp	.+4      	; 0x41f8 <Update+0x5a>


void Update(void)
{
	//make some storage, so we change all at once. 
	unsigned char BITSB=0x00,BITSC=0x00,BITSD=0x00; //default to in
    41f4:	50 e0       	ldi	r21, 0x00	; 0
    41f6:	01 c0       	rjmp	.+2      	; 0x41fa <Update+0x5c>
    else if (reportBuffer[HAT] == DPAD_UPLEFT   )BITSD |= 0xA0;
	else if (reportBuffer[HAT] == DPAD_DOWNLEFT )BITSD |= 0x60;
	else if (reportBuffer[HAT] == DPAD_UPRIGHT  )BITSD |= 0x90;
	else if (reportBuffer[HAT] == DPAD_DOWNRIGHT)BITSD |= 0x50;  
	
	if (reportBuffer[BUTTON_ROW_1] & 0x01)  BITSC |= 0x40; 
    41f8:	50 e4       	ldi	r21, 0x40	; 64
	

	
	if ( mode == ATARI )  	//for extra buttons (7800), map them so they make sense
    41fa:	80 91 91 03 	lds	r24, 0x0391
    41fe:	90 91 92 03 	lds	r25, 0x0392
    4202:	34 2f       	mov	r19, r20
    4204:	32 70       	andi	r19, 0x02	; 2
    4206:	81 30       	cpi	r24, 0x01	; 1
    4208:	91 05       	cpc	r25, r1
    420a:	71 f4       	brne	.+28     	; 0x4228 <Update+0x8a>
	{
		if (reportBuffer[BUTTON_ROW_1] & 0x01)  BITSD |= 0x01; //7800 pad A stays low  when not pressed
    420c:	61 11       	cpse	r22, r1
    420e:	21 60       	ori	r18, 0x01	; 1
		if (reportBuffer[BUTTON_ROW_1] & 0x02)  BITSD |= 0x02; //7800 pad B stays low  when not pressed
    4210:	31 11       	cpse	r19, r1
    4212:	22 60       	ori	r18, 0x02	; 2

		//flash back special buttons ( I think only 9 + )
		if (reportBuffer[BUTTON_ROW_3] & 0x04)  BITSD |= 0xC0;//up + down - menu
    4214:	30 91 7b 03 	lds	r19, 0x037B
    4218:	32 fd       	sbrc	r19, 2
    421a:	20 6c       	ori	r18, 0xC0	; 192
		if (reportBuffer[BUTTON_ROW_1] & 0x10)  BITSD |= 0x30;//left + right - select  
    421c:	44 fd       	sbrc	r20, 4
    421e:	20 63       	ori	r18, 0x30	; 48
		//if (reportBuffer[BUTTON_ROW_1] & 0x30)BITSD |= 0xB0;//left + right + up - rewind 
		if (reportBuffer[BUTTON_ROW_1] & 0x20)  BITSD |= 0xE0;//left + up + down - start 		
    4220:	45 ff       	sbrs	r20, 5
    4222:	1d c0       	rjmp	.+58     	; 0x425e <Update+0xc0>
    4224:	20 6e       	ori	r18, 0xE0	; 224
    4226:	1b c0       	rjmp	.+54     	; 0x425e <Update+0xc0>
	}
	else														 
	{															  
		if (reportBuffer[BUTTON_ROW_1] & 0x01)  BITSD |= 0x01;  
    4228:	61 11       	cpse	r22, r1
    422a:	21 60       	ori	r18, 0x01	; 1
		if (reportBuffer[BUTTON_ROW_1] & 0x02)  BITSD |= 0x02;  
    422c:	31 11       	cpse	r19, r1
    422e:	22 60       	ori	r18, 0x02	; 2
		if (reportBuffer[BUTTON_ROW_1] & 0x04)  BITSB |= 0x80;  
    4230:	42 fd       	sbrc	r20, 2
    4232:	02 c0       	rjmp	.+4      	; 0x4238 <Update+0x9a>


void Update(void)
{
	//make some storage, so we change all at once. 
	unsigned char BITSB=0x00,BITSC=0x00,BITSD=0x00; //default to in
    4234:	30 e0       	ldi	r19, 0x00	; 0
    4236:	01 c0       	rjmp	.+2      	; 0x423a <Update+0x9c>
	}
	else														 
	{															  
		if (reportBuffer[BUTTON_ROW_1] & 0x01)  BITSD |= 0x01;  
		if (reportBuffer[BUTTON_ROW_1] & 0x02)  BITSD |= 0x02;  
		if (reportBuffer[BUTTON_ROW_1] & 0x04)  BITSB |= 0x80;  
    4238:	30 e8       	ldi	r19, 0x80	; 128
		if (reportBuffer[BUTTON_ROW_1] & 0x08)  BITSB |= 0x40; 
    423a:	43 fd       	sbrc	r20, 3
    423c:	30 64       	ori	r19, 0x40	; 64
		if (reportBuffer[BUTTON_ROW_1] & 0x40)  BITSB |= 0x20;
    423e:	46 fd       	sbrc	r20, 6
    4240:	30 62       	ori	r19, 0x20	; 32
		if (reportBuffer[BUTTON_ROW_1] & 0x80)  BITSB |= 0x10;
    4242:	47 fd       	sbrc	r20, 7
    4244:	30 61       	ori	r19, 0x10	; 16
		if (reportBuffer[BUTTON_ROW_2] & 0x01)  BITSB |= 0x08; 
    4246:	40 91 69 03 	lds	r20, 0x0369
    424a:	40 fd       	sbrc	r20, 0
    424c:	38 60       	ori	r19, 0x08	; 8
		if (reportBuffer[BUTTON_ROW_2] & 0x02)  BITSB |= 0x04; 
    424e:	41 fd       	sbrc	r20, 1
    4250:	34 60       	ori	r19, 0x04	; 4
		if (reportBuffer[BUTTON_ROW_2] & 0x40)  BITSB |= 0x02; 
    4252:	46 fd       	sbrc	r20, 6
    4254:	32 60       	ori	r19, 0x02	; 2
		if (reportBuffer[BUTTON_ROW_2] & 0x80)  BITSB |= 0x01; 	
    4256:	47 ff       	sbrs	r20, 7
    4258:	03 c0       	rjmp	.+6      	; 0x4260 <Update+0xc2>
    425a:	31 60       	ori	r19, 0x01	; 1
    425c:	01 c0       	rjmp	.+2      	; 0x4260 <Update+0xc2>


void Update(void)
{
	//make some storage, so we change all at once. 
	unsigned char BITSB=0x00,BITSC=0x00,BITSD=0x00; //default to in
    425e:	30 e0       	ldi	r19, 0x00	; 0
		if (reportBuffer[BUTTON_ROW_2] & 0x40)  BITSB |= 0x02; 
		if (reportBuffer[BUTTON_ROW_2] & 0x80)  BITSB |= 0x01; 	
	}
	
	//set to existing port and bring defaults high. then set low where needed. Do not rely on consol to pull up.
	unsigned char portd = (PORTD | 0xF3) & ~BITSD;
    4260:	eb b1       	in	r30, 0x0b	; 11
	unsigned char portc = (PORTC | 0x40) & ~BITSC;
    4262:	78 b1       	in	r23, 0x08	; 8
	unsigned char portb = (PORTB | 0xFE) & ~BITSB;
    4264:	65 b1       	in	r22, 0x05	; 5
	
	
	if ( mode == NONE ) 
    4266:	00 97       	sbiw	r24, 0x00	; 0
    4268:	09 f4       	brne	.+2      	; 0x426c <Update+0xce>
    426a:	99 c0       	rjmp	.+306    	; 0x439e <Update+0x200>
		if (reportBuffer[BUTTON_ROW_2] & 0x40)  BITSB |= 0x02; 
		if (reportBuffer[BUTTON_ROW_2] & 0x80)  BITSB |= 0x01; 	
	}
	
	//set to existing port and bring defaults high. then set low where needed. Do not rely on consol to pull up.
	unsigned char portd = (PORTD | 0xF3) & ~BITSD;
    426c:	42 2f       	mov	r20, r18
    426e:	40 95       	com	r20
    4270:	e3 6f       	ori	r30, 0xF3	; 243
    4272:	4e 23       	and	r20, r30
		*/
		return;
	}
	
	//if anythign was seen, bring them low now.
	PORTD = ( mode == ATARI ) ? (portd ^ 0x03):portd; //special 7800 reverse logic. high is active not low.
    4274:	01 97       	sbiw	r24, 0x01	; 1
    4276:	19 f4       	brne	.+6      	; 0x427e <Update+0xe0>
    4278:	83 e0       	ldi	r24, 0x03	; 3
    427a:	84 27       	eor	r24, r20
    427c:	01 c0       	rjmp	.+2      	; 0x4280 <Update+0xe2>
    427e:	84 2f       	mov	r24, r20
    4280:	8b b9       	out	0x0b, r24	; 11
		
	
	if (FORCE_NO_PADDLES_SMS==0) //7800 does not work in this mode
    4282:	80 91 22 03 	lds	r24, 0x0322
    4286:	90 91 23 03 	lds	r25, 0x0323
    428a:	89 2b       	or	r24, r25
    428c:	09 f0       	breq	.+2      	; 0x4290 <Update+0xf2>
    428e:	68 c0       	rjmp	.+208    	; 0x4360 <Update+0x1c2>
	{
		if  ( (reportBuffer[DIAL] > 0) || (reportBuffer[SLIDER] > 0) || ( !Controller.DpadOnly && reportBuffer[BUTTON_ROW_1] & 0xf0))
    4290:	40 91 6f 03 	lds	r20, 0x036F
    4294:	41 11       	cpse	r20, r1
    4296:	0d c0       	rjmp	.+26     	; 0x42b2 <Update+0x114>
    4298:	80 91 70 03 	lds	r24, 0x0370
    429c:	81 11       	cpse	r24, r1
    429e:	09 c0       	rjmp	.+18     	; 0x42b2 <Update+0x114>
    42a0:	80 91 83 03 	lds	r24, 0x0383
    42a4:	81 11       	cpse	r24, r1
    42a6:	57 c0       	rjmp	.+174    	; 0x4356 <Update+0x1b8>
    42a8:	80 91 68 03 	lds	r24, 0x0368
    42ac:	80 7f       	andi	r24, 0xF0	; 240
    42ae:	09 f4       	brne	.+2      	; 0x42b2 <Update+0x114>
    42b0:	52 c0       	rjmp	.+164    	; 0x4356 <Update+0x1b8>
			// almost always in time and 24/7           //
			// we can not do the 24 7 but I think will  //
			// work ok with just one pulse every update.// 
			//////////////////////////////////////////////
			
			DDRD |= 0xF1;//data and pulse
    42b2:	8a b1       	in	r24, 0x0a	; 10
    42b4:	81 6f       	ori	r24, 0xF1	; 241
    42b6:	8a b9       	out	0x0a, r24	; 10
			DDRC |= 0x40;//the buttons
    42b8:	3e 9a       	sbi	0x07, 6	; 7
			
			//forward button
			if (reportBuffer[BUTTON_ROW_1] & 0x01) PORTC &= ~0x40; else PORTC |= 0x40; 
    42ba:	80 91 68 03 	lds	r24, 0x0368
    42be:	80 ff       	sbrs	r24, 0
    42c0:	02 c0       	rjmp	.+4      	; 0x42c6 <Update+0x128>
    42c2:	46 98       	cbi	0x08, 6	; 8
    42c4:	01 c0       	rjmp	.+2      	; 0x42c8 <Update+0x12a>
    42c6:	46 9a       	sbi	0x08, 6	; 8
			
			unsigned char data = 0;
			if  ( reportBuffer[DIAL] > 0) data = reportBuffer[DIAL] ;
    42c8:	41 11       	cpse	r20, r1
    42ca:	26 c0       	rjmp	.+76     	; 0x4318 <Update+0x17a>
			else if  (reportBuffer[SLIDER] > 0)data = reportBuffer[SLIDER] ;
    42cc:	40 91 70 03 	lds	r20, 0x0370
    42d0:	41 11       	cpse	r20, r1
    42d2:	22 c0       	rjmp	.+68     	; 0x4318 <Update+0x17a>
			else if ( !Controller.DpadOnly && reportBuffer[BUTTON_ROW_1] & 0xf0) //any higher button  
    42d4:	80 91 83 03 	lds	r24, 0x0383
    42d8:	81 11       	cpse	r24, r1
    42da:	1e c0       	rjmp	.+60     	; 0x4318 <Update+0x17a>
    42dc:	80 91 68 03 	lds	r24, 0x0368
    42e0:	80 7f       	andi	r24, 0xF0	; 240
    42e2:	d1 f0       	breq	.+52     	; 0x4318 <Update+0x17a>
			{
				if ( abs  (reportBuffer[X_MAIN_STICK]-128)  >= abs  (reportBuffer[X_SECONDARY_STICK]-128)  )  data = reportBuffer[X_MAIN_STICK];
    42e4:	50 91 6b 03 	lds	r21, 0x036B
    42e8:	40 91 6d 03 	lds	r20, 0x036D
    42ec:	25 2f       	mov	r18, r21
    42ee:	30 e0       	ldi	r19, 0x00	; 0
    42f0:	20 58       	subi	r18, 0x80	; 128
    42f2:	31 09       	sbc	r19, r1
    42f4:	37 ff       	sbrs	r19, 7
    42f6:	03 c0       	rjmp	.+6      	; 0x42fe <Update+0x160>
    42f8:	31 95       	neg	r19
    42fa:	21 95       	neg	r18
    42fc:	31 09       	sbc	r19, r1
    42fe:	84 2f       	mov	r24, r20
    4300:	90 e0       	ldi	r25, 0x00	; 0
    4302:	80 58       	subi	r24, 0x80	; 128
    4304:	91 09       	sbc	r25, r1
    4306:	97 ff       	sbrs	r25, 7
    4308:	03 c0       	rjmp	.+6      	; 0x4310 <Update+0x172>
    430a:	91 95       	neg	r25
    430c:	81 95       	neg	r24
    430e:	91 09       	sbc	r25, r1
    4310:	28 17       	cp	r18, r24
    4312:	39 07       	cpc	r19, r25
    4314:	0c f0       	brlt	.+2      	; 0x4318 <Update+0x17a>
    4316:	45 2f       	mov	r20, r21
			}
			//data from dial and X stickl are always 128 and greater
			//using fixed numebrs works...
			
			//data = reportBuffer[DIAL] ;
			unsigned char dataA = __builtin_avr_insert_bits (0x01238888, data, 0);
    4318:	40 fb       	bst	r20, 0
    431a:	87 f9       	bld	r24, 7
    431c:	41 fb       	bst	r20, 1
    431e:	86 f9       	bld	r24, 6
    4320:	42 fb       	bst	r20, 2
    4322:	85 f9       	bld	r24, 5
    4324:	43 fb       	bst	r20, 3
    4326:	84 f9       	bld	r24, 4
			unsigned char dataB = __builtin_avr_insert_bits (0x45678888, data, 0);
    4328:	04 2e       	mov	r0, r20
    432a:	04 fa       	bst	r0, 4
    432c:	47 f9       	bld	r20, 7
    432e:	05 fa       	bst	r0, 5
    4330:	46 f9       	bld	r20, 6
    4332:	06 fa       	bst	r0, 6
    4334:	45 f9       	bld	r20, 5
    4336:	07 fa       	bst	r0, 7
    4338:	44 f9       	bld	r20, 4
			//unsigned char dataB = __builtin_avr_insert_bits (0x32107654, data, 0);
 
			//set for lo bits 1,2,3,4
			PORTD |= 0x01; //first pass
    433a:	58 9a       	sbi	0x0b, 0	; 11
			PORTD = dataA & 0xf0; 
    433c:	80 7f       	andi	r24, 0xF0	; 240
    433e:	8b b9       	out	0x0b, r24	; 11
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4340:	83 ed       	ldi	r24, 0xD3	; 211
    4342:	90 e0       	ldi	r25, 0x00	; 0
    4344:	01 97       	sbiw	r24, 0x01	; 1
    4346:	f1 f7       	brne	.-4      	; 0x4344 <Update+0x1a6>
    4348:	00 c0       	rjmp	.+0      	; 0x434a <Update+0x1ac>
    434a:	00 00       	nop
			_delay_us(53);  
				
				
			PORTD &= ~0x01; //second pass			
    434c:	58 98       	cbi	0x0b, 0	; 11
			//set for hi bits 1,2,3,4
			PORTD = (dataB & 0xf0) | 1;
    434e:	40 7f       	andi	r20, 0xF0	; 240
    4350:	41 60       	ori	r20, 0x01	; 1
    4352:	4b b9       	out	0x0b, r20	; 11
			//_delay_us(69);  //we we are using this timer to go around the horn.
				
	
			return;
    4354:	08 95       	ret
		}

		
		PORTD |= 0x03; 
    4356:	8b b1       	in	r24, 0x0b	; 11
    4358:	83 60       	ori	r24, 0x03	; 3
    435a:	8b b9       	out	0x0b, r24	; 11
	
		///////////////
		//SMS support//
		//button 2 was pressed. This will not mess up atari, it WILL think a paddle is conncted when pressed. 
		if (BITSD & 0x02) PORTD &= ~0x01; 
    435c:	21 fd       	sbrc	r18, 1
    435e:	58 98       	cbi	0x0b, 0	; 11
		if (reportBuffer[BUTTON_ROW_2] & 0x80)  BITSB |= 0x01; 	
	}
	
	//set to existing port and bring defaults high. then set low where needed. Do not rely on consol to pull up.
	unsigned char portd = (PORTD | 0xF3) & ~BITSD;
	unsigned char portc = (PORTC | 0x40) & ~BITSC;
    4360:	85 2f       	mov	r24, r21
    4362:	80 95       	com	r24
    4364:	97 2f       	mov	r25, r23
    4366:	90 64       	ori	r25, 0x40	; 64
    4368:	89 23       	and	r24, r25
		//SMS support//
		//button 2 was pressed. This will not mess up atari, it WILL think a paddle is conncted when pressed. 
		if (BITSD & 0x02) PORTD &= ~0x01; 
	
	}
	PORTC = portc;
    436a:	88 b9       	out	0x08, r24	; 8
	}
	
	//set to existing port and bring defaults high. then set low where needed. Do not rely on consol to pull up.
	unsigned char portd = (PORTD | 0xF3) & ~BITSD;
	unsigned char portc = (PORTC | 0x40) & ~BITSC;
	unsigned char portb = (PORTB | 0xFE) & ~BITSB;
    436c:	83 2f       	mov	r24, r19
    436e:	80 95       	com	r24
    4370:	96 2f       	mov	r25, r22
    4372:	9e 6f       	ori	r25, 0xFE	; 254
    4374:	89 23       	and	r24, r25
		//button 2 was pressed. This will not mess up atari, it WILL think a paddle is conncted when pressed. 
		if (BITSD & 0x02) PORTD &= ~0x01; 
	
	}
	PORTC = portc;
	PORTB = portb;
    4376:	85 b9       	out	0x05, r24	; 5
	
	//Now do the outs. 
	DDRD = ( mode == ATARI ) ? (BITSD | 0x03):BITSD; //special 7800 reverse logic. Needs always out. high or low
    4378:	80 91 91 03 	lds	r24, 0x0391
    437c:	90 91 92 03 	lds	r25, 0x0392
    4380:	01 97       	sbiw	r24, 0x01	; 1
    4382:	09 f4       	brne	.+2      	; 0x4386 <Update+0x1e8>
    4384:	23 60       	ori	r18, 0x03	; 3
    4386:	2a b9       	out	0x0a, r18	; 10
	if (FORCE_NO_PADDLES_SMS==0) DDRD |= 0x03;  //7800 does not work in this mode
    4388:	80 91 22 03 	lds	r24, 0x0322
    438c:	90 91 23 03 	lds	r25, 0x0323
    4390:	89 2b       	or	r24, r25
    4392:	19 f4       	brne	.+6      	; 0x439a <Update+0x1fc>
    4394:	8a b1       	in	r24, 0x0a	; 10
    4396:	83 60       	ori	r24, 0x03	; 3
    4398:	8a b9       	out	0x0a, r24	; 10
	DDRC = BITSC;  
    439a:	57 b9       	out	0x07, r21	; 7
	DDRB = BITSB;
    439c:	34 b9       	out	0x04, r19	; 4
    439e:	08 95       	ret

000043a0 <standardGetConsole>:
};

ConsoleFound *standardGetConsole(void)
{
	return &STANDARD_Console;
}
    43a0:	8e e6       	ldi	r24, 0x6E	; 110
    43a2:	91 e0       	ldi	r25, 0x01	; 1
    43a4:	08 95       	ret

000043a6 <doWork>:
static bool mouse_walls;
/*********** prototypes *************/
static void Init(void); 
static void Update(void);
static unsigned char Probe(void);
static void doWork(void){};
    43a6:	08 95       	ret

000043a8 <CleanUp>:
{
	int in = N-128;//alow signs
    return ((in<0)?(-in):(in));//return 8 bits of the ABS value.
}
 void CleanUp(void)
{
    43a8:	08 95       	ret

000043aa <Init>:
   
}
void Init(void)
{
	mouse_read_mode = NORMAL;
    43aa:	10 92 2a 03 	sts	0x032A, r1
	mouse_walls = false;
    43ae:	10 92 24 03 	sts	0x0324, r1
	DDRC |= _switchX_;
    43b2:	3e 9a       	sbi	0x07, 6	; 7
	_data_portX_ |= _switchX_;
    43b4:	46 9a       	sbi	0x08, 6	; 8
	DDRD 		|= 0xf0;//data pins out, leave switches in.
    43b6:	8a b1       	in	r24, 0x0a	; 10
    43b8:	80 6f       	ori	r24, 0xF0	; 240
    43ba:	8a b9       	out	0x0a, r24	; 10
	_data_port_ |= 0xff; 
    43bc:	8b b1       	in	r24, 0x0b	; 11
    43be:	8f ef       	ldi	r24, 0xFF	; 255
    43c0:	8b b9       	out	0x0b, r24	; 11
	protocol = STANDARD;
    43c2:	10 92 2c 03 	sts	0x032C, r1
	pad = DIGITAL; 
    43c6:	82 e0       	ldi	r24, 0x02	; 2
    43c8:	80 93 2b 03 	sts	0x032B, r24
    43cc:	08 95       	ret

000043ce <SetMegaDriveID>:
void SetPinData( unsigned char data )
{ 
	//all this code does, is sets the state odf the pins on the 4 data wires. 
	unsigned char newValue = 0x00; //all bits low
	newValue |=  ( 0xF0 & (data<<4)); //any pins that need to go high. 
	PORTD = newValue | 0x0f; //leave switch pins high. 
    43ce:	8f ec       	ldi	r24, 0xCF	; 207
    43d0:	8b b9       	out	0x0b, r24	; 11
	unsigned char peripheral_ID_Low  = 0x0F; 

	
	SetPinData (  peripheral_ID_High );

	if (  (_data_pins_ & _switch11_)  != _switch11_ ) return 0;
    43d2:	89 b1       	in	r24, 0x09	; 9
    43d4:	83 70       	andi	r24, 0x03	; 3
    43d6:	83 30       	cpi	r24, 0x03	; 3
    43d8:	11 f5       	brne	.+68     	; 0x441e <SetMegaDriveID+0x50>
    43da:	80 e0       	ldi	r24, 0x00	; 0
    43dc:	90 e0       	ldi	r25, 0x00	; 0
	
	unsigned int timer=0;
	// the saturn should be changeing the swtich modes.  Look fror pattern 10
	//         v
	// ~~~~~~~~~|______|~~~~~~~~~~
	while ( timer < MAX_TIME && (_data_pins_ & _switch11_) != _switch01_) {	timer++;} 
    43de:	29 b1       	in	r18, 0x09	; 9
    43e0:	23 70       	andi	r18, 0x03	; 3
    43e2:	21 30       	cpi	r18, 0x01	; 1
    43e4:	29 f0       	breq	.+10     	; 0x43f0 <SetMegaDriveID+0x22>
    43e6:	01 96       	adiw	r24, 0x01	; 1
    43e8:	81 15       	cp	r24, r1
    43ea:	2a ef       	ldi	r18, 0xFA	; 250
    43ec:	92 07       	cpc	r25, r18
    43ee:	b9 f7       	brne	.-18     	; 0x43de <SetMegaDriveID+0x10>
void SetPinData( unsigned char data )
{ 
	//all this code does, is sets the state odf the pins on the 4 data wires. 
	unsigned char newValue = 0x00; //all bits low
	newValue |=  ( 0xF0 & (data<<4)); //any pins that need to go high. 
	PORTD = newValue | 0x0f; //leave switch pins high. 
    43f0:	2f ef       	ldi	r18, 0xFF	; 255
    43f2:	2b b9       	out	0x0b, r18	; 11
	// the saturn should be changeing the swtich modes.  Look fror pattern 10
	//         v
	// ~~~~~~~~~|______|~~~~~~~~~~
	while ( timer < MAX_TIME && (_data_pins_ & _switch11_) != _switch01_) {	timer++;} 
	SetPinData (  peripheral_ID_Low);		
	if (timer == MAX_TIME) return 0;
    43f4:	81 15       	cp	r24, r1
    43f6:	9a 4f       	sbci	r25, 0xFA	; 250
    43f8:	91 f0       	breq	.+36     	; 0x441e <SetMegaDriveID+0x50>
    43fa:	20 e0       	ldi	r18, 0x00	; 0
    43fc:	30 e0       	ldi	r19, 0x00	; 0
	
	timer=0;//	  v
	// ~~~~~~~~~|______|~~~~~~~~~~
	while ( timer < MAX_TIME && (_data_pins_ & _switch11_) == _switch01_) {	timer++;}
    43fe:	89 b1       	in	r24, 0x09	; 9
    4400:	83 70       	andi	r24, 0x03	; 3
    4402:	81 30       	cpi	r24, 0x01	; 1
    4404:	31 f4       	brne	.+12     	; 0x4412 <SetMegaDriveID+0x44>
    4406:	2f 5f       	subi	r18, 0xFF	; 255
    4408:	3f 4f       	sbci	r19, 0xFF	; 255
    440a:	21 15       	cp	r18, r1
    440c:	8a ef       	ldi	r24, 0xFA	; 250
    440e:	38 07       	cpc	r19, r24
    4410:	b1 f7       	brne	.-20     	; 0x43fe <SetMegaDriveID+0x30>
void SetPinData( unsigned char data )
{ 
	//all this code does, is sets the state odf the pins on the 4 data wires. 
	unsigned char newValue = 0x00; //all bits low
	newValue |=  ( 0xF0 & (data<<4)); //any pins that need to go high. 
	PORTD = newValue | 0x0f; //leave switch pins high. 
    4412:	8f ec       	ldi	r24, 0xCF	; 207
    4414:	8b b9       	out	0x0b, r24	; 11
	
	timer=0;//	  v
	// ~~~~~~~~~|______|~~~~~~~~~~
	while ( timer < MAX_TIME && (_data_pins_ & _switch11_) == _switch01_) {	timer++;}
	SetPinData (  peripheral_ID_High);	//this one shoudl not be needed. 
	if (timer == MAX_TIME) return 0;
    4416:	81 e0       	ldi	r24, 0x01	; 1
    4418:	21 15       	cp	r18, r1
    441a:	3a 4f       	sbci	r19, 0xFA	; 250
    441c:	09 f4       	brne	.+2      	; 0x4420 <SetMegaDriveID+0x52>
    441e:	80 e0       	ldi	r24, 0x00	; 0
			
	return 1; //it replied as it should. 
}
    4420:	08 95       	ret

00004422 <Probe>:
}

unsigned char Probe(void)
{
	//Saturn will do a MD acquisition, then a protcol acquisition. the MD is a simple pulse and the procol chagnes.
	if ( SetMegaDriveID( ) ) //set MD ID
    4422:	d5 df       	rcall	.-86     	; 0x43ce <SetMegaDriveID>
    4424:	88 23       	and	r24, r24
    4426:	59 f0       	breq	.+22     	; 0x443e <Probe+0x1c>
    4428:	8f e3       	ldi	r24, 0x3F	; 63
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    442a:	9c e9       	ldi	r25, 0x9C	; 156
    442c:	01 97       	sbiw	r24, 0x01	; 1
    442e:	f1 f7       	brne	.-4      	; 0x442c <Probe+0xa>
    4430:	00 c0       	rjmp	.+0      	; 0x4432 <Probe+0x10>
    4432:	00 00       	nop
    4434:	cc df       	rcall	.-104    	; 0x43ce <SetMegaDriveID>
	{
		_delay_ms(10);//can take up to 32 ms but oftem 15, so skip a head a bit.
		
		SetMegaDriveID( ); //this will now trigger the talk, so we look for switch 1,0. We only use this for the check
    4436:	89 b1       	in	r24, 0x09	; 9
    4438:	83 70       	andi	r24, 0x03	; 3
		if ( (_data_pins_ & _switch11_) == _switch00_)  return  WII; //saw it swtich this is a saturn.
    443a:	19 f0       	breq	.+6      	; 0x4442 <Probe+0x20>
    443c:	08 95       	ret
    443e:	80 e0       	ldi	r24, 0x00	; 0
    4440:	08 95       	ret
	}	
	else return 0;  
    4442:	89 e1       	ldi	r24, 0x19	; 25
    4444:	08 95       	ret

00004446 <SendByte>:
	if ( SetMegaDriveID( ) ) //set MD ID
	{
		_delay_ms(10);//can take up to 32 ms but oftem 15, so skip a head a bit.
		
		SetMegaDriveID( ); //this will now trigger the talk, so we look for switch 1,0. We only use this for the check
		if ( (_data_pins_ & _switch11_) == _switch00_)  return  WII; //saw it swtich this is a saturn.
    4446:	99 b1       	in	r25, 0x09	; 9
	}	
	else return 0;  
}
    4448:	93 70       	andi	r25, 0x03	; 3
	//3 wire handshake is done as follows.
	// Latch       : ```_________________``` console lowers the latch
	// clock       :``````|__|```|__|``````` console pulse the clock
	// data readty :````````|__|```|__|````` data always folows the clock and the controller controls this after data is set. 
	
	while ( (_data_pins_ & _switch11_) != _switch00_) {}//wait for Switch 00 and another 1
    444a:	e9 f7       	brne	.-6      	; 0x4446 <SendByte>
void SetPinData( unsigned char data )
{ 
	//all this code does, is sets the state odf the pins on the 4 data wires. 
	unsigned char newValue = 0x00; //all bits low
	newValue |=  ( 0xF0 & (data<<4)); //any pins that need to go high. 
	PORTD = newValue | 0x0f; //leave switch pins high. 
    444c:	98 2f       	mov	r25, r24
    444e:	9f 60       	ori	r25, 0x0F	; 15
    4450:	9b b9       	out	0x0b, r25	; 11
	// data readty :````````|__|```|__|````` data always folows the clock and the controller controls this after data is set. 
	
	while ( (_data_pins_ & _switch11_) != _switch00_) {}//wait for Switch 00 and another 1
	//_delay_us(7); 
	SetPinData ( byte >> 4 );//set first nibble 
	_data_portX_ &= ~_switchX_;//this now goes down.
    4452:	46 98       	cbi	0x08, 6	; 8
	while ( (_data_pins_ & _switch11_) != _switch01_) {}//wait for Switch 01 and another 1
    4454:	99 b1       	in	r25, 0x09	; 9
    4456:	93 70       	andi	r25, 0x03	; 3
    4458:	91 30       	cpi	r25, 0x01	; 1
    445a:	e1 f7       	brne	.-8      	; 0x4454 <SendByte+0xe>

void SetPinData( unsigned char data )
{ 
	//all this code does, is sets the state odf the pins on the 4 data wires. 
	unsigned char newValue = 0x00; //all bits low
	newValue |=  ( 0xF0 & (data<<4)); //any pins that need to go high. 
    445c:	20 e1       	ldi	r18, 0x10	; 16
    445e:	82 9f       	mul	r24, r18
    4460:	c0 01       	movw	r24, r0
    4462:	11 24       	eor	r1, r1
	PORTD = newValue | 0x0f; //leave switch pins high. 
    4464:	8f 60       	ori	r24, 0x0F	; 15
    4466:	8b b9       	out	0x0b, r24	; 11
	SetPinData ( byte >> 4 );//set first nibble 
	_data_portX_ &= ~_switchX_;//this now goes down.
	while ( (_data_pins_ & _switch11_) != _switch01_) {}//wait for Switch 01 and another 1
	//_delay_us(7); 
	SetPinData ( byte);//set second nibble 
	_data_portX_ |= _switchX_;//this now goes down.
    4468:	46 9a       	sbi	0x08, 6	; 8
    446a:	08 95       	ret

0000446c <Update>:
	SendByte(1);//0,1 end bit. 
	_delay_us(50); //make sure we are out,.  
} 

void Update(void)
{
    446c:	1f 93       	push	r17
    446e:	cf 93       	push	r28
    4470:	df 93       	push	r29
	unsigned int Data=0xffff;
	if (reportBuffer[HAT] == DPAD_DOWNLEFT )Data &= ~0x60;
    4472:	90 91 6a 03 	lds	r25, 0x036A
    4476:	95 30       	cpi	r25, 0x05	; 5
    4478:	89 f0       	breq	.+34     	; 0x449c <Update+0x30>
	else if (reportBuffer[HAT] == DPAD_UPLEFT   )Data &= ~0x50;
    447a:	97 30       	cpi	r25, 0x07	; 7
    447c:	91 f0       	breq	.+36     	; 0x44a2 <Update+0x36>
	else if (reportBuffer[HAT] == DPAD_UPRIGHT  )Data &= ~0x90;
    447e:	91 30       	cpi	r25, 0x01	; 1
    4480:	99 f0       	breq	.+38     	; 0x44a8 <Update+0x3c>
	else if (reportBuffer[HAT] == DPAD_DOWNRIGHT)Data &= ~0xA0;                                                
    4482:	93 30       	cpi	r25, 0x03	; 3
    4484:	a1 f0       	breq	.+40     	; 0x44ae <Update+0x42>
	else if (reportBuffer[HAT] == DPAD_UP	 ) Data  &= ~0x10;//U
    4486:	99 23       	and	r25, r25
    4488:	a9 f0       	breq	.+42     	; 0x44b4 <Update+0x48>
	else if (reportBuffer[HAT] == DPAD_DOWN	 ) Data  &= ~0x20;//D
    448a:	94 30       	cpi	r25, 0x04	; 4
    448c:	b1 f0       	breq	.+44     	; 0x44ba <Update+0x4e>
	else if (reportBuffer[HAT] == DPAD_LEFT	 ) Data  &= ~0x40;//L
    448e:	96 30       	cpi	r25, 0x06	; 6
    4490:	b9 f0       	breq	.+46     	; 0x44c0 <Update+0x54>
	else if (reportBuffer[HAT] == DPAD_RIGHT ) Data  &= ~0x80;//R
    4492:	92 30       	cpi	r25, 0x02	; 2
    4494:	c1 f0       	breq	.+48     	; 0x44c6 <Update+0x5a>
	_delay_us(50); //make sure we are out,.  
} 

void Update(void)
{
	unsigned int Data=0xffff;
    4496:	cf ef       	ldi	r28, 0xFF	; 255
    4498:	df ef       	ldi	r29, 0xFF	; 255
    449a:	17 c0       	rjmp	.+46     	; 0x44ca <Update+0x5e>
	if (reportBuffer[HAT] == DPAD_DOWNLEFT )Data &= ~0x60;
    449c:	cf e9       	ldi	r28, 0x9F	; 159
    449e:	df ef       	ldi	r29, 0xFF	; 255
    44a0:	14 c0       	rjmp	.+40     	; 0x44ca <Update+0x5e>
	else if (reportBuffer[HAT] == DPAD_UPLEFT   )Data &= ~0x50;
    44a2:	cf ea       	ldi	r28, 0xAF	; 175
    44a4:	df ef       	ldi	r29, 0xFF	; 255
    44a6:	11 c0       	rjmp	.+34     	; 0x44ca <Update+0x5e>
	else if (reportBuffer[HAT] == DPAD_UPRIGHT  )Data &= ~0x90;
    44a8:	cf e6       	ldi	r28, 0x6F	; 111
    44aa:	df ef       	ldi	r29, 0xFF	; 255
    44ac:	0e c0       	rjmp	.+28     	; 0x44ca <Update+0x5e>
	else if (reportBuffer[HAT] == DPAD_DOWNRIGHT)Data &= ~0xA0;                                                
    44ae:	cf e5       	ldi	r28, 0x5F	; 95
    44b0:	df ef       	ldi	r29, 0xFF	; 255
    44b2:	0b c0       	rjmp	.+22     	; 0x44ca <Update+0x5e>
	else if (reportBuffer[HAT] == DPAD_UP	 ) Data  &= ~0x10;//U
    44b4:	cf ee       	ldi	r28, 0xEF	; 239
    44b6:	df ef       	ldi	r29, 0xFF	; 255
    44b8:	08 c0       	rjmp	.+16     	; 0x44ca <Update+0x5e>
	else if (reportBuffer[HAT] == DPAD_DOWN	 ) Data  &= ~0x20;//D
    44ba:	cf ed       	ldi	r28, 0xDF	; 223
    44bc:	df ef       	ldi	r29, 0xFF	; 255
    44be:	05 c0       	rjmp	.+10     	; 0x44ca <Update+0x5e>
	else if (reportBuffer[HAT] == DPAD_LEFT	 ) Data  &= ~0x40;//L
    44c0:	cf eb       	ldi	r28, 0xBF	; 191
    44c2:	df ef       	ldi	r29, 0xFF	; 255
    44c4:	02 c0       	rjmp	.+4      	; 0x44ca <Update+0x5e>
	else if (reportBuffer[HAT] == DPAD_RIGHT ) Data  &= ~0x80;//R
    44c6:	cf e7       	ldi	r28, 0x7F	; 127
    44c8:	df ef       	ldi	r29, 0xFF	; 255
	                                                
	if (reportBuffer[BUTTON_ROW_1] & 0x02) Data  &= ~0x01;//B
    44ca:	80 91 68 03 	lds	r24, 0x0368
    44ce:	38 2f       	mov	r19, r24
    44d0:	32 70       	andi	r19, 0x02	; 2
    44d2:	81 fd       	sbrc	r24, 1
    44d4:	ce 7f       	andi	r28, 0xFE	; 254
	if (reportBuffer[BUTTON_ROW_1] & 0x80) { if (reportBuffer[HAT] == DPAD_UP ) Data &= ~0x8000;/*R*/ else Data  &=   ~0x02;}//C
    44d6:	87 ff       	sbrs	r24, 7
    44d8:	05 c0       	rjmp	.+10     	; 0x44e4 <Update+0x78>
    44da:	91 11       	cpse	r25, r1
    44dc:	02 c0       	rjmp	.+4      	; 0x44e2 <Update+0x76>
    44de:	df 77       	andi	r29, 0x7F	; 127
    44e0:	01 c0       	rjmp	.+2      	; 0x44e4 <Update+0x78>
    44e2:	cd 7f       	andi	r28, 0xFD	; 253
	if (reportBuffer[BUTTON_ROW_1] & 0x01) Data  &= ~0x04;//A
    44e4:	80 fd       	sbrc	r24, 0
    44e6:	cb 7f       	andi	r28, 0xFB	; 251
	if (reportBuffer[BUTTON_ROW_1] & 0x20) Data  &= ~0x08;//S
    44e8:	85 fd       	sbrc	r24, 5
    44ea:	c7 7f       	andi	r28, 0xF7	; 247
                                                                                                  
	if (reportBuffer[BUTTON_ROW_1] & 0x40) { if (reportBuffer[HAT] == DPAD_UP ) Data &=  ~0x800;/*L*/ else Data  &= ~0x1000;}//Z	
    44ec:	58 2f       	mov	r21, r24
    44ee:	50 74       	andi	r21, 0x40	; 64
    44f0:	86 ff       	sbrs	r24, 6
    44f2:	05 c0       	rjmp	.+10     	; 0x44fe <Update+0x92>
    44f4:	91 11       	cpse	r25, r1
    44f6:	02 c0       	rjmp	.+4      	; 0x44fc <Update+0x90>
    44f8:	d7 7f       	andi	r29, 0xF7	; 247
    44fa:	01 c0       	rjmp	.+2      	; 0x44fe <Update+0x92>
    44fc:	df 7e       	andi	r29, 0xEF	; 239
	if (reportBuffer[BUTTON_ROW_1] & 0x08) Data  &= ~0x2000;//Y
    44fe:	83 fd       	sbrc	r24, 3
    4500:	df 7d       	andi	r29, 0xDF	; 223
	if (reportBuffer[BUTTON_ROW_1] & 0x04) Data  &= ~0x4000;//X
    4502:	48 2f       	mov	r20, r24
    4504:	44 70       	andi	r20, 0x04	; 4
    4506:	82 fd       	sbrc	r24, 2
    4508:	df 7b       	andi	r29, 0xBF	; 191
	if (reportBuffer[BUTTON_ROW_2] & 0x02) Data  &= ~0x8000;//R	
    450a:	20 91 69 03 	lds	r18, 0x0369
    450e:	21 fd       	sbrc	r18, 1
    4510:	df 77       	andi	r29, 0x7F	; 127

	if (reportBuffer[BUTTON_ROW_2] & 0x01) Data &= ~0x800;//L
    4512:	20 fd       	sbrc	r18, 0
    4514:	d7 7f       	andi	r29, 0xF7	; 247
	
	if ( mouse_read_mode != STICKMODE ) //if we are in force mode do not check any of this. 
    4516:	20 91 2a 03 	lds	r18, 0x032A
    451a:	21 30       	cpi	r18, 0x01	; 1
    451c:	09 f4       	brne	.+2      	; 0x4520 <Update+0xb4>
    451e:	48 c0       	rjmp	.+144    	; 0x45b0 <Update+0x144>
	{	
		mouse_walls = false;
    4520:	10 92 24 03 	sts	0x0324, r1

		if (Controller.Type ==	69 || //tablet
    4524:	20 91 86 03 	lds	r18, 0x0386
    4528:	25 34       	cpi	r18, 0x45	; 69
    452a:	51 f0       	breq	.+20     	; 0x4540 <Update+0xd4>
    452c:	20 34       	cpi	r18, 0x40	; 64
    452e:	31 f0       	breq	.+12     	; 0x453c <Update+0xd0>
			Controller.Type ==	64 || //Atari TB
    4530:	2a 30       	cpi	r18, 0x0A	; 10
    4532:	79 f4       	brne	.+30     	; 0x4552 <Update+0xe6>
			Controller.Type == 10  ) //any device that use X/Y as mouse go here. (pippin)
		{
 
			//mouse right is ok. There really is no a good center so leave it as the default button.
			if (Controller.Type == 10  && reportBuffer[BUTTON_ROW_1] & 0x40) Data  &= ~0x01;// pippin uses L and R for mouse  L needs to be mapped to B
    4534:	55 23       	and	r21, r21
    4536:	21 f0       	breq	.+8      	; 0x4540 <Update+0xd4>
    4538:	ce 7f       	andi	r28, 0xFE	; 254
    453a:	02 c0       	rjmp	.+4      	; 0x4540 <Update+0xd4>
			if (Controller.Type == 	64  && reportBuffer[BUTTON_ROW_1] & 0x04) Data &= ~0x800;//TB to use reset for L
    453c:	41 11       	cpse	r20, r1
    453e:	d7 7f       	andi	r29, 0xF7	; 247
			mouse_read_mode = NORMAL; 
    4540:	10 92 2a 03 	sts	0x032A, r1
			protocol = MICE; 
    4544:	22 e0       	ldi	r18, 0x02	; 2
    4546:	20 93 2c 03 	sts	0x032C, r18
			pad = MOUSE;	
    454a:	23 e0       	ldi	r18, 0x03	; 3
    454c:	20 93 2b 03 	sts	0x032B, r18
    4550:	1f c0       	rjmp	.+62     	; 0x4590 <Update+0x124>
		}

		else if (reportBuffer[DIAL] && (Controller.Type ==	115  || Controller.Type ==	115 )  ) // PSX_DS(2)
    4552:	40 91 6f 03 	lds	r20, 0x036F
    4556:	44 23       	and	r20, r20
    4558:	81 f0       	breq	.+32     	; 0x457a <Update+0x10e>
    455a:	23 37       	cpi	r18, 0x73	; 115
    455c:	71 f4       	brne	.+28     	; 0x457a <Update+0x10e>
		{
			if (reportBuffer[BUTTON_ROW_1] & 0x02) Data  &= ~0x04;//DJHERO has B not A, just issue both?
    455e:	31 11       	cpse	r19, r1
    4560:	cb 7f       	andi	r28, 0xFB	; 251
			pad = MOUSE;
    4562:	23 e0       	ldi	r18, 0x03	; 3
    4564:	20 93 2b 03 	sts	0x032B, r18
			protocol = MICE; 
    4568:	22 e0       	ldi	r18, 0x02	; 2
    456a:	20 93 2c 03 	sts	0x032C, r18
			mouse_read_mode = DIALMODE; 
    456e:	20 93 2a 03 	sts	0x032A, r18
			mouse_walls = true;
    4572:	21 e0       	ldi	r18, 0x01	; 1
    4574:	20 93 24 03 	sts	0x0324, r18
    4578:	0b c0       	rjmp	.+22     	; 0x4590 <Update+0x124>
			mouse_read_mode = SLIDERMODE; 
			mouse_walls = true;
		}	

		//otherwise go to analog controller
		else if ( (reportBuffer[X_MAIN_STICK] > 200 || reportBuffer[X_MAIN_STICK] < 50)  ) 
    457a:	20 91 6b 03 	lds	r18, 0x036B
    457e:	22 53       	subi	r18, 0x32	; 50
    4580:	27 39       	cpi	r18, 0x97	; 151
    4582:	30 f0       	brcs	.+12     	; 0x4590 <Update+0x124>
		{
			pad = THREED;
    4584:	26 e0       	ldi	r18, 0x06	; 6
    4586:	20 93 2b 03 	sts	0x032B, r18
			protocol = ANALOG; 
    458a:	21 e0       	ldi	r18, 0x01	; 1
    458c:	20 93 2c 03 	sts	0x032C, r18
		}	
 		else mouse_read_mode == NORMAL;// catch if above fail. 
  
		//forces analogs to act as a mouse - one way mode...
		if ( reportBuffer[HAT] == DPAD_DOWN && (reportBuffer[BUTTON_ROW_1] & 0x83) == 0x83)//ABC + down
    4590:	94 30       	cpi	r25, 0x04	; 4
    4592:	71 f4       	brne	.+28     	; 0x45b0 <Update+0x144>
    4594:	83 78       	andi	r24, 0x83	; 131
    4596:	83 38       	cpi	r24, 0x83	; 131
    4598:	59 f4       	brne	.+22     	; 0x45b0 <Update+0x144>
		{
			protocol = MICE; 
    459a:	82 e0       	ldi	r24, 0x02	; 2
    459c:	80 93 2c 03 	sts	0x032C, r24
			pad = MOUSE;	
    45a0:	83 e0       	ldi	r24, 0x03	; 3
    45a2:	80 93 2b 03 	sts	0x032B, r24
			mouse_read_mode = STICKMODE;
    45a6:	81 e0       	ldi	r24, 0x01	; 1
    45a8:	80 93 2a 03 	sts	0x032A, r24
			mouse_walls = true;
    45ac:	80 93 24 03 	sts	0x0324, r24
		}
	}
	
	if ( Controller.DpadOnly == true  ) 
    45b0:	80 91 83 03 	lds	r24, 0x0383
    45b4:	88 23       	and	r24, r24
    45b6:	49 f0       	breq	.+18     	; 0x45ca <Update+0x15e>
	{
		protocol = STANDARD; 
    45b8:	10 92 2c 03 	sts	0x032C, r1
		pad = DIGITAL;		
    45bc:	82 e0       	ldi	r24, 0x02	; 2
    45be:	80 93 2b 03 	sts	0x032B, r24
		mouse_read_mode = NORMAL; 
    45c2:	10 92 2a 03 	sts	0x032A, r1
		mouse_walls = false;
    45c6:	10 92 24 03 	sts	0x0324, r1
void SetPinData( unsigned char data )
{ 
	//all this code does, is sets the state odf the pins on the 4 data wires. 
	unsigned char newValue = 0x00; //all bits low
	newValue |=  ( 0xF0 & (data<<4)); //any pins that need to go high. 
	PORTD = newValue | 0x0f; //leave switch pins high. 
    45ca:	8f e1       	ldi	r24, 0x1F	; 31
    45cc:	8b b9       	out	0x0b, r24	; 11
	//ebd bit							//
	//////////////////////////////////////
	SetPinData ( 1 ); //begine bit. 
	
	//next bit is also a 1, so leave it. 
	while (  (_data_pins_ & _switch11_) != _switch00_) { }//wait for Switch 00
    45ce:	89 b1       	in	r24, 0x09	; 9
    45d0:	83 70       	andi	r24, 0x03	; 3
    45d2:	e9 f7       	brne	.-6      	; 0x45ce <Update+0x162>
		
	SendByte( protocol<<4 | pad);//1,size
    45d4:	10 91 2b 03 	lds	r17, 0x032B
    45d8:	80 91 2c 03 	lds	r24, 0x032C
    45dc:	20 e1       	ldi	r18, 0x10	; 16
    45de:	82 9f       	mul	r24, r18
    45e0:	c0 01       	movw	r24, r0
    45e2:	11 24       	eor	r1, r1
    45e4:	81 2b       	or	r24, r17
    45e6:	2f df       	rcall	.-418    	; 0x4446 <SendByte>
    45e8:	13 30       	cpi	r17, 0x03	; 3

	if (pad == MOUSE)
    45ea:	09 f0       	breq	.+2      	; 0x45ee <Update+0x182>
    45ec:	78 c0       	rjmp	.+240    	; 0x46de <Update+0x272>
    45ee:	c0 95       	com	r28
		signed int temp =0;//hold from -255 to 255
		//---|------|-------|------|----< not used by all games --- x and y take normal tweo's compliment.
		//y over, X over, Y sign, X sign, start, middle, right, left. this maps out to SACB ( and that works)
		
		//note 1: The amount 255 is slow, 5 is fast, and way too fast, 200 was nice. value are inverted I think because of two comp. . Also note that we need to force flip bits here. 
		inData = ~inData;//invert buttons
    45f0:	d0 95       	com	r29
    45f2:	80 91 2a 03 	lds	r24, 0x032A
		
		unsigned char mouseX_now = 0;
		if (mouse_read_mode == DIALMODE)   mouseX_now =  reportBuffer[DIAL]; 
    45f6:	82 30       	cpi	r24, 0x02	; 2
    45f8:	19 f4       	brne	.+6      	; 0x4600 <Update+0x194>
    45fa:	20 91 6f 03 	lds	r18, 0x036F
    45fe:	07 c0       	rjmp	.+14     	; 0x460e <Update+0x1a2>
    4600:	83 30       	cpi	r24, 0x03	; 3
		else if (mouse_read_mode == SLIDERMODE)   mouseX_now =  reportBuffer[SLIDER]; 
    4602:	19 f4       	brne	.+6      	; 0x460a <Update+0x19e>
    4604:	20 91 70 03 	lds	r18, 0x0370
    4608:	02 c0       	rjmp	.+4      	; 0x460e <Update+0x1a2>
    460a:	20 91 6b 03 	lds	r18, 0x036B
		else  mouseX_now = reportBuffer[X_MAIN_STICK];
    460e:	82 2f       	mov	r24, r18
				
		temp = mouseX_now - mouseX_old; 
    4610:	90 e0       	ldi	r25, 0x00	; 0
    4612:	30 91 29 03 	lds	r19, 0x0329
    4616:	83 1b       	sub	r24, r19
    4618:	91 09       	sbc	r25, r1
    461a:	20 93 29 03 	sts	0x0329, r18
		mouseX_old = mouseX_now;//backp stick position up for later
    461e:	97 fd       	sbrc	r25, 7
		if (temp >= 0) inData &= ~0x10; else inData |= 0x10; 
    4620:	02 c0       	rjmp	.+4      	; 0x4626 <Update+0x1ba>
    4622:	cf 7e       	andi	r28, 0xEF	; 239
    4624:	01 c0       	rjmp	.+2      	; 0x4628 <Update+0x1bc>
    4626:	c0 61       	ori	r28, 0x10	; 16
    4628:	30 91 86 03 	lds	r19, 0x0386
		//type 68 is DJ hero, endless, coudl make a bool for this.
		if ( Controller.Type !=	68  && mouse_walls && mouseX_now >= 200)    {temp =  -200; inData &= ~0x10; }// note 1 above
    462c:	40 91 24 03 	lds	r20, 0x0324
    4630:	34 34       	cpi	r19, 0x44	; 68
    4632:	71 f0       	breq	.+28     	; 0x4650 <Update+0x1e4>
    4634:	44 23       	and	r20, r20
    4636:	61 f0       	breq	.+24     	; 0x4650 <Update+0x1e4>
    4638:	28 3c       	cpi	r18, 0xC8	; 200
    463a:	20 f0       	brcs	.+8      	; 0x4644 <Update+0x1d8>
    463c:	cf 7e       	andi	r28, 0xEF	; 239
    463e:	88 e3       	ldi	r24, 0x38	; 56
    4640:	9f ef       	ldi	r25, 0xFF	; 255
    4642:	13 c0       	rjmp	.+38     	; 0x466a <Update+0x1fe>
    4644:	21 34       	cpi	r18, 0x41	; 65
		else if (Controller.Type !=	68  && mouse_walls && mouseX_now < 65) {temp =  200;  inData |= 0x10;}//  note 1 above
    4646:	20 f4       	brcc	.+8      	; 0x4650 <Update+0x1e4>
    4648:	c0 61       	ori	r28, 0x10	; 16
    464a:	88 ec       	ldi	r24, 0xC8	; 200
    464c:	90 e0       	ldi	r25, 0x00	; 0
    464e:	0d c0       	rjmp	.+26     	; 0x466a <Update+0x1fe>
    4650:	9c 01       	movw	r18, r24
		else if (temp > 230 || temp < -230 ) { inData &= ~0x10; if (mouseDir_old & 0x10) inData |= 0x10; temp=mouseSpeedX_old ; }//watch for flip over code ( going past 255 flips to 0)
    4652:	2a 51       	subi	r18, 0x1A	; 26
    4654:	3f 4f       	sbci	r19, 0xFF	; 255
    4656:	2d 3c       	cpi	r18, 0xCD	; 205
    4658:	31 40       	sbci	r19, 0x01	; 1
    465a:	38 f0       	brcs	.+14     	; 0x466a <Update+0x1fe>
    465c:	cf 7e       	andi	r28, 0xEF	; 239
    465e:	80 91 27 03 	lds	r24, 0x0327
    4662:	84 fd       	sbrc	r24, 4
    4664:	c0 61       	ori	r28, 0x10	; 16
    4666:	80 91 26 03 	lds	r24, 0x0326
    466a:	91 e0       	ldi	r25, 0x01	; 1
		reportBuffer[X_MAIN_STICK] = (~temp^0xff)+1;
    466c:	98 0f       	add	r25, r24
    466e:	90 93 6b 03 	sts	0x036B, r25
    4672:	80 93 26 03 	sts	0x0326, r24
		mouseSpeedX_old=temp;
    4676:	20 91 6c 03 	lds	r18, 0x036C
		
		//Y is inverted so the bits are backwards and the inversion is last
		//this one only uses wall mode if we are in stick mode. Dial does not need this and DJ hero should not have it for its y stick.
		unsigned char mouseY_now = reportBuffer[Y_MAIN_STICK];
    467a:	82 2f       	mov	r24, r18
		temp = mouseY_now - mouseY_old;
    467c:	90 e0       	ldi	r25, 0x00	; 0
    467e:	30 91 28 03 	lds	r19, 0x0328
    4682:	83 1b       	sub	r24, r19
    4684:	91 09       	sbc	r25, r1
    4686:	20 93 28 03 	sts	0x0328, r18
		mouseY_old = mouseY_now;//backup stick position up for later
    468a:	18 16       	cp	r1, r24
		//if (temp >= 0) inData |= 0x20; else inData &= ~0x20; 
		if (temp > 0) inData |= 0x20; else inData &= ~ 0x20; 
    468c:	19 06       	cpc	r1, r25
    468e:	14 f4       	brge	.+4      	; 0x4694 <Update+0x228>
    4690:	c0 62       	ori	r28, 0x20	; 32
    4692:	01 c0       	rjmp	.+2      	; 0x4696 <Update+0x22a>
    4694:	cf 7d       	andi	r28, 0xDF	; 223
    4696:	44 23       	and	r20, r20
		
		if (mouse_walls && reportBuffer[Y_MAIN_STICK] >= 200)    {temp =  50; inData |=  0x20;}//  note 1 above
    4698:	61 f0       	breq	.+24     	; 0x46b2 <Update+0x246>
    469a:	28 3c       	cpi	r18, 0xC8	; 200
    469c:	20 f0       	brcs	.+8      	; 0x46a6 <Update+0x23a>
    469e:	c0 62       	ori	r28, 0x20	; 32
    46a0:	82 e3       	ldi	r24, 0x32	; 50
    46a2:	90 e0       	ldi	r25, 0x00	; 0
    46a4:	13 c0       	rjmp	.+38     	; 0x46cc <Update+0x260>
    46a6:	21 34       	cpi	r18, 0x41	; 65
		else if (mouse_walls && reportBuffer[Y_MAIN_STICK] < 65) {temp =  -50;inData &= ~0x20;}//  note 1 above
    46a8:	20 f4       	brcc	.+8      	; 0x46b2 <Update+0x246>
    46aa:	cf 7d       	andi	r28, 0xDF	; 223
    46ac:	8e ec       	ldi	r24, 0xCE	; 206
    46ae:	9f ef       	ldi	r25, 0xFF	; 255
    46b0:	0d c0       	rjmp	.+26     	; 0x46cc <Update+0x260>
    46b2:	9c 01       	movw	r18, r24
		else if (temp > 250 || temp < -250 ) { inData &= ~0x20; if (mouseDir_old & 0x20) inData |= 0x20; temp=mouseSpeedY_old ; } //watch for flip over code ( going past 255 flips to 0)
    46b4:	26 50       	subi	r18, 0x06	; 6
    46b6:	3f 4f       	sbci	r19, 0xFF	; 255
    46b8:	25 3f       	cpi	r18, 0xF5	; 245
    46ba:	31 40       	sbci	r19, 0x01	; 1
    46bc:	38 f0       	brcs	.+14     	; 0x46cc <Update+0x260>
    46be:	cf 7d       	andi	r28, 0xDF	; 223
    46c0:	80 91 27 03 	lds	r24, 0x0327
    46c4:	85 fd       	sbrc	r24, 5
    46c6:	c0 62       	ori	r28, 0x20	; 32
    46c8:	80 91 25 03 	lds	r24, 0x0325
    46cc:	98 2f       	mov	r25, r24
		reportBuffer[Y_MAIN_STICK] = (~temp)+1;	
    46ce:	91 95       	neg	r25
    46d0:	90 93 6c 03 	sts	0x036C, r25
    46d4:	80 93 25 03 	sts	0x0325, r24
		mouseSpeedY_old=temp;
    46d8:	cf 73       	andi	r28, 0x3F	; 63
		 
		inData &= ~0x40; //no use, just report ok. 
		inData &= ~0x80; //no use, just report ok. 
    46da:	c0 93 27 03 	sts	0x0327, r28

		mouseDir_old=inData;
    46de:	8c 2f       	mov	r24, r28
		
		
		
	}
	SendByte(inData);//udlr, abcs 
    46e0:	b2 de       	rcall	.-668    	; 0x4446 <SendByte>
    46e2:	13 30       	cpi	r17, 0x03	; 3
    46e4:	49 f4       	brne	.+18     	; 0x46f8 <Update+0x28c>
	if(pad != MOUSE) SendByte(inData>>8);//xyzr, Lxxx
    46e6:	80 91 6b 03 	lds	r24, 0x036B
	if(pad>2 || pad == MOUSE) SendByte(reportBuffer[X_MAIN_STICK]);
    46ea:	ad de       	rcall	.-678    	; 0x4446 <SendByte>
    46ec:	80 91 6c 03 	lds	r24, 0x036C
    46f0:	aa de       	rcall	.-684    	; 0x4446 <SendByte>
	if(pad>3 || pad == MOUSE) SendByte(reportBuffer[Y_MAIN_STICK]);
    46f2:	15 30       	cpi	r17, 0x05	; 5
    46f4:	30 f4       	brcc	.+12     	; 0x4702 <Update+0x296>
    46f6:	0d c0       	rjmp	.+26     	; 0x4712 <Update+0x2a6>
    46f8:	8d 2f       	mov	r24, r29
	if(pad>4) SendByte(reportBuffer[LEFT_TRIGGER]);
    46fa:	a5 de       	rcall	.-694    	; 0x4446 <SendByte>
    46fc:	13 30       	cpi	r17, 0x03	; 3
    46fe:	48 f0       	brcs	.+18     	; 0x4712 <Update+0x2a6>
		
		
		
	}
	SendByte(inData);//udlr, abcs 
	if(pad != MOUSE) SendByte(inData>>8);//xyzr, Lxxx
    4700:	f2 cf       	rjmp	.-28     	; 0x46e6 <Update+0x27a>
    4702:	80 91 71 03 	lds	r24, 0x0371
	if(pad>2 || pad == MOUSE) SendByte(reportBuffer[X_MAIN_STICK]);
    4706:	9f de       	rcall	.-706    	; 0x4446 <SendByte>
    4708:	15 30       	cpi	r17, 0x05	; 5
    470a:	19 f0       	breq	.+6      	; 0x4712 <Update+0x2a6>
	if(pad>3 || pad == MOUSE) SendByte(reportBuffer[Y_MAIN_STICK]);
	if(pad>4) SendByte(reportBuffer[LEFT_TRIGGER]);
    470c:	80 91 72 03 	lds	r24, 0x0372
    4710:	9a de       	rcall	.-716    	; 0x4446 <SendByte>
    4712:	81 e0       	ldi	r24, 0x01	; 1
	if(pad>5) SendByte(reportBuffer[RIGHT_TRIGGER]);
    4714:	98 de       	rcall	.-720    	; 0x4446 <SendByte>
    4716:	87 ec       	ldi	r24, 0xC7	; 199
    4718:	90 e0       	ldi	r25, 0x00	; 0
    471a:	01 97       	sbiw	r24, 0x01	; 1
    471c:	f1 f7       	brne	.-4      	; 0x471a <Update+0x2ae>
    471e:	00 c0       	rjmp	.+0      	; 0x4720 <Update+0x2b4>
	SendByte(1);//0,1 end bit. 
    4720:	00 00       	nop
    4722:	df 91       	pop	r29
    4724:	cf 91       	pop	r28
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4726:	1f 91       	pop	r17
    4728:	08 95       	ret

0000472a <saturnGetConsole>:
    472a:	88 e7       	ldi	r24, 0x78	; 120
    472c:	91 e0       	ldi	r25, 0x01	; 1
    472e:	08 95       	ret

00004730 <doWork>:
 
/*********** prototypes *************/
static void Init(void);
static void Update(void);
static unsigned char Probe(void);
static void doWork(void){};
    4730:	08 95       	ret

00004732 <Init>:
static void CleanUp(void);
 
void Init(void)
{
	DDRD |= 0xF3;
    4732:	8a b1       	in	r24, 0x0a	; 10
    4734:	83 6f       	ori	r24, 0xF3	; 243
    4736:	8a b9       	out	0x0a, r24	; 10
	_CON_TIMER_EXP_SETUP 
    4738:	88 e0       	ldi	r24, 0x08	; 8
    473a:	80 93 81 00 	sts	0x0081, r24
    473e:	82 e0       	ldi	r24, 0x02	; 2
    4740:	80 93 6f 00 	sts	0x006F, r24
    4744:	e8 e8       	ldi	r30, 0x88	; 136
    4746:	f0 e0       	ldi	r31, 0x00	; 0
    4748:	8f ef       	ldi	r24, 0xFF	; 255
    474a:	91 e0       	ldi	r25, 0x01	; 1
    474c:	91 83       	std	Z+1, r25	; 0x01
    474e:	80 83       	st	Z, r24
	
	//33 TODO why do both of these (here and define). It needs to be here fror some reason?
	OCR1AL=255;
    4750:	8f ef       	ldi	r24, 0xFF	; 255
    4752:	80 83       	st	Z, r24
	OCR1AH=1;
    4754:	81 e0       	ldi	r24, 0x01	; 1
    4756:	80 93 89 00 	sts	0x0089, r24
    475a:	08 95       	ret

0000475c <CleanUp>:
}
   
void CleanUp(void)
{
  _CON_TIMER_EXP_STOP
    475c:	b1 9a       	sbi	0x16, 1	; 22
    475e:	10 92 85 00 	sts	0x0085, r1
    4762:	10 92 84 00 	sts	0x0084, r1
    4766:	10 92 81 00 	sts	0x0081, r1
    476a:	f8 94       	cli
    476c:	08 95       	ret

0000476e <Probe>:
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    476e:	2f ef       	ldi	r18, 0xFF	; 255
    4770:	89 e6       	ldi	r24, 0x69	; 105
    4772:	98 e1       	ldi	r25, 0x18	; 24
    4774:	21 50       	subi	r18, 0x01	; 1
    4776:	80 40       	sbci	r24, 0x00	; 0
    4778:	90 40       	sbci	r25, 0x00	; 0
    477a:	e1 f7       	brne	.-8      	; 0x4774 <Probe+0x6>
    477c:	00 c0       	rjmp	.+0      	; 0x477e <Probe+0x10>
    477e:	00 00       	nop
 // most of the time LATCH0 is low 
 // some games LATCH3 is normaly low
 // and other time none are low. 
 // maybe best to use LATCH1, this one is always going to be low, untill it polls...canuse the same logic but check order differnt. 
	
	if ((PINB & LATCH3 ) != LATCH3) _delay_us(6);
    4780:	1c 99       	sbic	0x03, 4	; 3
    4782:	03 c0       	rjmp	.+6      	; 0x478a <Probe+0x1c>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4784:	20 e2       	ldi	r18, 0x20	; 32
    4786:	2a 95       	dec	r18
    4788:	f1 f7       	brne	.-4      	; 0x4786 <Probe+0x18>
	unsigned int timer=0;
    478a:	80 e0       	ldi	r24, 0x00	; 0
    478c:	90 e0       	ldi	r25, 0x00	; 0
	WHILE_LATCH_IS_HI_3
    478e:	1c 9b       	sbis	0x03, 4	; 3
    4790:	0b c0       	rjmp	.+22     	; 0x47a8 <Probe+0x3a>
    4792:	01 96       	adiw	r24, 0x01	; 1
    4794:	81 15       	cp	r24, r1
    4796:	2a ef       	ldi	r18, 0xFA	; 250
    4798:	92 07       	cpc	r25, r18
    479a:	c9 f7       	brne	.-14     	; 0x478e <Probe+0x20>
    479c:	12 c0       	rjmp	.+36     	; 0x47c2 <Probe+0x54>
	if (timer != MAX_TIME) 
	{
		 WHILE_LATCH_IS_LO_3;//wait for next
    479e:	01 96       	adiw	r24, 0x01	; 1
    47a0:	81 15       	cp	r24, r1
    47a2:	2a ef       	ldi	r18, 0xFA	; 250
    47a4:	92 07       	cpc	r25, r18
    47a6:	69 f0       	breq	.+26     	; 0x47c2 <Probe+0x54>
    47a8:	1c 9b       	sbis	0x03, 4	; 3
    47aa:	f9 cf       	rjmp	.-14     	; 0x479e <Probe+0x30>
		 if ((PINB & LATCH2 ) != LATCH2) //check low. 
    47ac:	1d 99       	sbic	0x03, 5	; 3
    47ae:	08 c0       	rjmp	.+16     	; 0x47c0 <Probe+0x52>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    47b0:	8f e9       	ldi	r24, 0x9F	; 159
    47b2:	9f e0       	ldi	r25, 0x0F	; 15
    47b4:	01 97       	sbiw	r24, 0x01	; 1
    47b6:	f1 f7       	brne	.-4      	; 0x47b4 <Probe+0x46>
    47b8:	00 c0       	rjmp	.+0      	; 0x47ba <Probe+0x4c>
    47ba:	00 00       	nop
		 {
			_delay_ms(1); 
			return JAG;//found the 3rd. Skip last because its not always the same. 
    47bc:	85 e1       	ldi	r24, 0x15	; 21
    47be:	08 95       	ret
    47c0:	08 95       	ret
		 } 
	}
	
} 
    47c2:	08 95       	ret

000047c4 <Update>:
	unsigned char pass0 = 0xFF;
	unsigned char pass1 = 0xFF;
	unsigned char pass2 = 0xFF;
	unsigned char pass3 = 0xFF;
	
	con_anagloToDigital();
    47c4:	0e 94 4c 09 	call	0x1298	; 0x1298 <con_anagloToDigital>
	
	if (reportBuffer[BUTTON_ROW_1] & 0x20)	 pass0 &= ~DATABIT5;//Start
    47c8:	90 91 68 03 	lds	r25, 0x0368
    47cc:	95 fd       	sbrc	r25, 5
    47ce:	02 c0       	rjmp	.+4      	; 0x47d4 <Update+0x10>
  _CON_TIMER_EXP_STOP
}
void Update(void)
{
	
	unsigned char pass0 = 0xFF;
    47d0:	2f ef       	ldi	r18, 0xFF	; 255
    47d2:	01 c0       	rjmp	.+2      	; 0x47d6 <Update+0x12>
	unsigned char pass2 = 0xFF;
	unsigned char pass3 = 0xFF;
	
	con_anagloToDigital();
	
	if (reportBuffer[BUTTON_ROW_1] & 0x20)	 pass0 &= ~DATABIT5;//Start
    47d4:	2d ef       	ldi	r18, 0xFD	; 253
	if (reportBuffer[BUTTON_ROW_1] & 0x80) 	 pass0 &= ~DATABIT0;//A - yes this is C I know, Jag is backwards. 
    47d6:	97 fd       	sbrc	r25, 7
    47d8:	2f 77       	andi	r18, 0x7F	; 127
	if (reportBuffer[HAT] == DPAD_RIGHT)	 pass0 &= ~DATABIT1;//right
    47da:	80 91 6a 03 	lds	r24, 0x036A
    47de:	82 30       	cpi	r24, 0x02	; 2
    47e0:	11 f4       	brne	.+4      	; 0x47e6 <Update+0x22>
    47e2:	2f 7b       	andi	r18, 0xBF	; 191
    47e4:	1b c0       	rjmp	.+54     	; 0x481c <Update+0x58>
	if (reportBuffer[HAT] == DPAD_LEFT)		 pass0 &= ~DATABIT2;//left     	
    47e6:	86 30       	cpi	r24, 0x06	; 6
    47e8:	11 f4       	brne	.+4      	; 0x47ee <Update+0x2a>
    47ea:	2f 7d       	andi	r18, 0xDF	; 223
    47ec:	17 c0       	rjmp	.+46     	; 0x481c <Update+0x58>
	if (reportBuffer[HAT] == DPAD_DOWN)		 pass0 &= ~DATABIT3;//down
    47ee:	84 30       	cpi	r24, 0x04	; 4
    47f0:	11 f4       	brne	.+4      	; 0x47f6 <Update+0x32>
    47f2:	2f 7e       	andi	r18, 0xEF	; 239
    47f4:	13 c0       	rjmp	.+38     	; 0x481c <Update+0x58>
	if (reportBuffer[HAT] == DPAD_UP) 		 pass0 &= ~DATABIT4;//up
    47f6:	81 11       	cpse	r24, r1
    47f8:	02 c0       	rjmp	.+4      	; 0x47fe <Update+0x3a>
    47fa:	2e 7f       	andi	r18, 0xFE	; 254
    47fc:	0f c0       	rjmp	.+30     	; 0x481c <Update+0x58>
    if (reportBuffer[HAT] == DPAD_UPLEFT   ){pass0 &= ~DATABIT4;pass0 &= ~DATABIT2;}
    47fe:	87 30       	cpi	r24, 0x07	; 7
    4800:	11 f4       	brne	.+4      	; 0x4806 <Update+0x42>
    4802:	2e 7d       	andi	r18, 0xDE	; 222
    4804:	0b c0       	rjmp	.+22     	; 0x481c <Update+0x58>
	if (reportBuffer[HAT] == DPAD_DOWNLEFT ){pass0 &= ~DATABIT3;pass0 &= ~DATABIT2;}
    4806:	85 30       	cpi	r24, 0x05	; 5
    4808:	11 f4       	brne	.+4      	; 0x480e <Update+0x4a>
    480a:	2f 7c       	andi	r18, 0xCF	; 207
    480c:	07 c0       	rjmp	.+14     	; 0x481c <Update+0x58>
	if (reportBuffer[HAT] == DPAD_UPRIGHT  ){pass0 &= ~DATABIT4;pass0 &= ~DATABIT1;}
    480e:	81 30       	cpi	r24, 0x01	; 1
    4810:	11 f4       	brne	.+4      	; 0x4816 <Update+0x52>
    4812:	2e 7b       	andi	r18, 0xBE	; 190
    4814:	03 c0       	rjmp	.+6      	; 0x481c <Update+0x58>
	if (reportBuffer[HAT] == DPAD_DOWNRIGHT){pass0 &= ~DATABIT3;pass0 &= ~DATABIT1;}
    4816:	83 30       	cpi	r24, 0x03	; 3
    4818:	09 f4       	brne	.+2      	; 0x481c <Update+0x58>
    481a:	2f 7a       	andi	r18, 0xAF	; 175
	
	if (reportBuffer[BUTTON_ROW_1] & 0x02)	pass1&= ~DATABIT0;//B
    481c:	91 fd       	sbrc	r25, 1
    481e:	02 c0       	rjmp	.+4      	; 0x4824 <Update+0x60>
}
void Update(void)
{
	
	unsigned char pass0 = 0xFF;
	unsigned char pass1 = 0xFF;
    4820:	5f ef       	ldi	r21, 0xFF	; 255
    4822:	01 c0       	rjmp	.+2      	; 0x4826 <Update+0x62>
    if (reportBuffer[HAT] == DPAD_UPLEFT   ){pass0 &= ~DATABIT4;pass0 &= ~DATABIT2;}
	if (reportBuffer[HAT] == DPAD_DOWNLEFT ){pass0 &= ~DATABIT3;pass0 &= ~DATABIT2;}
	if (reportBuffer[HAT] == DPAD_UPRIGHT  ){pass0 &= ~DATABIT4;pass0 &= ~DATABIT1;}
	if (reportBuffer[HAT] == DPAD_DOWNRIGHT){pass0 &= ~DATABIT3;pass0 &= ~DATABIT1;}
	
	if (reportBuffer[BUTTON_ROW_1] & 0x02)	pass1&= ~DATABIT0;//B
    4824:	5f e7       	ldi	r21, 0x7F	; 127
	if (reportBuffer[BUTTON_ROW_2] & 0x01)	pass1&= ~DATABIT1;//1
    4826:	80 91 69 03 	lds	r24, 0x0369
    482a:	80 fd       	sbrc	r24, 0
    482c:	5f 7b       	andi	r21, 0xBF	; 191
	if (reportBuffer[BUTTON_ROW_2] & 0x08)	pass1&= ~DATABIT2;//4
    482e:	83 fd       	sbrc	r24, 3
    4830:	5f 7d       	andi	r21, 0xDF	; 223
	if (reportBuffer[BUTTON_ROW_2] & 0x40)	pass1&= ~DATABIT3;//7
    4832:	86 fd       	sbrc	r24, 6
    4834:	5f 7e       	andi	r21, 0xEF	; 239
	if (reportBuffer[BUTTON_ROW_3] & 0x02)	pass1&= ~DATABIT4;//*
    4836:	60 91 7b 03 	lds	r22, 0x037B
    483a:	61 fd       	sbrc	r22, 1
    483c:	5e 7f       	andi	r21, 0xFE	; 254
	                                              
	if (reportBuffer[BUTTON_ROW_1] & 0x01)	pass2&= ~DATABIT0;//C- yes this is A I know, Jag is backwards. 
    483e:	90 fd       	sbrc	r25, 0
    4840:	02 c0       	rjmp	.+4      	; 0x4846 <Update+0x82>
void Update(void)
{
	
	unsigned char pass0 = 0xFF;
	unsigned char pass1 = 0xFF;
	unsigned char pass2 = 0xFF;
    4842:	4f ef       	ldi	r20, 0xFF	; 255
    4844:	01 c0       	rjmp	.+2      	; 0x4848 <Update+0x84>
	if (reportBuffer[BUTTON_ROW_2] & 0x01)	pass1&= ~DATABIT1;//1
	if (reportBuffer[BUTTON_ROW_2] & 0x08)	pass1&= ~DATABIT2;//4
	if (reportBuffer[BUTTON_ROW_2] & 0x40)	pass1&= ~DATABIT3;//7
	if (reportBuffer[BUTTON_ROW_3] & 0x02)	pass1&= ~DATABIT4;//*
	                                              
	if (reportBuffer[BUTTON_ROW_1] & 0x01)	pass2&= ~DATABIT0;//C- yes this is A I know, Jag is backwards. 
    4846:	4f e7       	ldi	r20, 0x7F	; 127
	if (reportBuffer[BUTTON_ROW_2] & 0x02)	pass2&= ~DATABIT1;//2
    4848:	81 fd       	sbrc	r24, 1
    484a:	4f 7b       	andi	r20, 0xBF	; 191
	if (reportBuffer[BUTTON_ROW_2] & 0x10)	pass2&= ~DATABIT2;//5
    484c:	84 fd       	sbrc	r24, 4
    484e:	4f 7d       	andi	r20, 0xDF	; 223
	if (reportBuffer[BUTTON_ROW_2] & 0x80)	pass2&= ~DATABIT3;//8
    4850:	87 fd       	sbrc	r24, 7
    4852:	4f 7e       	andi	r20, 0xEF	; 239
	if (reportBuffer[BUTTON_ROW_3] & 0x04)	pass2&= ~DATABIT4;//0
    4854:	62 fd       	sbrc	r22, 2
    4856:	4e 7f       	andi	r20, 0xFE	; 254
	                                              
	if (reportBuffer[BUTTON_ROW_1] & 0x10)	pass3 &= ~DATABIT0;//select
    4858:	94 ff       	sbrs	r25, 4
    485a:	02 c0       	rjmp	.+4      	; 0x4860 <Update+0x9c>
    485c:	3f e7       	ldi	r19, 0x7F	; 127
    485e:	01 c0       	rjmp	.+2      	; 0x4862 <Update+0x9e>
{
	
	unsigned char pass0 = 0xFF;
	unsigned char pass1 = 0xFF;
	unsigned char pass2 = 0xFF;
	unsigned char pass3 = 0xFF;
    4860:	3f ef       	ldi	r19, 0xFF	; 255
	if (reportBuffer[BUTTON_ROW_2] & 0x10)	pass2&= ~DATABIT2;//5
	if (reportBuffer[BUTTON_ROW_2] & 0x80)	pass2&= ~DATABIT3;//8
	if (reportBuffer[BUTTON_ROW_3] & 0x04)	pass2&= ~DATABIT4;//0
	                                              
	if (reportBuffer[BUTTON_ROW_1] & 0x10)	pass3 &= ~DATABIT0;//select
	if (reportBuffer[BUTTON_ROW_2] & 0x04)	pass3 &= ~DATABIT1;//3
    4862:	82 fd       	sbrc	r24, 2
    4864:	3f 7b       	andi	r19, 0xBF	; 191
	if (reportBuffer[BUTTON_ROW_2] & 0x20)	pass3 &= ~DATABIT2;//6
    4866:	85 fd       	sbrc	r24, 5
    4868:	3f 7d       	andi	r19, 0xDF	; 223
	if (reportBuffer[BUTTON_ROW_3] & 0x01)	pass3 &= ~DATABIT3;//9
    486a:	60 fd       	sbrc	r22, 0
    486c:	3f 7e       	andi	r19, 0xEF	; 239
	if (reportBuffer[BUTTON_ROW_3] & 0x08)	pass3 &= ~DATABIT4;//#
    486e:	63 fd       	sbrc	r22, 3
    4870:	3e 7f       	andi	r19, 0xFE	; 254
	//------------------------------------------------------------------------------------------------------------//
	// my guess is the held lo line, mean alwyas poll. Tried with isr but it took too long to jump in.			  //
	*///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//find mode
	unsigned char mode = 0; //default
	if      ((PINB & LATCH0 ) != LATCH0) mode = 1;
    4872:	1f 9b       	sbis	0x03, 7	; 3
    4874:	04 c0       	rjmp	.+8      	; 0x487e <Update+0xba>
	else if ((PINB & LATCH3 ) != LATCH3) mode = 2;
    4876:	1c 9b       	sbis	0x03, 4	; 3
    4878:	04 c0       	rjmp	.+8      	; 0x4882 <Update+0xbe>
	// then in some its only pulling low -- LATCH3 lo, LATCH2 lo, LATCH1 lo, LATCH0 lo 							  //
	//------------------------------------------------------------------------------------------------------------//
	// my guess is the held lo line, mean alwyas poll. Tried with isr but it took too long to jump in.			  //
	*///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	//find mode
	unsigned char mode = 0; //default
    487a:	80 e0       	ldi	r24, 0x00	; 0
    487c:	03 c0       	rjmp	.+6      	; 0x4884 <Update+0xc0>
	if      ((PINB & LATCH0 ) != LATCH0) mode = 1;
    487e:	81 e0       	ldi	r24, 0x01	; 1
    4880:	01 c0       	rjmp	.+2      	; 0x4884 <Update+0xc0>
	else if ((PINB & LATCH3 ) != LATCH3) mode = 2;
    4882:	82 e0       	ldi	r24, 0x02	; 2
	
	
_CON_TIMER_EXP_START
    4884:	90 91 81 00 	lds	r25, 0x0081
    4888:	95 60       	ori	r25, 0x05	; 5
    488a:	90 93 81 00 	sts	0x0081, r25
    488e:	78 94       	sei
    4890:	10 92 85 00 	sts	0x0085, r1
    4894:	10 92 84 00 	sts	0x0084, r1
	switch (mode)
    4898:	81 30       	cpi	r24, 0x01	; 1
    489a:	29 f0       	breq	.+10     	; 0x48a6 <Update+0xe2>
    489c:	82 30       	cpi	r24, 0x02	; 2
    489e:	a1 f0       	breq	.+40     	; 0x48c8 <Update+0x104>
    48a0:	80 e0       	ldi	r24, 0x00	; 0
    48a2:	90 e0       	ldi	r25, 0x00	; 0
    48a4:	29 c0       	rjmp	.+82     	; 0x48f8 <Update+0x134>
		case 1: //most games - HB menu
			/////////////////////////////////////////
			// using no wait makes it veyr smooth. //
			// without its is jerky.               //
			/////////////////////////////////////////
			WHILE_LATCH_IS_LO_0_NW//wait for sync in.
    48a6:	1f 9b       	sbis	0x03, 7	; 3
    48a8:	fe cf       	rjmp	.-4      	; 0x48a6 <Update+0xe2>
			
			//check timer exp.
			if ( _CON_TIMER_EXP_FLAG )  break; // > EXP time, so do not report to console.
    48aa:	80 91 42 03 	lds	r24, 0x0342
    48ae:	81 11       	cpse	r24, r1
    48b0:	4f c0       	rjmp	.+158    	; 0x4950 <Update+0x18c>

			PORTD = pass0;//first pass, a, pause, r, l, d, u
    48b2:	2b b9       	out	0x0b, r18	; 11
			WHILE_LATCH_IS_LO_3_NW;  //hold during latch 3
    48b4:	1c 9b       	sbis	0x03, 4	; 3
    48b6:	fe cf       	rjmp	.-4      	; 0x48b4 <Update+0xf0>
	 
			PORTD = pass1;//second pass, na, b, 1, 4, 7, *
    48b8:	5b b9       	out	0x0b, r21	; 11
			WHILE_LATCH_IS_LO_2_NW; //hold during latch 2
    48ba:	1d 9b       	sbis	0x03, 5	; 3
    48bc:	fe cf       	rjmp	.-4      	; 0x48ba <Update+0xf6>
			
			PORTD = pass2;//thrid pass, na, c, 2, 5, 8, 0
    48be:	4b b9       	out	0x0b, r20	; 11
			WHILE_LATCH_IS_LO_1_NW //hold during latch 1
    48c0:	1e 9b       	sbis	0x03, 6	; 3
    48c2:	fe cf       	rjmp	.-4      	; 0x48c0 <Update+0xfc>
			
			PORTD = pass3;//last pass, na, opt, 3, 6, 9, #
    48c4:	3b b9       	out	0x0b, r19	; 11
			//leave for loop return.
		break;
    48c6:	44 c0       	rjmp	.+136    	; 0x4950 <Update+0x18c>

		case 2: //tempest did this one on rotary		
			WHILE_LATCH_IS_LO_3_NW;//sync in
    48c8:	1c 9b       	sbis	0x03, 4	; 3
    48ca:	fe cf       	rjmp	.-4      	; 0x48c8 <Update+0x104>
			
			//check timer exp.
			if ( _CON_TIMER_EXP_FLAG )  break; // > EXP time, so do not report to console.
    48cc:	80 91 42 03 	lds	r24, 0x0342
    48d0:	81 11       	cpse	r24, r1
    48d2:	3e c0       	rjmp	.+124    	; 0x4950 <Update+0x18c>
			
			PORTD = pass1; //second pass, na, b, 1, 4, 7, *
    48d4:	5b b9       	out	0x0b, r21	; 11
			WHILE_LATCH_IS_LO_2_NW; //wait.
    48d6:	1d 9b       	sbis	0x03, 5	; 3
    48d8:	fe cf       	rjmp	.-4      	; 0x48d6 <Update+0x112>
			
			PORTD = pass2;//thrid pass, na, c, 2, 5, 8, 0
    48da:	4b b9       	out	0x0b, r20	; 11
			WHILE_LATCH_IS_LO_1_NW; //wait.
    48dc:	1e 9b       	sbis	0x03, 6	; 3
    48de:	fe cf       	rjmp	.-4      	; 0x48dc <Update+0x118>
			
			PORTD = pass3; //last pass, na, opt, 3, 6, 9, #
    48e0:	3b b9       	out	0x0b, r19	; 11
			WHILE_LATCH_IS_LO_0_NW; //wait.
    48e2:	1f 9b       	sbis	0x03, 7	; 3
    48e4:	fe cf       	rjmp	.-4      	; 0x48e2 <Update+0x11e>
		 
			PORTD = pass0;//first pass, a, pause, r, l, d, u
    48e6:	2b b9       	out	0x0b, r18	; 11
			WHILE_LATCH_IS_LO_3_NW;//wait.
    48e8:	1c 9b       	sbis	0x03, 4	; 3
    48ea:	fe cf       	rjmp	.-4      	; 0x48e8 <Update+0x124>
    48ec:	31 c0       	rjmp	.+98     	; 0x4950 <Update+0x18c>
			/////////////////////////////////////////////////
			// home brue seems to have a more complicated  //
			// poolling but also works with a 4 latch poll //
			/////////////////////////////////////////////////
			
			WHILE_LATCH_IS_HI_3//we need to watch something, 
    48ee:	01 96       	adiw	r24, 0x01	; 1
    48f0:	81 15       	cp	r24, r1
    48f2:	6a ef       	ldi	r22, 0xFA	; 250
    48f4:	96 07       	cpc	r25, r22
    48f6:	b1 f1       	breq	.+108    	; 0x4964 <Update+0x1a0>
    48f8:	1c 99       	sbic	0x03, 4	; 3
    48fa:	f9 cf       	rjmp	.-14     	; 0x48ee <Update+0x12a>
			
			//check timer exp.
			if ( _CON_TIMER_EXP_FLAG )  break; //  > EXP time, so do not report to console.
    48fc:	60 91 42 03 	lds	r22, 0x0342
    4900:	61 11       	cpse	r22, r1
    4902:	26 c0       	rjmp	.+76     	; 0x4950 <Update+0x18c>

			PORTD = pass0; //first pass, a, pause, r, l, d, u
    4904:	2b b9       	out	0x0b, r18	; 11
			WHILE_LATCH_IS_LO_3; 
    4906:	1c 99       	sbic	0x03, 4	; 3
    4908:	06 c0       	rjmp	.+12     	; 0x4916 <Update+0x152>
    490a:	01 96       	adiw	r24, 0x01	; 1
    490c:	81 15       	cp	r24, r1
    490e:	2a ef       	ldi	r18, 0xFA	; 250
    4910:	92 07       	cpc	r25, r18
    4912:	c9 f7       	brne	.-14     	; 0x4906 <Update+0x142>
    4914:	27 c0       	rjmp	.+78     	; 0x4964 <Update+0x1a0>
			
			PORTD = pass1;//second pass, na, b, 1, 4, 7, *
    4916:	5b b9       	out	0x0b, r21	; 11
			WHILE_LATCH_IS_LO_2;
    4918:	1d 99       	sbic	0x03, 5	; 3
    491a:	06 c0       	rjmp	.+12     	; 0x4928 <Update+0x164>
    491c:	01 96       	adiw	r24, 0x01	; 1
    491e:	81 15       	cp	r24, r1
    4920:	6a ef       	ldi	r22, 0xFA	; 250
    4922:	96 07       	cpc	r25, r22
    4924:	c9 f7       	brne	.-14     	; 0x4918 <Update+0x154>
    4926:	1e c0       	rjmp	.+60     	; 0x4964 <Update+0x1a0>
			
			PORTD = pass2;//thrid pass, na, c, 2, 5, 8, 0
    4928:	4b b9       	out	0x0b, r20	; 11
			WHILE_LATCH_IS_LO_1; 
    492a:	1e 99       	sbic	0x03, 6	; 3
    492c:	06 c0       	rjmp	.+12     	; 0x493a <Update+0x176>
    492e:	01 96       	adiw	r24, 0x01	; 1
    4930:	81 15       	cp	r24, r1
    4932:	2a ef       	ldi	r18, 0xFA	; 250
    4934:	92 07       	cpc	r25, r18
    4936:	c9 f7       	brne	.-14     	; 0x492a <Update+0x166>
    4938:	15 c0       	rjmp	.+42     	; 0x4964 <Update+0x1a0>
			
			PORTD = pass3;//last pass, na, opt, 3, 6, 9, #
    493a:	3b b9       	out	0x0b, r19	; 11
			WHILE_LATCH_IS_LO_0;
    493c:	1f 99       	sbic	0x03, 7	; 3
    493e:	06 c0       	rjmp	.+12     	; 0x494c <Update+0x188>
    4940:	01 96       	adiw	r24, 0x01	; 1
    4942:	81 15       	cp	r24, r1
    4944:	6a ef       	ldi	r22, 0xFA	; 250
    4946:	96 07       	cpc	r25, r22
    4948:	c9 f7       	brne	.-14     	; 0x493c <Update+0x178>
    494a:	0c c0       	rjmp	.+24     	; 0x4964 <Update+0x1a0>
			
			//this one does no hold a line low
			PORTD = 0xF3; //leave up so we do not collide with return (first poil)
    494c:	83 ef       	ldi	r24, 0xF3	; 243
    494e:	8b b9       	out	0x0b, r24	; 11
		break;
	}
		
	_CON_TIMER_EXP_STOP  		
    4950:	b1 9a       	sbi	0x16, 1	; 22
    4952:	10 92 85 00 	sts	0x0085, r1
    4956:	10 92 84 00 	sts	0x0084, r1
    495a:	10 92 81 00 	sts	0x0081, r1
    495e:	f8 94       	cli
	_CON_TIMER_EXP_FLAG=false;
    4960:	10 92 42 03 	sts	0x0342, r1
    4964:	08 95       	ret

00004966 <jagGetConsole>:
};

ConsoleFound *jagGetConsole(void)
{
	return &JAG_Console;
}
    4966:	82 e8       	ldi	r24, 0x82	; 130
    4968:	91 e0       	ldi	r25, 0x01	; 1
    496a:	08 95       	ret

0000496c <doWork>:
 
/*********** prototypes *************/
static void Init(void);
static void Update(void);
static unsigned char Probe(void);
static void doWork(void){};
    496c:	08 95       	ret

0000496e <Init>:
static void CleanUp(void);
 
void Init(void)
{
	DDRD |=0x71;//output pins
    496e:	8a b1       	in	r24, 0x0a	; 10
    4970:	81 67       	ori	r24, 0x71	; 113
    4972:	8a b9       	out	0x0a, r24	; 10
    4974:	08 95       	ret

00004976 <CleanUp>:
}   
void CleanUp(void)
{
    4976:	08 95       	ret

00004978 <Probe>:
unsigned  char Probe(void)
{
	//______|~~~~|____ PIN 0X80
	//______|~~|_______PIN 0X0-1
	unsigned int timer;				 
	WHILE_SELECT_IS_LO
    4978:	80 31       	cpi	r24, 0x10	; 16
    497a:	24 ea       	ldi	r18, 0xA4	; 164
    497c:	92 07       	cpc	r25, r18
    497e:	20 f4       	brcc	.+8      	; 0x4988 <Probe+0x10>
    4980:	4f 99       	sbic	0x09, 7	; 9
    4982:	06 c0       	rjmp	.+12     	; 0x4990 <Probe+0x18>
    4984:	01 96       	adiw	r24, 0x01	; 1
    4986:	f8 cf       	rjmp	.-16     	; 0x4978 <Probe>
	if (timer != 42000)
    4988:	80 31       	cpi	r24, 0x10	; 16
    498a:	24 ea       	ldi	r18, 0xA4	; 164
    498c:	92 07       	cpc	r25, r18
    498e:	39 f0       	breq	.+14     	; 0x499e <Probe+0x26>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    4990:	28 e0       	ldi	r18, 0x08	; 8
    4992:	2a 95       	dec	r18
    4994:	f1 f7       	brne	.-4      	; 0x4992 <Probe+0x1a>
	{
		_delay_us(1.5);
		if ( (OE_PIN & OE) == OE && (SELECT_PIN & SELECT )==SELECT ) //both should be high
    4996:	36 9b       	sbis	0x06, 6	; 6
    4998:	02 c0       	rjmp	.+4      	; 0x499e <Probe+0x26>
    499a:	4f 99       	sbic	0x09, 7	; 9
    499c:	05 c0       	rjmp	.+10     	; 0x49a8 <Probe+0x30>
				if (timer == 42000) return 0;
				if ( (OE_PIN & OE ) == 0x00 && (SELECT_PIN & SELECT )==0x00)  return TG16;//it has gone low ans OE is also low its tg16
			}
		}
	}
	return 0;
    499e:	80 e0       	ldi	r24, 0x00	; 0
    49a0:	08 95       	ret
	if (timer != 42000)
	{
		_delay_us(1.5);
		if ( (OE_PIN & OE) == OE && (SELECT_PIN & SELECT )==SELECT ) //both should be high
		{
			WHILE_OE_IS_HI
    49a2:	36 9b       	sbis	0x06, 6	; 6
    49a4:	09 c0       	rjmp	.+18     	; 0x49b8 <Probe+0x40>
    49a6:	01 96       	adiw	r24, 0x01	; 1
    49a8:	80 31       	cpi	r24, 0x10	; 16
    49aa:	24 ea       	ldi	r18, 0xA4	; 164
    49ac:	92 07       	cpc	r25, r18
    49ae:	c8 f3       	brcs	.-14     	; 0x49a2 <Probe+0x2a>
			if (timer == 42000) return 0;
    49b0:	80 31       	cpi	r24, 0x10	; 16
    49b2:	24 ea       	ldi	r18, 0xA4	; 164
    49b4:	92 07       	cpc	r25, r18
    49b6:	99 f3       	breq	.-26     	; 0x499e <Probe+0x26>
			if ( (SELECT_PIN & SELECT )==SELECT ) //make sure its low now and Select is still high.
    49b8:	4f 9b       	sbis	0x09, 7	; 9
    49ba:	f1 cf       	rjmp	.-30     	; 0x499e <Probe+0x26>
    49bc:	03 c0       	rjmp	.+6      	; 0x49c4 <Probe+0x4c>
			{
				WHILE_SELECT_IS_HI
    49be:	4f 9b       	sbis	0x09, 7	; 9
    49c0:	08 c0       	rjmp	.+16     	; 0x49d2 <Probe+0x5a>
    49c2:	01 96       	adiw	r24, 0x01	; 1
    49c4:	80 31       	cpi	r24, 0x10	; 16
    49c6:	24 ea       	ldi	r18, 0xA4	; 164
    49c8:	92 07       	cpc	r25, r18
    49ca:	c8 f3       	brcs	.-14     	; 0x49be <Probe+0x46>
				if (timer == 42000) return 0;
    49cc:	80 31       	cpi	r24, 0x10	; 16
    49ce:	94 4a       	sbci	r25, 0xA4	; 164
    49d0:	31 f3       	breq	.-52     	; 0x499e <Probe+0x26>
				if ( (OE_PIN & OE ) == 0x00 && (SELECT_PIN & SELECT )==0x00)  return TG16;//it has gone low ans OE is also low its tg16
    49d2:	96 b1       	in	r25, 0x06	; 6
    49d4:	89 2f       	mov	r24, r25
    49d6:	80 74       	andi	r24, 0x40	; 64
    49d8:	96 fd       	sbrc	r25, 6
    49da:	e1 cf       	rjmp	.-62     	; 0x499e <Probe+0x26>
    49dc:	4f 9b       	sbis	0x09, 7	; 9
    49de:	87 e2       	ldi	r24, 0x27	; 39
			}
		}
	}
	return 0;
	
}
    49e0:	08 95       	ret

000049e2 <Update>:
void CleanUp(void)
{
   
}
void Update(void)
{
    49e2:	cf 93       	push	r28
    49e4:	df 93       	push	r29
	unsigned char bits1 = 0xff;
	unsigned char bits2 = 0xff;
	unsigned char bits3 = 0xff;
	unsigned char bits4 = 0xff;

	con_anagloToDigital();
    49e6:	0e 94 4c 09 	call	0x1298	; 0x1298 <con_anagloToDigital>
 
	
	if (reportBuffer[BUTTON_ROW_1] & 0x20)	bits2 &= ~0x10;//Start
    49ea:	30 91 68 03 	lds	r19, 0x0368
    49ee:	35 fd       	sbrc	r19, 5
    49f0:	02 c0       	rjmp	.+4      	; 0x49f6 <Update+0x14>
}
void Update(void)
{
	
	unsigned char bits1 = 0xff;
	unsigned char bits2 = 0xff;
    49f2:	9f ef       	ldi	r25, 0xFF	; 255
    49f4:	01 c0       	rjmp	.+2      	; 0x49f8 <Update+0x16>
	unsigned char bits4 = 0xff;

	con_anagloToDigital();
 
	
	if (reportBuffer[BUTTON_ROW_1] & 0x20)	bits2 &= ~0x10;//Start
    49f6:	9f ee       	ldi	r25, 0xEF	; 239
	if (reportBuffer[HAT] == DPAD_RIGHT)	bits1 &= ~0x01;
    49f8:	20 91 6a 03 	lds	r18, 0x036A
    49fc:	22 30       	cpi	r18, 0x02	; 2
    49fe:	09 f4       	brne	.+2      	; 0x4a02 <Update+0x20>
    4a00:	6a c0       	rjmp	.+212    	; 0x4ad6 <Update+0xf4>
	if (reportBuffer[HAT] == DPAD_LEFT)		bits1 &= ~0x10;   	
    4a02:	26 30       	cpi	r18, 0x06	; 6
    4a04:	09 f4       	brne	.+2      	; 0x4a08 <Update+0x26>
    4a06:	69 c0       	rjmp	.+210    	; 0x4ada <Update+0xf8>
	if (reportBuffer[HAT] == DPAD_DOWN)		bits1 &= ~0x40;
    4a08:	24 30       	cpi	r18, 0x04	; 4
    4a0a:	49 f0       	breq	.+18     	; 0x4a1e <Update+0x3c>
	if (reportBuffer[HAT] == DPAD_UP) 		bits1 &= ~0x20;
    4a0c:	22 23       	and	r18, r18
    4a0e:	89 f0       	breq	.+34     	; 0x4a32 <Update+0x50>
	if (reportBuffer[HAT] == DPAD_UPLEFT)	bits1 &= ~0x30;
    4a10:	27 30       	cpi	r18, 0x07	; 7
    4a12:	89 f0       	breq	.+34     	; 0x4a36 <Update+0x54>
   
}
void Update(void)
{
	
	unsigned char bits1 = 0xff;
    4a14:	8f ef       	ldi	r24, 0xFF	; 255
	if (reportBuffer[HAT] == DPAD_RIGHT)	bits1 &= ~0x01;
	if (reportBuffer[HAT] == DPAD_LEFT)		bits1 &= ~0x10;   	
	if (reportBuffer[HAT] == DPAD_DOWN)		bits1 &= ~0x40;
	if (reportBuffer[HAT] == DPAD_UP) 		bits1 &= ~0x20;
	if (reportBuffer[HAT] == DPAD_UPLEFT)	bits1 &= ~0x30;
	if (reportBuffer[HAT] == DPAD_DOWNLEFT)	bits1 &= ~0x50;   	
    4a16:	25 30       	cpi	r18, 0x05	; 5
    4a18:	21 f4       	brne	.+8      	; 0x4a22 <Update+0x40>
    4a1a:	8f ea       	ldi	r24, 0xAF	; 175
    4a1c:	0d c0       	rjmp	.+26     	; 0x4a38 <Update+0x56>
 
	
	if (reportBuffer[BUTTON_ROW_1] & 0x20)	bits2 &= ~0x10;//Start
	if (reportBuffer[HAT] == DPAD_RIGHT)	bits1 &= ~0x01;
	if (reportBuffer[HAT] == DPAD_LEFT)		bits1 &= ~0x10;   	
	if (reportBuffer[HAT] == DPAD_DOWN)		bits1 &= ~0x40;
    4a1e:	8f eb       	ldi	r24, 0xBF	; 191
    4a20:	0b c0       	rjmp	.+22     	; 0x4a38 <Update+0x56>
	if (reportBuffer[HAT] == DPAD_UP) 		bits1 &= ~0x20;
	if (reportBuffer[HAT] == DPAD_UPLEFT)	bits1 &= ~0x30;
	if (reportBuffer[HAT] == DPAD_DOWNLEFT)	bits1 &= ~0x50;   	
	if (reportBuffer[HAT] == DPAD_UPRIGHT)	bits1 &= ~0x21;
    4a22:	21 30       	cpi	r18, 0x01	; 1
    4a24:	11 f4       	brne	.+4      	; 0x4a2a <Update+0x48>
    4a26:	8e ed       	ldi	r24, 0xDE	; 222
    4a28:	07 c0       	rjmp	.+14     	; 0x4a38 <Update+0x56>
	if (reportBuffer[HAT] == DPAD_DOWNRIGHT)bits1 &= ~0x41;
    4a2a:	23 30       	cpi	r18, 0x03	; 3
    4a2c:	29 f4       	brne	.+10     	; 0x4a38 <Update+0x56>
    4a2e:	8e eb       	ldi	r24, 0xBE	; 190
    4a30:	03 c0       	rjmp	.+6      	; 0x4a38 <Update+0x56>
	
	if (reportBuffer[BUTTON_ROW_1] & 0x20)	bits2 &= ~0x10;//Start
	if (reportBuffer[HAT] == DPAD_RIGHT)	bits1 &= ~0x01;
	if (reportBuffer[HAT] == DPAD_LEFT)		bits1 &= ~0x10;   	
	if (reportBuffer[HAT] == DPAD_DOWN)		bits1 &= ~0x40;
	if (reportBuffer[HAT] == DPAD_UP) 		bits1 &= ~0x20;
    4a32:	8f ed       	ldi	r24, 0xDF	; 223
    4a34:	01 c0       	rjmp	.+2      	; 0x4a38 <Update+0x56>
	if (reportBuffer[HAT] == DPAD_UPLEFT)	bits1 &= ~0x30;
    4a36:	8f ec       	ldi	r24, 0xCF	; 207
	if (reportBuffer[HAT] == DPAD_DOWNLEFT)	bits1 &= ~0x50;   	
	if (reportBuffer[HAT] == DPAD_UPRIGHT)	bits1 &= ~0x21;
	if (reportBuffer[HAT] == DPAD_DOWNRIGHT)bits1 &= ~0x41;
	if (reportBuffer[BUTTON_ROW_1] & 0x02)	bits2 &= ~0x20;//1
    4a38:	31 fd       	sbrc	r19, 1
    4a3a:	9f 7d       	andi	r25, 0xDF	; 223
	if (reportBuffer[BUTTON_ROW_1] & 0x01)	bits2 &= ~0x01;//2
    4a3c:	30 fd       	sbrc	r19, 0
    4a3e:	9e 7f       	andi	r25, 0xFE	; 254
	if (reportBuffer[BUTTON_ROW_1] & 0x10)	bits2 &= ~0x40;//select
    4a40:	34 fd       	sbrc	r19, 4
    4a42:	9f 7b       	andi	r25, 0xBF	; 191
		
	//6 button mode.  
	if (reportBuffer[BUTTON_ROW_1] & 0xCC)	
    4a44:	23 2f       	mov	r18, r19
    4a46:	2c 7c       	andi	r18, 0xCC	; 204
    4a48:	69 f0       	breq	.+26     	; 0x4a64 <Update+0x82>
		bits4=bits2;
		bits1 = 0x8e;//hold all 4 directions down
		
		//patch in new buttons. 
		bits2 = 0xff;
		if (reportBuffer[BUTTON_ROW_1] & 0x80) bits2 &= ~0x20;//3
    4a4a:	37 fd       	sbrc	r19, 7
    4a4c:	02 c0       	rjmp	.+4      	; 0x4a52 <Update+0x70>
		bits3=bits1;
		bits4=bits2;
		bits1 = 0x8e;//hold all 4 directions down
		
		//patch in new buttons. 
		bits2 = 0xff;
    4a4e:	2f ef       	ldi	r18, 0xFF	; 255
    4a50:	01 c0       	rjmp	.+2      	; 0x4a54 <Update+0x72>
		if (reportBuffer[BUTTON_ROW_1] & 0x80) bits2 &= ~0x20;//3
    4a52:	2f ed       	ldi	r18, 0xDF	; 223
		if (reportBuffer[BUTTON_ROW_1] & 0x08) bits2 &= ~0x10;//6
    4a54:	33 fd       	sbrc	r19, 3
    4a56:	2f 7e       	andi	r18, 0xEF	; 239
		if (reportBuffer[BUTTON_ROW_1] & 0x04) bits2 &= ~0x40;//5
    4a58:	32 fd       	sbrc	r19, 2
    4a5a:	2f 7b       	andi	r18, 0xBF	; 191
		if (reportBuffer[BUTTON_ROW_1] & 0x40) bits2 &= ~0x01;//4
    4a5c:	36 ff       	sbrs	r19, 6
    4a5e:	07 c0       	rjmp	.+14     	; 0x4a6e <Update+0x8c>
    4a60:	2e 7f       	andi	r18, 0xFE	; 254
    4a62:	05 c0       	rjmp	.+10     	; 0x4a6e <Update+0x8c>
    4a64:	29 2f       	mov	r18, r25
    4a66:	38 2f       	mov	r19, r24
{
	
	unsigned char bits1 = 0xff;
	unsigned char bits2 = 0xff;
	unsigned char bits3 = 0xff;
	unsigned char bits4 = 0xff;
    4a68:	9f ef       	ldi	r25, 0xFF	; 255
void Update(void)
{
	
	unsigned char bits1 = 0xff;
	unsigned char bits2 = 0xff;
	unsigned char bits3 = 0xff;
    4a6a:	8f ef       	ldi	r24, 0xFF	; 255
    4a6c:	05 c0       	rjmp	.+10     	; 0x4a78 <Update+0x96>
	
		//(6)(5)(4)
		//(3)(2)(1)
		bits3=bits1;
		bits4=bits2;
		bits1 = 0x8e;//hold all 4 directions down
    4a6e:	3e e8       	ldi	r19, 0x8E	; 142
    4a70:	03 c0       	rjmp	.+6      	; 0x4a78 <Update+0x96>
	
	//TG is simple, state set hight (UDKR) state reset low(BUTTONS). OE is a prepare data.  
	//6 button will do two polls back to back.
	
	unsigned int timer;
	WHILE_OE_IS_LO//Select rises first so sunc to OE so we can alway catch this regardless of muitaping. 
    4a72:	36 99       	sbic	0x06, 6	; 6
    4a74:	05 c0       	rjmp	.+10     	; 0x4a80 <Update+0x9e>
    4a76:	21 96       	adiw	r28, 0x01	; 1
    4a78:	c0 31       	cpi	r28, 0x10	; 16
    4a7a:	44 ea       	ldi	r20, 0xA4	; 164
    4a7c:	d4 07       	cpc	r29, r20
    4a7e:	c8 f3       	brcs	.-14     	; 0x4a72 <Update+0x90>
	PORTD = bits1;//set pins states for u,d,r,l
    4a80:	3b b9       	out	0x0b, r19	; 11
	WHILE_SELECT_IS_HI
    4a82:	03 c0       	rjmp	.+6      	; 0x4a8a <Update+0xa8>
    4a84:	4f 9b       	sbis	0x09, 7	; 9
    4a86:	05 c0       	rjmp	.+10     	; 0x4a92 <Update+0xb0>
    4a88:	21 96       	adiw	r28, 0x01	; 1
    4a8a:	c0 31       	cpi	r28, 0x10	; 16
    4a8c:	44 ea       	ldi	r20, 0xA4	; 164
    4a8e:	d4 07       	cpc	r29, r20
    4a90:	c8 f3       	brcs	.-14     	; 0x4a84 <Update+0xa2>
	PORTD = bits2;//set pins states for s,s,1,2
    4a92:	2b b9       	out	0x0b, r18	; 11

	//redundant checks.
	if ( bits1 != 0x8e ) 
    4a94:	3e 38       	cpi	r19, 0x8E	; 142
    4a96:	41 f0       	breq	.+16     	; 0x4aa8 <Update+0xc6>
    4a98:	84 ef       	ldi	r24, 0xF4	; 244
    4a9a:	91 e0       	ldi	r25, 0x01	; 1
	{
		timer=0;
		WAIT_OE_READY
    4a9c:	36 99       	sbic	0x06, 6	; 6
    4a9e:	06 c0       	rjmp	.+12     	; 0x4aac <Update+0xca>
    4aa0:	01 97       	sbiw	r24, 0x01	; 1
    4aa2:	00 97       	sbiw	r24, 0x00	; 0
    4aa4:	d9 f7       	brne	.-10     	; 0x4a9c <Update+0xba>
    4aa6:	02 c0       	rjmp	.+4      	; 0x4aac <Update+0xca>
    4aa8:	29 2f       	mov	r18, r25
    4aaa:	38 2f       	mov	r19, r24
    4aac:	80 e0       	ldi	r24, 0x00	; 0
    4aae:	90 e0       	ldi	r25, 0x00	; 0
	//6 button reporting. - 6 button mode does not support redundant checking atm. 
	if ( bits1 == 0x8e )// we need to report for 6 buttons. 
	{
		
		timer=0;
		WAIT_OE_READY
    4ab0:	36 99       	sbic	0x06, 6	; 6
    4ab2:	05 c0       	rjmp	.+10     	; 0x4abe <Update+0xdc>
    4ab4:	01 96       	adiw	r24, 0x01	; 1
    4ab6:	84 3f       	cpi	r24, 0xF4	; 244
    4ab8:	41 e0       	ldi	r20, 0x01	; 1
    4aba:	94 07       	cpc	r25, r20
    4abc:	c9 f7       	brne	.-14     	; 0x4ab0 <Update+0xce>
		if (timer > MAX_TIME2) return;//the console is not asking, give up.
		
		PORTD = bits3;//resend  pins states for u,d,r,l
    4abe:	3b b9       	out	0x0b, r19	; 11
		WHILE_SELECT_IS_HI
    4ac0:	4f 9b       	sbis	0x09, 7	; 9
    4ac2:	05 c0       	rjmp	.+10     	; 0x4ace <Update+0xec>
    4ac4:	01 96       	adiw	r24, 0x01	; 1
    4ac6:	80 31       	cpi	r24, 0x10	; 16
    4ac8:	34 ea       	ldi	r19, 0xA4	; 164
    4aca:	93 07       	cpc	r25, r19
    4acc:	c8 f3       	brcs	.-14     	; 0x4ac0 <Update+0xde>
		PORTD = bits4;//resend  pins states for s,s,1,2
    4ace:	2b b9       	out	0x0b, r18	; 11

	}
	
}
    4ad0:	df 91       	pop	r29
    4ad2:	cf 91       	pop	r28
    4ad4:	08 95       	ret

	con_anagloToDigital();
 
	
	if (reportBuffer[BUTTON_ROW_1] & 0x20)	bits2 &= ~0x10;//Start
	if (reportBuffer[HAT] == DPAD_RIGHT)	bits1 &= ~0x01;
    4ad6:	8e ef       	ldi	r24, 0xFE	; 254
    4ad8:	af cf       	rjmp	.-162    	; 0x4a38 <Update+0x56>
	if (reportBuffer[HAT] == DPAD_LEFT)		bits1 &= ~0x10;   	
    4ada:	8f ee       	ldi	r24, 0xEF	; 239
    4adc:	ad cf       	rjmp	.-166    	; 0x4a38 <Update+0x56>

00004ade <tg16GetConsole>:
};

ConsoleFound *tg16GetConsole(void)
{
	return &TG16_Console;
}
    4ade:	8c e8       	ldi	r24, 0x8C	; 140
    4ae0:	91 e0       	ldi	r25, 0x01	; 1
    4ae2:	08 95       	ret

00004ae4 <DoWork>:

/*********** prototypes *************/
static void Init(void);
static void Update(void);
static unsigned char Probe(void);
static void DoWork(void){};
    4ae4:	08 95       	ret

00004ae6 <Init>:
static void CleanUp(void);
 
void Init(void)
{
	DDRB |= 0xff; //all out. 
    4ae6:	84 b1       	in	r24, 0x04	; 4
    4ae8:	8f ef       	ldi	r24, 0xFF	; 255
    4aea:	84 b9       	out	0x04, r24	; 4
    4aec:	08 95       	ret

00004aee <CleanUp>:
}
void CleanUp(void)
{
    4aee:	08 95       	ret

00004af0 <Probe>:


unsigned char Probe(void)
{
	return INTELI; //use a key detection
} 
    4af0:	8b e1       	ldi	r24, 0x1B	; 27
    4af2:	08 95       	ret

00004af4 <cordicAtan2>:
{
 
}

unsigned char cordicAtan2(int y, int x) 
{
    4af4:	cf 93       	push	r28
    4af6:	e2 eb       	ldi	r30, 0xB2	; 178
    4af8:	f1 e0       	ldi	r31, 0x01	; 1
	
			new = x - (y>>i);
			y = y + (x>>i);
			sumAngle -= AngTable[i];
		}
		x = new;
    4afa:	20 e0       	ldi	r18, 0x00	; 0
    4afc:	30 e0       	ldi	r19, 0x00	; 0

unsigned char cordicAtan2(int y, int x) 
{
	static unsigned char AngTable[] = { 45, 27, 14, 7, 4 };

	unsigned char sumAngle = 0;
    4afe:	c0 e0       	ldi	r28, 0x00	; 0
    4b00:	dc 01       	movw	r26, r24
    4b02:	02 2e       	mov	r0, r18
    4b04:	02 c0       	rjmp	.+4      	; 0x4b0a <cordicAtan2+0x16>
    4b06:	b5 95       	asr	r27
    4b08:	a7 95       	ror	r26
    4b0a:	0a 94       	dec	r0
    4b0c:	e2 f7       	brpl	.-8      	; 0x4b06 <cordicAtan2+0x12>
    4b0e:	ab 01       	movw	r20, r22
    4b10:	02 2e       	mov	r0, r18
    4b12:	02 c0       	rjmp	.+4      	; 0x4b18 <cordicAtan2+0x24>
    4b14:	55 95       	asr	r21
    4b16:	47 95       	ror	r20
    4b18:	0a 94       	dec	r0
    4b1a:	e2 f7       	brpl	.-8      	; 0x4b14 <cordicAtan2+0x20>
	char i;
	int new;
  
	for (i=0; i < 5; i++) 
	{
		if (y > 0) 
    4b1c:	18 16       	cp	r1, r24
    4b1e:	19 06       	cpc	r1, r25
    4b20:	3c f4       	brge	.+14     	; 0x4b30 <cordicAtan2+0x3c>
		{
			new = x + (y>>i);
    4b22:	6a 0f       	add	r22, r26
    4b24:	7b 1f       	adc	r23, r27
			y = y - (x>>i);
    4b26:	84 1b       	sub	r24, r20
    4b28:	95 0b       	sbc	r25, r21
			sumAngle += AngTable[i];
    4b2a:	40 81       	ld	r20, Z
    4b2c:	c4 0f       	add	r28, r20
    4b2e:	06 c0       	rjmp	.+12     	; 0x4b3c <cordicAtan2+0x48>
		}
		else 
		{
	
			new = x - (y>>i);
    4b30:	6a 1b       	sub	r22, r26
    4b32:	7b 0b       	sbc	r23, r27
			y = y + (x>>i);
    4b34:	84 0f       	add	r24, r20
    4b36:	95 1f       	adc	r25, r21
			sumAngle -= AngTable[i];
    4b38:	40 81       	ld	r20, Z
    4b3a:	c4 1b       	sub	r28, r20
    4b3c:	2f 5f       	subi	r18, 0xFF	; 255
    4b3e:	3f 4f       	sbci	r19, 0xFF	; 255
    4b40:	31 96       	adiw	r30, 0x01	; 1

	unsigned char sumAngle = 0;
	char i;
	int new;
  
	for (i=0; i < 5; i++) 
    4b42:	25 30       	cpi	r18, 0x05	; 5
    4b44:	31 05       	cpc	r19, r1
    4b46:	e1 f6       	brne	.-72     	; 0x4b00 <cordicAtan2+0xc>
			sumAngle -= AngTable[i];
		}
		x = new;
	}
	return sumAngle;
}
    4b48:	8c 2f       	mov	r24, r28
    4b4a:	cf 91       	pop	r28
    4b4c:	08 95       	ret

00004b4e <Update>:

void Update(void)
{
    4b4e:	cf 93       	push	r28
    4b50:	df 93       	push	r29
	unsigned char  PINS=0xFF;

	signed char x,y; 
	
	//center for easy math
    x = reportBuffer[X_MAIN_STICK]  - 128;
    4b52:	d0 91 6b 03 	lds	r29, 0x036B
    4b56:	d0 58       	subi	r29, 0x80	; 128
	y = reportBuffer[Y_MAIN_STICK]  - 128;
    4b58:	c0 91 6c 03 	lds	r28, 0x036C
    4b5c:	c0 58       	subi	r28, 0x80	; 128

	//if ( sqrt( y * y + x * x ) > 50)
    if ( abs(x) > range  || abs(y) > range )
    4b5e:	6d 2f       	mov	r22, r29
    4b60:	77 27       	eor	r23, r23
    4b62:	67 fd       	sbrc	r22, 7
    4b64:	70 95       	com	r23
    4b66:	77 ff       	sbrs	r23, 7
    4b68:	03 c0       	rjmp	.+6      	; 0x4b70 <Update+0x22>
    4b6a:	71 95       	neg	r23
    4b6c:	61 95       	neg	r22
    4b6e:	71 09       	sbc	r23, r1
    4b70:	8c 2f       	mov	r24, r28
    4b72:	99 27       	eor	r25, r25
    4b74:	87 fd       	sbrc	r24, 7
    4b76:	90 95       	com	r25
    4b78:	63 33       	cpi	r22, 0x33	; 51
    4b7a:	71 05       	cpc	r23, r1
    4b7c:	64 f4       	brge	.+24     	; 0x4b96 <Update+0x48>
    4b7e:	9c 01       	movw	r18, r24
    4b80:	97 ff       	sbrs	r25, 7
    4b82:	04 c0       	rjmp	.+8      	; 0x4b8c <Update+0x3e>
    4b84:	22 27       	eor	r18, r18
    4b86:	33 27       	eor	r19, r19
    4b88:	28 1b       	sub	r18, r24
    4b8a:	39 0b       	sbc	r19, r25
    4b8c:	23 33       	cpi	r18, 0x33	; 51
    4b8e:	31 05       	cpc	r19, r1
    4b90:	14 f4       	brge	.+4      	; 0x4b96 <Update+0x48>
}

void Update(void)
{
 	//port C (pin 5)  is our comon.
	unsigned char  PINS=0xFF;
    4b92:	8f ef       	ldi	r24, 0xFF	; 255
    4b94:	68 c0       	rjmp	.+208    	; 0x4c66 <Update+0x118>
	//if ( sqrt( y * y + x * x ) > 50)
    if ( abs(x) > range  || abs(y) > range )
	{ 

		signed int  angle=0;
		angle = cordicAtan2( abs(y), abs(x) );
    4b96:	97 ff       	sbrs	r25, 7
    4b98:	03 c0       	rjmp	.+6      	; 0x4ba0 <Update+0x52>
    4b9a:	91 95       	neg	r25
    4b9c:	81 95       	neg	r24
    4b9e:	91 09       	sbc	r25, r1
    4ba0:	a9 df       	rcall	.-174    	; 0x4af4 <cordicAtan2>
    4ba2:	90 e0       	ldi	r25, 0x00	; 0
    4ba4:	d7 fd       	sbrc	r29, 7
			
			
		if ( x >= 0 && y > 0) //buttom right
    4ba6:	1f c0       	rjmp	.+62     	; 0x4be6 <Update+0x98>
    4ba8:	1c 16       	cp	r1, r28
    4baa:	74 f4       	brge	.+28     	; 0x4bc8 <Update+0x7a>
    4bac:	8b 30       	cpi	r24, 0x0B	; 11
		{
				 if ( angle < 11 ) { PINS &= ~PIN03						;}	// right
    4bae:	91 05       	cpc	r25, r1
    4bb0:	0c f4       	brge	.+2      	; 0x4bb4 <Update+0x66>
    4bb2:	44 c0       	rjmp	.+136    	; 0x4c3c <Update+0xee>
    4bb4:	81 32       	cpi	r24, 0x21	; 33
			else if ( angle < 33 ) { PINS &= ~(PIN03 | PIN09)			;}	//
    4bb6:	91 05       	cpc	r25, r1
    4bb8:	dc f1       	brlt	.+118    	; 0x4c30 <Update+0xe2>
    4bba:	88 33       	cpi	r24, 0x38	; 56
			else if ( angle < 56 ) { PINS &= ~(PIN03 | PIN04 | PIN09)   ;} 	// right down
    4bbc:	91 05       	cpc	r25, r1
    4bbe:	d4 f1       	brlt	.+116    	; 0x4c34 <Update+0xe6>
    4bc0:	8e 34       	cpi	r24, 0x4E	; 78
			else if ( angle < 78 ) { PINS &= ~(PIN03 | PIN04)			;} 	//
    4bc2:	91 05       	cpc	r25, r1
    4bc4:	cc f1       	brlt	.+114    	; 0x4c38 <Update+0xea>
    4bc6:	2e c0       	rjmp	.+92     	; 0x4c24 <Update+0xd6>
    4bc8:	cc 23       	and	r28, r28
			else if ( angle < 90 ) { PINS &= ~PIN04						;}	// down
		
		}
		else if ( x >= 0 && y < 0) //top right
    4bca:	19 f3       	breq	.-58     	; 0x4b92 <Update+0x44>
    4bcc:	8b 30       	cpi	r24, 0x0B	; 11
		{
				 if ( angle < 11 ) { PINS &= ~PIN03						;}	// right
    4bce:	91 05       	cpc	r25, r1
    4bd0:	ac f1       	brlt	.+106    	; 0x4c3c <Update+0xee>
    4bd2:	81 32       	cpi	r24, 0x21	; 33
			else if ( angle < 33 ) { PINS &= ~(PIN02 | PIN03 )		    ;}  //
    4bd4:	91 05       	cpc	r25, r1
    4bd6:	a4 f1       	brlt	.+104    	; 0x4c40 <Update+0xf2>
    4bd8:	88 33       	cpi	r24, 0x38	; 56
			else if ( angle < 56 ) { PINS &= ~(PIN02 | PIN03 | PIN09)   ;}	// up right
    4bda:	91 05       	cpc	r25, r1
    4bdc:	9c f1       	brlt	.+102    	; 0x4c44 <Update+0xf6>
    4bde:	8e 34       	cpi	r24, 0x4E	; 78
			else if ( angle < 78 ) { PINS &= ~(PIN02 | PIN09)		    ;}  //
    4be0:	91 05       	cpc	r25, r1
    4be2:	94 f1       	brlt	.+100    	; 0x4c48 <Update+0xfa>
    4be4:	0e c0       	rjmp	.+28     	; 0x4c02 <Update+0xb4>
    4be6:	c7 ff       	sbrs	r28, 7
			else if ( angle < 90 ) { PINS &= ~PIN02						;}	// up
		}
		else if ( x < 0 && y < 0) //top left
    4be8:	11 c0       	rjmp	.+34     	; 0x4c0c <Update+0xbe>
    4bea:	8b 30       	cpi	r24, 0x0B	; 11
		{
			     if ( angle < 11 ) { PINS &= ~PIN01 				 	;}	// left
    4bec:	91 05       	cpc	r25, r1
    4bee:	a4 f1       	brlt	.+104    	; 0x4c58 <Update+0x10a>
    4bf0:	81 32       	cpi	r24, 0x21	; 33
			else if ( angle < 33 ) { PINS &= ~(PIN01 | PIN09) 		 	;}  // 
    4bf2:	91 05       	cpc	r25, r1
    4bf4:	5c f1       	brlt	.+86     	; 0x4c4c <Update+0xfe>
    4bf6:	88 33       	cpi	r24, 0x38	; 56
			else if ( angle < 56 ) { PINS &= ~(PIN01 | PIN02 | PIN09)	;} 	// left up
    4bf8:	91 05       	cpc	r25, r1
    4bfa:	54 f1       	brlt	.+84     	; 0x4c50 <Update+0x102>
    4bfc:	8e 34       	cpi	r24, 0x4E	; 78
			else if ( angle < 78 ) { PINS &= ~(PIN01 | PIN02)		    ;} 	// 
    4bfe:	91 05       	cpc	r25, r1
    4c00:	4c f1       	brlt	.+82     	; 0x4c54 <Update+0x106>
    4c02:	8a 35       	cpi	r24, 0x5A	; 90
			else if ( angle < 90 ) { PINS &= ~PIN02						;}	// up
    4c04:	91 05       	cpc	r25, r1
    4c06:	2c f6       	brge	.-118    	; 0x4b92 <Update+0x44>
    4c08:	8f eb       	ldi	r24, 0xBF	; 191
		{
				 if ( angle < 11 ) { PINS &= ~PIN03						;}	// right
			else if ( angle < 33 ) { PINS &= ~(PIN02 | PIN03 )		    ;}  //
			else if ( angle < 56 ) { PINS &= ~(PIN02 | PIN03 | PIN09)   ;}	// up right
			else if ( angle < 78 ) { PINS &= ~(PIN02 | PIN09)		    ;}  //
			else if ( angle < 90 ) { PINS &= ~PIN02						;}	// up
    4c0a:	2d c0       	rjmp	.+90     	; 0x4c66 <Update+0x118>
    4c0c:	8b 30       	cpi	r24, 0x0B	; 11
			else if ( angle < 78 ) { PINS &= ~(PIN01 | PIN02)		    ;} 	// 
			else if ( angle < 90 ) { PINS &= ~PIN02						;}	// up
		}
		else if ( x < 0 && y >= 0) //buttom left
		{
				 if ( angle < 11) { PINS &= ~PIN01 					 	;}	// left
    4c0e:	91 05       	cpc	r25, r1
    4c10:	1c f1       	brlt	.+70     	; 0x4c58 <Update+0x10a>
    4c12:	81 32       	cpi	r24, 0x21	; 33
			else if ( angle < 33) { PINS &= ~(PIN01 | PIN04)			;}	//
    4c14:	91 05       	cpc	r25, r1
    4c16:	14 f1       	brlt	.+68     	; 0x4c5c <Update+0x10e>
    4c18:	88 33       	cpi	r24, 0x38	; 56
			else if ( angle < 56) { PINS &= ~(PIN01 | PIN04 | PIN09)	;}	// down left
    4c1a:	91 05       	cpc	r25, r1
    4c1c:	0c f1       	brlt	.+66     	; 0x4c60 <Update+0x112>
    4c1e:	8e 34       	cpi	r24, 0x4E	; 78
			else if ( angle < 78) { PINS &= ~(PIN04 | PIN09)			;}	//
    4c20:	91 05       	cpc	r25, r1
    4c22:	04 f1       	brlt	.+64     	; 0x4c64 <Update+0x116>
    4c24:	8a 35       	cpi	r24, 0x5A	; 90
			else if ( angle < 90) { PINS &= ~PIN04						;}	// down
    4c26:	91 05       	cpc	r25, r1
    4c28:	0c f0       	brlt	.+2      	; 0x4c2c <Update+0xde>
    4c2a:	b3 cf       	rjmp	.-154    	; 0x4b92 <Update+0x44>
    4c2c:	8f ee       	ldi	r24, 0xEF	; 239
		{
				 if ( angle < 11 ) { PINS &= ~PIN03						;}	// right
			else if ( angle < 33 ) { PINS &= ~(PIN03 | PIN09)			;}	//
			else if ( angle < 56 ) { PINS &= ~(PIN03 | PIN04 | PIN09)   ;} 	// right down
			else if ( angle < 78 ) { PINS &= ~(PIN03 | PIN04)			;} 	//
			else if ( angle < 90 ) { PINS &= ~PIN04						;}	// down
    4c2e:	1b c0       	rjmp	.+54     	; 0x4c66 <Update+0x118>
    4c30:	8e ed       	ldi	r24, 0xDE	; 222
			
			
		if ( x >= 0 && y > 0) //buttom right
		{
				 if ( angle < 11 ) { PINS &= ~PIN03						;}	// right
			else if ( angle < 33 ) { PINS &= ~(PIN03 | PIN09)			;}	//
    4c32:	19 c0       	rjmp	.+50     	; 0x4c66 <Update+0x118>
    4c34:	8e ec       	ldi	r24, 0xCE	; 206
			else if ( angle < 56 ) { PINS &= ~(PIN03 | PIN04 | PIN09)   ;} 	// right down
    4c36:	17 c0       	rjmp	.+46     	; 0x4c66 <Update+0x118>
    4c38:	8f ec       	ldi	r24, 0xCF	; 207
			else if ( angle < 78 ) { PINS &= ~(PIN03 | PIN04)			;} 	//
    4c3a:	15 c0       	rjmp	.+42     	; 0x4c66 <Update+0x118>
    4c3c:	8f ed       	ldi	r24, 0xDF	; 223
		angle = cordicAtan2( abs(y), abs(x) );
			
			
		if ( x >= 0 && y > 0) //buttom right
		{
				 if ( angle < 11 ) { PINS &= ~PIN03						;}	// right
    4c3e:	13 c0       	rjmp	.+38     	; 0x4c66 <Update+0x118>
    4c40:	8f e9       	ldi	r24, 0x9F	; 159
		
		}
		else if ( x >= 0 && y < 0) //top right
		{
				 if ( angle < 11 ) { PINS &= ~PIN03						;}	// right
			else if ( angle < 33 ) { PINS &= ~(PIN02 | PIN03 )		    ;}  //
    4c42:	11 c0       	rjmp	.+34     	; 0x4c66 <Update+0x118>
    4c44:	8e e9       	ldi	r24, 0x9E	; 158
			else if ( angle < 56 ) { PINS &= ~(PIN02 | PIN03 | PIN09)   ;}	// up right
    4c46:	0f c0       	rjmp	.+30     	; 0x4c66 <Update+0x118>
    4c48:	8e eb       	ldi	r24, 0xBE	; 190
			else if ( angle < 78 ) { PINS &= ~(PIN02 | PIN09)		    ;}  //
    4c4a:	0d c0       	rjmp	.+26     	; 0x4c66 <Update+0x118>
    4c4c:	8e e7       	ldi	r24, 0x7E	; 126
			else if ( angle < 90 ) { PINS &= ~PIN02						;}	// up
		}
		else if ( x < 0 && y < 0) //top left
		{
			     if ( angle < 11 ) { PINS &= ~PIN01 				 	;}	// left
			else if ( angle < 33 ) { PINS &= ~(PIN01 | PIN09) 		 	;}  // 
    4c4e:	0b c0       	rjmp	.+22     	; 0x4c66 <Update+0x118>
    4c50:	8e e3       	ldi	r24, 0x3E	; 62
			else if ( angle < 56 ) { PINS &= ~(PIN01 | PIN02 | PIN09)	;} 	// left up
    4c52:	09 c0       	rjmp	.+18     	; 0x4c66 <Update+0x118>
    4c54:	8f e3       	ldi	r24, 0x3F	; 63
			else if ( angle < 78 ) { PINS &= ~(PIN01 | PIN02)		    ;} 	// 
    4c56:	07 c0       	rjmp	.+14     	; 0x4c66 <Update+0x118>
    4c58:	8f e7       	ldi	r24, 0x7F	; 127
			else if ( angle < 78 ) { PINS &= ~(PIN02 | PIN09)		    ;}  //
			else if ( angle < 90 ) { PINS &= ~PIN02						;}	// up
		}
		else if ( x < 0 && y < 0) //top left
		{
			     if ( angle < 11 ) { PINS &= ~PIN01 				 	;}	// left
    4c5a:	05 c0       	rjmp	.+10     	; 0x4c66 <Update+0x118>
    4c5c:	8f e6       	ldi	r24, 0x6F	; 111
			else if ( angle < 90 ) { PINS &= ~PIN02						;}	// up
		}
		else if ( x < 0 && y >= 0) //buttom left
		{
				 if ( angle < 11) { PINS &= ~PIN01 					 	;}	// left
			else if ( angle < 33) { PINS &= ~(PIN01 | PIN04)			;}	//
    4c5e:	03 c0       	rjmp	.+6      	; 0x4c66 <Update+0x118>
    4c60:	8e e6       	ldi	r24, 0x6E	; 110
			else if ( angle < 56) { PINS &= ~(PIN01 | PIN04 | PIN09)	;}	// down left
    4c62:	01 c0       	rjmp	.+2      	; 0x4c66 <Update+0x118>
    4c64:	8e ee       	ldi	r24, 0xEE	; 238
			else if ( angle < 78) { PINS &= ~(PIN04 | PIN09)			;}	//
    4c66:	90 91 6a 03 	lds	r25, 0x036A
			else if ( angle < 90) { PINS &= ~PIN04						;}	// down
		}
		 
	}
	
	if ( reportBuffer[HAT] != DPAD_REST )//then maybe its a d-pad.
    4c6a:	20 91 68 03 	lds	r18, 0x0368
    4c6e:	9f 3f       	cpi	r25, 0xFF	; 255
    4c70:	01 f1       	breq	.+64     	; 0x4cb2 <Update+0x164>
    4c72:	94 30       	cpi	r25, 0x04	; 4
	{
	
		//d-pad
		if 		(reportBuffer[HAT] == DPAD_DOWN		) PINS &= ~PIN04;
    4c74:	11 f4       	brne	.+4      	; 0x4c7a <Update+0x12c>
    4c76:	8f 7e       	andi	r24, 0xEF	; 239
    4c78:	3c c0       	rjmp	.+120    	; 0x4cf2 <Update+0x1a4>
    4c7a:	92 30       	cpi	r25, 0x02	; 2
		else if (reportBuffer[HAT] == DPAD_RIGHT	) PINS &= ~PIN03;
    4c7c:	11 f4       	brne	.+4      	; 0x4c82 <Update+0x134>
    4c7e:	8f 7d       	andi	r24, 0xDF	; 223
    4c80:	38 c0       	rjmp	.+112    	; 0x4cf2 <Update+0x1a4>
    4c82:	91 11       	cpse	r25, r1
		else if (reportBuffer[HAT] == DPAD_UP		) PINS &= ~PIN02;       
    4c84:	02 c0       	rjmp	.+4      	; 0x4c8a <Update+0x13c>
    4c86:	8f 7b       	andi	r24, 0xBF	; 191
    4c88:	34 c0       	rjmp	.+104    	; 0x4cf2 <Update+0x1a4>
    4c8a:	96 30       	cpi	r25, 0x06	; 6
		else if (reportBuffer[HAT] == DPAD_LEFT		) PINS &= ~PIN01;                            
    4c8c:	11 f4       	brne	.+4      	; 0x4c92 <Update+0x144>
    4c8e:	8f 77       	andi	r24, 0x7F	; 127
    4c90:	30 c0       	rjmp	.+96     	; 0x4cf2 <Update+0x1a4>
    4c92:	97 30       	cpi	r25, 0x07	; 7
		else if (reportBuffer[HAT] == DPAD_UPLEFT   ) PINS &= ~(PIN01 | PIN02 | PIN09);
    4c94:	11 f4       	brne	.+4      	; 0x4c9a <Update+0x14c>
    4c96:	8e 73       	andi	r24, 0x3E	; 62
    4c98:	2c c0       	rjmp	.+88     	; 0x4cf2 <Update+0x1a4>
    4c9a:	95 30       	cpi	r25, 0x05	; 5
		else if (reportBuffer[HAT] == DPAD_DOWNLEFT ) PINS &= ~(PIN01 | PIN04 | PIN09);
    4c9c:	11 f4       	brne	.+4      	; 0x4ca2 <Update+0x154>
    4c9e:	8e 76       	andi	r24, 0x6E	; 110
    4ca0:	28 c0       	rjmp	.+80     	; 0x4cf2 <Update+0x1a4>
    4ca2:	91 30       	cpi	r25, 0x01	; 1
		else if (reportBuffer[HAT] == DPAD_UPRIGHT  ) PINS &= ~(PIN02 | PIN03 | PIN09);
    4ca4:	11 f4       	brne	.+4      	; 0x4caa <Update+0x15c>
    4ca6:	8e 79       	andi	r24, 0x9E	; 158
    4ca8:	24 c0       	rjmp	.+72     	; 0x4cf2 <Update+0x1a4>
    4caa:	93 30       	cpi	r25, 0x03	; 3
		else if (reportBuffer[HAT] == DPAD_DOWNRIGHT) PINS &= ~(PIN03 | PIN04 | PIN09);
    4cac:	11 f5       	brne	.+68     	; 0x4cf2 <Update+0x1a4>
    4cae:	8e 7c       	andi	r24, 0xCE	; 206
    4cb0:	20 c0       	rjmp	.+64     	; 0x4cf2 <Update+0x1a4>
    4cb2:	90 91 69 03 	lds	r25, 0x0369
	}
	else //only key keypad if we didnt pick a dirrection as they both can not be used. 
	{
		//keypad
		if (reportBuffer[BUTTON_ROW_2] & 0x01) PINS &= ~(PIN04 | PIN06 );//1
    4cb6:	90 fd       	sbrc	r25, 0
    4cb8:	87 7e       	andi	r24, 0xE7	; 231
    4cba:	91 fd       	sbrc	r25, 1
		if (reportBuffer[BUTTON_ROW_2] & 0x02) PINS &= ~(PIN04 | PIN07 );//2
    4cbc:	8b 7e       	andi	r24, 0xEB	; 235
    4cbe:	92 fd       	sbrc	r25, 2
		if (reportBuffer[BUTTON_ROW_2] & 0x04) PINS &= ~(PIN04 | PIN08 );//3
    4cc0:	8d 7e       	andi	r24, 0xED	; 237
    4cc2:	93 fd       	sbrc	r25, 3
		if (reportBuffer[BUTTON_ROW_2] & 0x08) PINS &= ~(PIN03 | PIN06 );//4
    4cc4:	87 7d       	andi	r24, 0xD7	; 215
    4cc6:	94 fd       	sbrc	r25, 4
		if (reportBuffer[BUTTON_ROW_2] & 0x10) PINS &= ~(PIN03 | PIN07 );//5
    4cc8:	8b 7d       	andi	r24, 0xDB	; 219
    4cca:	95 fd       	sbrc	r25, 5
		if (reportBuffer[BUTTON_ROW_2] & 0x20) PINS &= ~(PIN03 | PIN08 );//6
    4ccc:	8d 7d       	andi	r24, 0xDD	; 221
    4cce:	96 fd       	sbrc	r25, 6
		if (reportBuffer[BUTTON_ROW_2] & 0x40) PINS &= ~(PIN02 | PIN06 );//7
    4cd0:	87 7b       	andi	r24, 0xB7	; 183
    4cd2:	97 fd       	sbrc	r25, 7
		if (reportBuffer[BUTTON_ROW_2] & 0x80) PINS &= ~(PIN02 | PIN07 );//8
    4cd4:	8b 7b       	andi	r24, 0xBB	; 187
    4cd6:	90 91 7b 03 	lds	r25, 0x037B
		if (reportBuffer[BUTTON_ROW_3] & 0x01) PINS &= ~(PIN02 | PIN08 );//9
    4cda:	90 fd       	sbrc	r25, 0
    4cdc:	8d 7b       	andi	r24, 0xBD	; 189
    4cde:	91 fd       	sbrc	r25, 1
		if (reportBuffer[BUTTON_ROW_3] & 0x02 || reportBuffer[BUTTON_ROW_1] & 0x10) PINS &= ~(PIN01 | PIN06 );//clean
    4ce0:	01 c0       	rjmp	.+2      	; 0x4ce4 <Update+0x196>
    4ce2:	24 fd       	sbrc	r18, 4
    4ce4:	87 77       	andi	r24, 0x77	; 119
    4ce6:	92 fd       	sbrc	r25, 2
		if (reportBuffer[BUTTON_ROW_3] & 0x04) PINS &= ~(PIN01 | PIN07 );//0
    4ce8:	8b 77       	andi	r24, 0x7B	; 123
    4cea:	93 fd       	sbrc	r25, 3
		if (reportBuffer[BUTTON_ROW_3] & 0x08 || reportBuffer[BUTTON_ROW_1] & 0x20) PINS &= ~(PIN01 | PIN08 );//enter
    4cec:	01 c0       	rjmp	.+2      	; 0x4cf0 <Update+0x1a2>
    4cee:	25 fd       	sbrc	r18, 5
    4cf0:	8d 77       	andi	r24, 0x7D	; 125
    4cf2:	20 fd       	sbrc	r18, 0
	 }
	//buttons
	if (reportBuffer[BUTTON_ROW_1] & 0x01) PINS &= ~(PIN07 | PIN08);//b1 (diamond style B)
    4cf4:	89 7f       	andi	r24, 0xF9	; 249
    4cf6:	21 fd       	sbrc	r18, 1
	if (reportBuffer[BUTTON_ROW_1] & 0x02) PINS &= ~(PIN08 | PIN06);//tops (diamond style A)  
    4cf8:	85 7f       	andi	r24, 0xF5	; 245
    4cfa:	22 fd       	sbrc	r18, 2
	if (reportBuffer[BUTTON_ROW_1] & 0x04 || reportBuffer[BUTTON_ROW_1] & 0x80) PINS &= ~(PIN06 | PIN07);//sega and snes styles b2 (diamond style Y)
    4cfc:	01 c0       	rjmp	.+2      	; 0x4d00 <Update+0x1b2>
    4cfe:	27 fd       	sbrc	r18, 7
    4d00:	83 7f       	andi	r24, 0xF3	; 243
    4d02:	85 b9       	out	0x05, r24	; 5
	
	
	PORTB = PINS;
    4d04:	df 91       	pop	r29
 
}																	  
    4d06:	cf 91       	pop	r28
    4d08:	08 95       	ret

00004d0a <intlGetConsole>:
    4d0a:	86 e9       	ldi	r24, 0x96	; 150
};

ConsoleFound *intlGetConsole(void)
{
	return &INTEL_Console;
}
    4d0c:	91 e0       	ldi	r25, 0x01	; 1
    4d0e:	08 95       	ret

00004d10 <DoWork>:

/*********** prototypes *************/
static void Init(void);
static void Update(void);
static unsigned char Probe(void);
static void DoWork(void){};
    4d10:	08 95       	ret

00004d12 <Init>:
		
void Init(void)
{	 
	 
	//is this needed?
	PORTB = 0xff;//all high.
    4d12:	8f ef       	ldi	r24, 0xFF	; 255
    4d14:	85 b9       	out	0x05, r24	; 5
	PORTD = 0xff;//all high.
    4d16:	8b b9       	out	0x0b, r24	; 11
	
	DDRB = 0x0f; //Key pad  out/in pins f0 are in 0f are out
    4d18:	8f e0       	ldi	r24, 0x0F	; 15
    4d1a:	84 b9       	out	0x04, r24	; 4
	
	DDRC &= ~0x40; //common for pots. 
    4d1c:	3e 98       	cbi	0x07, 6	; 7

	DDRD |= 0x30; //side buttons
    4d1e:	8a b1       	in	r24, 0x0a	; 10
    4d20:	80 63       	ori	r24, 0x30	; 48
    4d22:	8a b9       	out	0x0a, r24	; 10
	
	DDRD &= ~0xC0;//pot lines in and high.
    4d24:	8a b1       	in	r24, 0x0a	; 10
    4d26:	8f 73       	andi	r24, 0x3F	; 63
    4d28:	8a b9       	out	0x0a, r24	; 10
    4d2a:	08 95       	ret

00004d2c <CleanUp>:
	//5200 pin 13 bottom trigger
	//5200 pin 14 top trigger
	//5200 pin 15 ground
}
void CleanUp(void)
{
    4d2c:	08 95       	ret

00004d2e <Update>:
	// further, so 13 total with a 10ms resolution. To calabrate//
	// it the console shrinks or lengthens that 3 ms window.    //
	//////////////////////////////////////////////////////////////
	bool capOperation=0;

	LATCH1=0xff;
    4d2e:	8f ef       	ldi	r24, 0xFF	; 255
    4d30:	80 93 30 03 	sts	0x0330, r24
	LATCH2=0xff;
    4d34:	80 93 2f 03 	sts	0x032F, r24
	LATCH3=0xff;
    4d38:	80 93 2e 03 	sts	0x032E, r24
	LATCH4=0xff;
    4d3c:	80 93 2d 03 	sts	0x032D, r24
	
	timer=0;
    4d40:	10 92 32 03 	sts	0x0332, r1
    4d44:	10 92 31 03 	sts	0x0331, r1

	//keypad
	if (reportBuffer[BUTTON_ROW_2] & 0x01) LATCH2 &= ~(PIN07);//1 
    4d48:	80 91 69 03 	lds	r24, 0x0369
    4d4c:	80 ff       	sbrs	r24, 0
    4d4e:	03 c0       	rjmp	.+6      	; 0x4d56 <Update+0x28>
    4d50:	9d ef       	ldi	r25, 0xFD	; 253
    4d52:	90 93 2f 03 	sts	0x032F, r25
	if (reportBuffer[BUTTON_ROW_2] & 0x02) LATCH3 &= ~(PIN07);//2
    4d56:	81 ff       	sbrs	r24, 1
    4d58:	03 c0       	rjmp	.+6      	; 0x4d60 <Update+0x32>
    4d5a:	9d ef       	ldi	r25, 0xFD	; 253
    4d5c:	90 93 2e 03 	sts	0x032E, r25
	if (reportBuffer[BUTTON_ROW_2] & 0x04) LATCH4 &= ~(PIN07);//3
    4d60:	82 ff       	sbrs	r24, 2
    4d62:	03 c0       	rjmp	.+6      	; 0x4d6a <Update+0x3c>
    4d64:	9d ef       	ldi	r25, 0xFD	; 253
    4d66:	90 93 2d 03 	sts	0x032D, r25
	if (reportBuffer[BUTTON_ROW_2] & 0x08) LATCH2 &= ~(PIN06);//4
    4d6a:	83 ff       	sbrs	r24, 3
    4d6c:	05 c0       	rjmp	.+10     	; 0x4d78 <Update+0x4a>
    4d6e:	90 91 2f 03 	lds	r25, 0x032F
    4d72:	9b 7f       	andi	r25, 0xFB	; 251
    4d74:	90 93 2f 03 	sts	0x032F, r25
	if (reportBuffer[BUTTON_ROW_2] & 0x10) LATCH3 &= ~(PIN06);//5
    4d78:	84 ff       	sbrs	r24, 4
    4d7a:	05 c0       	rjmp	.+10     	; 0x4d86 <Update+0x58>
    4d7c:	90 91 2e 03 	lds	r25, 0x032E
    4d80:	9b 7f       	andi	r25, 0xFB	; 251
    4d82:	90 93 2e 03 	sts	0x032E, r25
	if (reportBuffer[BUTTON_ROW_2] & 0x20) LATCH4 &= ~(PIN06);//6
    4d86:	85 ff       	sbrs	r24, 5
    4d88:	05 c0       	rjmp	.+10     	; 0x4d94 <Update+0x66>
    4d8a:	90 91 2d 03 	lds	r25, 0x032D
    4d8e:	9b 7f       	andi	r25, 0xFB	; 251
    4d90:	90 93 2d 03 	sts	0x032D, r25
	if (reportBuffer[BUTTON_ROW_2] & 0x40) LATCH2 &= ~(PIN05);//7 
    4d94:	86 ff       	sbrs	r24, 6
    4d96:	05 c0       	rjmp	.+10     	; 0x4da2 <Update+0x74>
    4d98:	90 91 2f 03 	lds	r25, 0x032F
    4d9c:	97 7f       	andi	r25, 0xF7	; 247
    4d9e:	90 93 2f 03 	sts	0x032F, r25
	if (reportBuffer[BUTTON_ROW_2] & 0x80) LATCH3 &= ~(PIN05);//8
    4da2:	87 ff       	sbrs	r24, 7
    4da4:	05 c0       	rjmp	.+10     	; 0x4db0 <Update+0x82>
    4da6:	80 91 2e 03 	lds	r24, 0x032E
    4daa:	87 7f       	andi	r24, 0xF7	; 247
    4dac:	80 93 2e 03 	sts	0x032E, r24
	if (reportBuffer[BUTTON_ROW_3] & 0x01) LATCH4 &= ~(PIN05);//9
    4db0:	80 91 7b 03 	lds	r24, 0x037B
    4db4:	80 ff       	sbrs	r24, 0
    4db6:	05 c0       	rjmp	.+10     	; 0x4dc2 <Update+0x94>
    4db8:	90 91 2d 03 	lds	r25, 0x032D
    4dbc:	97 7f       	andi	r25, 0xF7	; 247
    4dbe:	90 93 2d 03 	sts	0x032D, r25
	if (reportBuffer[BUTTON_ROW_3] & 0x02) LATCH2 &= ~(PIN08);//*
    4dc2:	81 ff       	sbrs	r24, 1
    4dc4:	05 c0       	rjmp	.+10     	; 0x4dd0 <Update+0xa2>
    4dc6:	90 91 2f 03 	lds	r25, 0x032F
    4dca:	9e 7f       	andi	r25, 0xFE	; 254
    4dcc:	90 93 2f 03 	sts	0x032F, r25
	if (reportBuffer[BUTTON_ROW_3] & 0x04) LATCH3 &= ~(PIN08);//0
    4dd0:	82 ff       	sbrs	r24, 2
    4dd2:	05 c0       	rjmp	.+10     	; 0x4dde <Update+0xb0>
    4dd4:	90 91 2e 03 	lds	r25, 0x032E
    4dd8:	9e 7f       	andi	r25, 0xFE	; 254
    4dda:	90 93 2e 03 	sts	0x032E, r25
	if (reportBuffer[BUTTON_ROW_3] & 0x08) LATCH4 &= ~(PIN08);//#
    4dde:	83 ff       	sbrs	r24, 3
    4de0:	05 c0       	rjmp	.+10     	; 0x4dec <Update+0xbe>
    4de2:	80 91 2d 03 	lds	r24, 0x032D
    4de6:	8e 7f       	andi	r24, 0xFE	; 254
    4de8:	80 93 2d 03 	sts	0x032D, r24

	//buttons
	if (reportBuffer[BUTTON_ROW_1] & 0x10) LATCH1 &= ~(PIN07) ;//start
    4dec:	80 91 68 03 	lds	r24, 0x0368
    4df0:	84 ff       	sbrs	r24, 4
    4df2:	03 c0       	rjmp	.+6      	; 0x4dfa <Update+0xcc>
    4df4:	9d ef       	ldi	r25, 0xFD	; 253
    4df6:	90 93 30 03 	sts	0x0330, r25
	if (reportBuffer[BUTTON_ROW_1] & 0x20) LATCH1 &= ~(PIN06) ;//pause
    4dfa:	85 ff       	sbrs	r24, 5
    4dfc:	05 c0       	rjmp	.+10     	; 0x4e08 <Update+0xda>
    4dfe:	90 91 30 03 	lds	r25, 0x0330
    4e02:	9b 7f       	andi	r25, 0xFB	; 251
    4e04:	90 93 30 03 	sts	0x0330, r25
	if (reportBuffer[BUTTON_ROW_1] & 0x04) LATCH1 &= ~(PIN05) ;//reset
    4e08:	82 ff       	sbrs	r24, 2
    4e0a:	05 c0       	rjmp	.+10     	; 0x4e16 <Update+0xe8>
    4e0c:	90 91 30 03 	lds	r25, 0x0330
    4e10:	97 7f       	andi	r25, 0xF7	; 247
    4e12:	90 93 30 03 	sts	0x0330, r25
	
	//triggers
	if (reportBuffer[BUTTON_ROW_1] & 0x01) PORTD &= ~0x10; else PORTD |= 0x10;//botton  
    4e16:	80 ff       	sbrs	r24, 0
    4e18:	02 c0       	rjmp	.+4      	; 0x4e1e <Update+0xf0>
    4e1a:	5c 98       	cbi	0x0b, 4	; 11
    4e1c:	01 c0       	rjmp	.+2      	; 0x4e20 <Update+0xf2>
    4e1e:	5c 9a       	sbi	0x0b, 4	; 11
	if (reportBuffer[BUTTON_ROW_1] & 0x02) PORTD &= ~0x20; else PORTD |= 0x20;//top  
    4e20:	80 91 68 03 	lds	r24, 0x0368
    4e24:	81 ff       	sbrs	r24, 1
    4e26:	02 c0       	rjmp	.+4      	; 0x4e2c <Update+0xfe>
    4e28:	5d 98       	cbi	0x0b, 5	; 11
    4e2a:	09 c0       	rjmp	.+18     	; 0x4e3e <Update+0x110>
    4e2c:	5d 9a       	sbi	0x0b, 5	; 11
    4e2e:	07 c0       	rjmp	.+14     	; 0x4e3e <Update+0x110>
	// to make sure we come in at this point  //
	// if not run this  to find it	    	  //
	//not the console does not go high so we  //
	//can only use in and high to detect this //
	////////////////////////////////////////////
	WHILE_H_POT_IS_hi
    4e30:	4e 9b       	sbis	0x09, 6	; 9
    4e32:	11 c0       	rjmp	.+34     	; 0x4e56 <Update+0x128>
    4e34:	01 96       	adiw	r24, 0x01	; 1
    4e36:	90 93 32 03 	sts	0x0332, r25
    4e3a:	80 93 31 03 	sts	0x0331, r24
    4e3e:	80 91 31 03 	lds	r24, 0x0331
    4e42:	90 91 32 03 	lds	r25, 0x0332
    4e46:	88 36       	cpi	r24, 0x68	; 104
    4e48:	22 e4       	ldi	r18, 0x42	; 66
    4e4a:	92 07       	cpc	r25, r18
    4e4c:	88 f3       	brcs	.-30     	; 0x4e30 <Update+0x102>
	if (timer ==MAX_TIME )  return; 
    4e4e:	88 36       	cpi	r24, 0x68	; 104
    4e50:	92 44       	sbci	r25, 0x42	; 66
    4e52:	09 f4       	brne	.+2      	; 0x4e56 <Update+0x128>
    4e54:	e0 c0       	rjmp	.+448    	; 0x5016 <Update+0x2e8>

}
																	  
unsigned char DoButtons(void)
{ //around 500us but drifts. 
	timer=0;//synbc and check
    4e56:	10 92 32 03 	sts	0x0332, r1
    4e5a:	10 92 31 03 	sts	0x0331, r1
	while (  (PINB & 0x10)  ) 
    4e5e:	1c 9b       	sbis	0x03, 4	; 3
    4e60:	17 c0       	rjmp	.+46     	; 0x4e90 <Update+0x162>
	{
		if (timer > 500) {PORTD |= 1;return; }
    4e62:	80 91 31 03 	lds	r24, 0x0331
    4e66:	90 91 32 03 	lds	r25, 0x0332
    4e6a:	85 3f       	cpi	r24, 0xF5	; 245
    4e6c:	f1 e0       	ldi	r31, 0x01	; 1
    4e6e:	9f 07       	cpc	r25, r31
    4e70:	10 f0       	brcs	.+4      	; 0x4e76 <Update+0x148>
    4e72:	58 9a       	sbi	0x0b, 0	; 11
    4e74:	6b c0       	rjmp	.+214    	; 0x4f4c <Update+0x21e>
		timer++;
    4e76:	01 96       	adiw	r24, 0x01	; 1
    4e78:	90 93 32 03 	sts	0x0332, r25
    4e7c:	80 93 31 03 	sts	0x0331, r24
    4e80:	ee cf       	rjmp	.-36     	; 0x4e5e <Update+0x130>
	};	

	WHILE_PULSE1_IS_HI //s,p,r,none
    4e82:	1c 9b       	sbis	0x03, 4	; 3
    4e84:	0d c0       	rjmp	.+26     	; 0x4ea0 <Update+0x172>
    4e86:	01 96       	adiw	r24, 0x01	; 1
    4e88:	90 93 32 03 	sts	0x0332, r25
    4e8c:	80 93 31 03 	sts	0x0331, r24
    4e90:	80 91 31 03 	lds	r24, 0x0331
    4e94:	90 91 32 03 	lds	r25, 0x0332
    4e98:	88 36       	cpi	r24, 0x68	; 104
    4e9a:	22 e4       	ldi	r18, 0x42	; 66
    4e9c:	92 07       	cpc	r25, r18
    4e9e:	88 f3       	brcs	.-30     	; 0x4e82 <Update+0x154>
	PORTB = LATCH1;
    4ea0:	80 91 30 03 	lds	r24, 0x0330
    4ea4:	85 b9       	out	0x05, r24	; 5

	WHILE_PULSE2_IS_HI//1,4,7,*
    4ea6:	80 91 31 03 	lds	r24, 0x0331
    4eaa:	90 91 32 03 	lds	r25, 0x0332
    4eae:	88 36       	cpi	r24, 0x68	; 104
    4eb0:	e2 e4       	ldi	r30, 0x42	; 66
    4eb2:	9e 07       	cpc	r25, r30
    4eb4:	40 f4       	brcc	.+16     	; 0x4ec6 <Update+0x198>
    4eb6:	1d 9b       	sbis	0x03, 5	; 3
    4eb8:	06 c0       	rjmp	.+12     	; 0x4ec6 <Update+0x198>
    4eba:	01 96       	adiw	r24, 0x01	; 1
    4ebc:	90 93 32 03 	sts	0x0332, r25
    4ec0:	80 93 31 03 	sts	0x0331, r24
    4ec4:	f0 cf       	rjmp	.-32     	; 0x4ea6 <Update+0x178>
	PORTB = LATCH2;
    4ec6:	80 91 2f 03 	lds	r24, 0x032F
    4eca:	85 b9       	out	0x05, r24	; 5

	WHILE_PULSE3_IS_HI//2,5,8,0
    4ecc:	80 91 31 03 	lds	r24, 0x0331
    4ed0:	90 91 32 03 	lds	r25, 0x0332
    4ed4:	88 36       	cpi	r24, 0x68	; 104
    4ed6:	f2 e4       	ldi	r31, 0x42	; 66
    4ed8:	9f 07       	cpc	r25, r31
    4eda:	40 f4       	brcc	.+16     	; 0x4eec <Update+0x1be>
    4edc:	1e 9b       	sbis	0x03, 6	; 3
    4ede:	06 c0       	rjmp	.+12     	; 0x4eec <Update+0x1be>
    4ee0:	01 96       	adiw	r24, 0x01	; 1
    4ee2:	90 93 32 03 	sts	0x0332, r25
    4ee6:	80 93 31 03 	sts	0x0331, r24
    4eea:	f0 cf       	rjmp	.-32     	; 0x4ecc <Update+0x19e>
	PORTB = LATCH3;
    4eec:	80 91 2e 03 	lds	r24, 0x032E
    4ef0:	85 b9       	out	0x05, r24	; 5

	WHILE_PULSE4_IS_HI//3,6,9,#
    4ef2:	80 91 31 03 	lds	r24, 0x0331
    4ef6:	90 91 32 03 	lds	r25, 0x0332
    4efa:	88 36       	cpi	r24, 0x68	; 104
    4efc:	22 e4       	ldi	r18, 0x42	; 66
    4efe:	92 07       	cpc	r25, r18
    4f00:	40 f4       	brcc	.+16     	; 0x4f12 <Update+0x1e4>
    4f02:	1f 9b       	sbis	0x03, 7	; 3
    4f04:	06 c0       	rjmp	.+12     	; 0x4f12 <Update+0x1e4>
    4f06:	01 96       	adiw	r24, 0x01	; 1
    4f08:	90 93 32 03 	sts	0x0332, r25
    4f0c:	80 93 31 03 	sts	0x0331, r24
    4f10:	f0 cf       	rjmp	.-32     	; 0x4ef2 <Update+0x1c4>
	PORTB = LATCH4;
    4f12:	80 91 2d 03 	lds	r24, 0x032D
    4f16:	85 b9       	out	0x05, r24	; 5

	WHILE_PULSE1_IS_HI
    4f18:	80 91 31 03 	lds	r24, 0x0331
    4f1c:	90 91 32 03 	lds	r25, 0x0332
    4f20:	88 36       	cpi	r24, 0x68	; 104
    4f22:	e2 e4       	ldi	r30, 0x42	; 66
    4f24:	9e 07       	cpc	r25, r30
    4f26:	40 f4       	brcc	.+16     	; 0x4f38 <Update+0x20a>
    4f28:	1c 9b       	sbis	0x03, 4	; 3
    4f2a:	06 c0       	rjmp	.+12     	; 0x4f38 <Update+0x20a>
    4f2c:	01 96       	adiw	r24, 0x01	; 1
    4f2e:	90 93 32 03 	sts	0x0332, r25
    4f32:	80 93 31 03 	sts	0x0331, r24
    4f36:	f0 cf       	rjmp	.-32     	; 0x4f18 <Update+0x1ea>
	PORTB = 0xff; //unset
    4f38:	8f ef       	ldi	r24, 0xFF	; 255
    4f3a:	85 b9       	out	0x05, r24	; 5
    4f3c:	07 c0       	rjmp	.+14     	; 0x4f4c <Update+0x21e>
	WHILE_H_POT_IS_hi
	if (timer ==MAX_TIME )  return; 

	DoButtons(); //this is not a static time, so do it while we are low and then sync to high.
 
	WHILE_H_POT_IS_lo;//now we are in sync
    4f3e:	4e 99       	sbic	0x09, 6	; 9
    4f40:	0d c0       	rjmp	.+26     	; 0x4f5c <Update+0x22e>
    4f42:	01 96       	adiw	r24, 0x01	; 1
    4f44:	90 93 32 03 	sts	0x0332, r25
    4f48:	80 93 31 03 	sts	0x0331, r24
    4f4c:	80 91 31 03 	lds	r24, 0x0331
    4f50:	90 91 32 03 	lds	r25, 0x0332
    4f54:	88 36       	cpi	r24, 0x68	; 104
    4f56:	f2 e4       	ldi	r31, 0x42	; 66
    4f58:	9f 07       	cpc	r25, r31
    4f5a:	88 f3       	brcs	.-30     	; 0x4f3e <Update+0x210>
 
	DDRD |= 0xC0; PORTD &= ~0xC0; //now we need it low for the reads to work right. At this point the line should be low!
    4f5c:	8a b1       	in	r24, 0x0a	; 10
    4f5e:	80 6c       	ori	r24, 0xC0	; 192
    4f60:	8a b9       	out	0x0a, r24	; 10
    4f62:	8b b1       	in	r24, 0x0b	; 11
    4f64:	8f 73       	andi	r24, 0x3F	; 63
    4f66:	8b b9       	out	0x0b, r24	; 11
unsigned char DoAnalog(void)
{

	unsigned char x;
	unsigned char y;
	DDRD |= 0xC0;//out here for fake post.
    4f68:	8a b1       	in	r24, 0x0a	; 10
    4f6a:	80 6c       	ori	r24, 0xC0	; 192
    4f6c:	8a b9       	out	0x0a, r24	; 10
	if ( abs  (reportBuffer[X_MAIN_STICK]-128)  >= abs  (reportBuffer[X_SECONDARY_STICK]-128)  ) x = reportBuffer[X_MAIN_STICK]; else  x = reportBuffer[X_SECONDARY_STICK];
    4f6e:	40 91 6b 03 	lds	r20, 0x036B
    4f72:	50 91 6d 03 	lds	r21, 0x036D
    4f76:	24 2f       	mov	r18, r20
    4f78:	30 e0       	ldi	r19, 0x00	; 0
    4f7a:	20 58       	subi	r18, 0x80	; 128
    4f7c:	31 09       	sbc	r19, r1
    4f7e:	37 ff       	sbrs	r19, 7
    4f80:	03 c0       	rjmp	.+6      	; 0x4f88 <Update+0x25a>
    4f82:	31 95       	neg	r19
    4f84:	21 95       	neg	r18
    4f86:	31 09       	sbc	r19, r1
    4f88:	85 2f       	mov	r24, r21
    4f8a:	90 e0       	ldi	r25, 0x00	; 0
    4f8c:	80 58       	subi	r24, 0x80	; 128
    4f8e:	91 09       	sbc	r25, r1
    4f90:	97 ff       	sbrs	r25, 7
    4f92:	03 c0       	rjmp	.+6      	; 0x4f9a <Update+0x26c>
    4f94:	91 95       	neg	r25
    4f96:	81 95       	neg	r24
    4f98:	91 09       	sbc	r25, r1
    4f9a:	28 17       	cp	r18, r24
    4f9c:	39 07       	cpc	r19, r25
    4f9e:	0c f0       	brlt	.+2      	; 0x4fa2 <Update+0x274>
    4fa0:	54 2f       	mov	r21, r20
	if ( abs  (reportBuffer[Y_MAIN_STICK]-128)  >= abs  (reportBuffer[Y_SECONDARY_STICK]-128)  ) y = reportBuffer[Y_MAIN_STICK]; else  y = reportBuffer[Y_SECONDARY_STICK]; 
    4fa2:	60 91 6c 03 	lds	r22, 0x036C
    4fa6:	40 91 6e 03 	lds	r20, 0x036E
    4faa:	26 2f       	mov	r18, r22
    4fac:	30 e0       	ldi	r19, 0x00	; 0
    4fae:	20 58       	subi	r18, 0x80	; 128
    4fb0:	31 09       	sbc	r19, r1
    4fb2:	37 ff       	sbrs	r19, 7
    4fb4:	03 c0       	rjmp	.+6      	; 0x4fbc <Update+0x28e>
    4fb6:	31 95       	neg	r19
    4fb8:	21 95       	neg	r18
    4fba:	31 09       	sbc	r19, r1
    4fbc:	84 2f       	mov	r24, r20
    4fbe:	90 e0       	ldi	r25, 0x00	; 0
    4fc0:	80 58       	subi	r24, 0x80	; 128
    4fc2:	91 09       	sbc	r25, r1
    4fc4:	97 ff       	sbrs	r25, 7
    4fc6:	03 c0       	rjmp	.+6      	; 0x4fce <Update+0x2a0>
    4fc8:	91 95       	neg	r25
    4fca:	81 95       	neg	r24
    4fcc:	91 09       	sbc	r25, r1
    4fce:	28 17       	cp	r18, r24
    4fd0:	39 07       	cpc	r19, r25
    4fd2:	0c f0       	brlt	.+2      	; 0x4fd6 <Update+0x2a8>
    4fd4:	46 2f       	mov	r20, r22
	if ( reportBuffer[DIAL] > 0 )  x = reportBuffer[DIAL];
    4fd6:	80 91 6f 03 	lds	r24, 0x036F
    4fda:	81 11       	cpse	r24, r1
    4fdc:	01 c0       	rjmp	.+2      	; 0x4fe0 <Update+0x2b2>
    4fde:	85 2f       	mov	r24, r21
	if ( reportBuffer[SLIDER] > 0) x = reportBuffer[SLIDER];
    4fe0:	90 91 70 03 	lds	r25, 0x0370
    4fe4:	91 11       	cpse	r25, r1
    4fe6:	01 c0       	rjmp	.+2      	; 0x4fea <Update+0x2bc>
    4fe8:	98 2f       	mov	r25, r24
	
	//near 14 ms
	for (unsigned char loop = 0; loop < 0xff; loop++) 
    4fea:	80 e0       	ldi	r24, 0x00	; 0
	{
		if (  x <= loop ) {  PORTD |= 0x80; } //expired bring it high
    4fec:	89 17       	cp	r24, r25
    4fee:	08 f0       	brcs	.+2      	; 0x4ff2 <Update+0x2c4>
    4ff0:	5f 9a       	sbi	0x0b, 7	; 11
		if (  y <= loop ) {  PORTD |= 0x40; } //expired bring it high
    4ff2:	84 17       	cp	r24, r20
    4ff4:	08 f0       	brcs	.+2      	; 0x4ff8 <Update+0x2ca>
    4ff6:	5e 9a       	sbi	0x0b, 6	; 11
    4ff8:	eb ed       	ldi	r30, 0xDB	; 219
    4ffa:	f0 e0       	ldi	r31, 0x00	; 0
    4ffc:	31 97       	sbiw	r30, 0x01	; 1
    4ffe:	f1 f7       	brne	.-4      	; 0x4ffc <Update+0x2ce>
    5000:	00 c0       	rjmp	.+0      	; 0x5002 <Update+0x2d4>
    5002:	00 00       	nop
	if ( abs  (reportBuffer[Y_MAIN_STICK]-128)  >= abs  (reportBuffer[Y_SECONDARY_STICK]-128)  ) y = reportBuffer[Y_MAIN_STICK]; else  y = reportBuffer[Y_SECONDARY_STICK]; 
	if ( reportBuffer[DIAL] > 0 )  x = reportBuffer[DIAL];
	if ( reportBuffer[SLIDER] > 0) x = reportBuffer[SLIDER];
	
	//near 14 ms
	for (unsigned char loop = 0; loop < 0xff; loop++) 
    5004:	8f 5f       	subi	r24, 0xFF	; 255
    5006:	8f 3f       	cpi	r24, 0xFF	; 255
    5008:	89 f7       	brne	.-30     	; 0x4fec <Update+0x2be>
		if (  x <= loop ) {  PORTD |= 0x80; } //expired bring it high
		if (  y <= loop ) {  PORTD |= 0x40; } //expired bring it high
		_delay_us(55);
	}
 
	PORTD |= 0xC0; //for the 255 value, be sure its done. 
    500a:	8b b1       	in	r24, 0x0b	; 11
    500c:	80 6c       	ori	r24, 0xC0	; 192
    500e:	8b b9       	out	0x0b, r24	; 11
	DDRD &= ~0xC0;//back in for read. 
    5010:	8a b1       	in	r24, 0x0a	; 10
    5012:	8f 73       	andi	r24, 0x3F	; 63
    5014:	8a b9       	out	0x0a, r24	; 10
    5016:	08 95       	ret

00005018 <Probe>:
    5018:	8f e1       	ldi	r24, 0x1F	; 31
    501a:	93 e0       	ldi	r25, 0x03	; 3
    501c:	01 97       	sbiw	r24, 0x01	; 1
    501e:	f1 f7       	brne	.-4      	; 0x501c <Probe+0x4>
    5020:	00 c0       	rjmp	.+0      	; 0x5022 <Probe+0xa>
    5022:	00 00       	nop

unsigned char Probe(void)
{ 
	_delay_us(200);//stableize
 
	timer=0;
    5024:	10 92 32 03 	sts	0x0332, r1
    5028:	10 92 31 03 	sts	0x0331, r1

	WHILE_PULSE1_IS_HI;//shoudl go low at some point < MAX_TIME
    502c:	80 91 31 03 	lds	r24, 0x0331
    5030:	90 91 32 03 	lds	r25, 0x0332
    5034:	88 36       	cpi	r24, 0x68	; 104
    5036:	22 e4       	ldi	r18, 0x42	; 66
    5038:	92 07       	cpc	r25, r18
    503a:	78 f4       	brcc	.+30     	; 0x505a <Probe+0x42>
    503c:	1c 9b       	sbis	0x03, 4	; 3
    503e:	0d c0       	rjmp	.+26     	; 0x505a <Probe+0x42>
    5040:	01 96       	adiw	r24, 0x01	; 1
    5042:	90 93 32 03 	sts	0x0332, r25
    5046:	80 93 31 03 	sts	0x0331, r24
    504a:	f0 cf       	rjmp	.-32     	; 0x502c <Probe+0x14>
	WHILE_PULSE2_IS_HI;//shoudl go low at some point < MAX_TIME
    504c:	1d 9b       	sbis	0x03, 5	; 3
    504e:	15 c0       	rjmp	.+42     	; 0x507a <Probe+0x62>
    5050:	01 96       	adiw	r24, 0x01	; 1
    5052:	90 93 32 03 	sts	0x0332, r25
    5056:	80 93 31 03 	sts	0x0331, r24
    505a:	80 91 31 03 	lds	r24, 0x0331
    505e:	90 91 32 03 	lds	r25, 0x0332
    5062:	88 36       	cpi	r24, 0x68	; 104
    5064:	22 e4       	ldi	r18, 0x42	; 66
    5066:	92 07       	cpc	r25, r18
    5068:	88 f3       	brcs	.-30     	; 0x504c <Probe+0x34>
    506a:	07 c0       	rjmp	.+14     	; 0x507a <Probe+0x62>
	WHILE_PULSE3_IS_HI;//shoudl go low at some point < MAX_TIME
    506c:	1e 9b       	sbis	0x03, 6	; 3
    506e:	15 c0       	rjmp	.+42     	; 0x509a <Probe+0x82>
    5070:	01 96       	adiw	r24, 0x01	; 1
    5072:	90 93 32 03 	sts	0x0332, r25
    5076:	80 93 31 03 	sts	0x0331, r24
    507a:	80 91 31 03 	lds	r24, 0x0331
    507e:	90 91 32 03 	lds	r25, 0x0332
    5082:	88 36       	cpi	r24, 0x68	; 104
    5084:	22 e4       	ldi	r18, 0x42	; 66
    5086:	92 07       	cpc	r25, r18
    5088:	88 f3       	brcs	.-30     	; 0x506c <Probe+0x54>
    508a:	07 c0       	rjmp	.+14     	; 0x509a <Probe+0x82>
	WHILE_PULSE4_IS_HI;//shoudl go low at some point < MAX_TIME
    508c:	1f 9b       	sbis	0x03, 7	; 3
    508e:	12 c0       	rjmp	.+36     	; 0x50b4 <Probe+0x9c>
    5090:	01 96       	adiw	r24, 0x01	; 1
    5092:	90 93 32 03 	sts	0x0332, r25
    5096:	80 93 31 03 	sts	0x0331, r24
    509a:	80 91 31 03 	lds	r24, 0x0331
    509e:	90 91 32 03 	lds	r25, 0x0332
    50a2:	88 36       	cpi	r24, 0x68	; 104
    50a4:	22 e4       	ldi	r18, 0x42	; 66
    50a6:	92 07       	cpc	r25, r18
    50a8:	88 f3       	brcs	.-30     	; 0x508c <Probe+0x74>

	//if all do not add up, we are good, check 10 again. 
	if (   timer == MAX_TIME) return 0; else return A5200;	//80 is low, 40 and 10 are high	
    50aa:	88 36       	cpi	r24, 0x68	; 104
    50ac:	92 44       	sbci	r25, 0x42	; 66
    50ae:	11 f4       	brne	.+4      	; 0x50b4 <Probe+0x9c>
    50b0:	80 e0       	ldi	r24, 0x00	; 0
    50b2:	08 95       	ret
    50b4:	8b e0       	ldi	r24, 0x0B	; 11

} 
    50b6:	08 95       	ret

000050b8 <a5200GetConsole>:
};

ConsoleFound *a5200GetConsole(void)
{
	return &A5200_Console;
}
    50b8:	80 ea       	ldi	r24, 0xA0	; 160
    50ba:	91 e0       	ldi	r25, 0x01	; 1
    50bc:	08 95       	ret

000050be <Init>:
//2.2us low 2.3us hi (0)
//2.2us low 2.3us low (1)

void Init(void)
{	
	_DDR |= _BOTH;
    50be:	80 b3       	in	r24, 0x10	; 16
    50c0:	80 66       	ori	r24, 0x60	; 96
    50c2:	80 bb       	out	0x10, r24	; 16
	_PORT |= _BOTH;//bring both high to tell slave we are attached. 
    50c4:	81 b3       	in	r24, 0x11	; 17
    50c6:	80 66       	ori	r24, 0x60	; 96
    50c8:	81 bb       	out	0x11, r24	; 17
    50ca:	08 95       	ret

000050cc <CheckFree>:
}

unsigned char  CheckFree(void)
{	
	unsigned reply;
	unsigned char _DDR_ = _DDR;
    50cc:	20 b3       	in	r18, 0x10	; 16
	_DDR &= ~_BOTH;
    50ce:	80 b3       	in	r24, 0x10	; 16
    50d0:	8f 79       	andi	r24, 0x9F	; 159
    50d2:	80 bb       	out	0x10, r24	; 16
	 if (_PIN & _BOTH) reply =1; else reply= 0;
    50d4:	9f b1       	in	r25, 0x0f	; 15
	 _DDR = _DDR_;
    50d6:	20 bb       	out	0x10, r18	; 16
unsigned char  CheckFree(void)
{	
	unsigned reply;
	unsigned char _DDR_ = _DDR;
	_DDR &= ~_BOTH;
	 if (_PIN & _BOTH) reply =1; else reply= 0;
    50d8:	90 76       	andi	r25, 0x60	; 96
    50da:	81 e0       	ldi	r24, 0x01	; 1
    50dc:	09 f4       	brne	.+2      	; 0x50e0 <CheckFree+0x14>
    50de:	80 e0       	ldi	r24, 0x00	; 0
	 _DDR = _DDR_;
	 return reply;
}
    50e0:	08 95       	ret

000050e2 <Read>:
//..make sure we are not sending pressure
//may need better bug not sure. 
	
	
	int count=0;	
    if (_PIN & _BOTH) return GET_CONTROLLER_STATUS_ERROR_NOTREADY;//it is expected to be LO here as we are reading a command.
    50e2:	9f b1       	in	r25, 0x0f	; 15
    50e4:	90 76       	andi	r25, 0x60	; 96
    50e6:	51 f4       	brne	.+20     	; 0x50fc <Read+0x1a>
    50e8:	28 e6       	ldi	r18, 0x68	; 104
    50ea:	32 e4       	ldi	r19, 0x42	; 66
	WHILE_LINE_IS_LO//wait for busy to send, then sync in
    50ec:	9f b1       	in	r25, 0x0f	; 15
    50ee:	90 76       	andi	r25, 0x60	; 96
    50f0:	39 f4       	brne	.+14     	; 0x5100 <Read+0x1e>
    50f2:	21 50       	subi	r18, 0x01	; 1
    50f4:	31 09       	sbc	r19, r1
    50f6:	21 15       	cp	r18, r1
    50f8:	31 05       	cpc	r19, r1
    50fa:	c1 f7       	brne	.-16     	; 0x50ec <Read+0xa>
//..make sure we are not sending pressure
//may need better bug not sure. 
	
	
	int count=0;	
    if (_PIN & _BOTH) return GET_CONTROLLER_STATUS_ERROR_NOTREADY;//it is expected to be LO here as we are reading a command.
    50fc:	8e ef       	ldi	r24, 0xFE	; 254
    50fe:	08 95       	ret
    5100:	96 e0       	ldi	r25, 0x06	; 6
    5102:	9a 95       	dec	r25
    5104:	f1 f7       	brne	.-4      	; 0x5102 <Read+0x20>
    5106:	00 c0       	rjmp	.+0      	; 0x5108 <Read+0x26>
	WHILE_LINE_IS_LO//wait for busy to send, then sync in

	if (count == MAX_TIME2) return GET_CONTROLLER_STATUS_ERROR_NOTREADY;//was not ready.
	_delay_us(1.25); //make sure we are clear.
	
	if ( (_PIN & _BOTH) != 0x00 ) return GET_CONTROLLER_STATUS_ERROR_NOTREADY;//wrong condition.
    5108:	9f b1       	in	r25, 0x0f	; 15
    510a:	90 76       	andi	r25, 0x60	; 96
    510c:	b9 f7       	brne	.-18     	; 0x50fc <Read+0x1a>
    510e:	90 e1       	ldi	r25, 0x10	; 16
    5110:	9a 95       	dec	r25
    5112:	f1 f7       	brne	.-4      	; 0x5110 <Read+0x2e>
    5114:	e3 e4       	ldi	r30, 0x43	; 67
    5116:	f3 e0       	ldi	r31, 0x03	; 3
	_delay_us(3); 
	

	for (char b = 0; b < size; b++)
    5118:	40 e0       	ldi	r20, 0x00	; 0
    511a:	48 17       	cp	r20, r24
    511c:	09 f4       	brne	.+2      	; 0x5120 <Read+0x3e>
    511e:	b1 c0       	rjmp	.+354    	; 0x5282 <Read+0x1a0>
	{
		BB_ReadBuffer[b] >>=1; asm("NOP\nNOP\n"); if (_PIN & _DATA)   _delay_us(.2); else BB_ReadBuffer[b] |= 0x80;  _delay_us(3.7);
    5120:	90 81       	ld	r25, Z
    5122:	96 95       	lsr	r25
    5124:	90 83       	st	Z, r25
    5126:	00 00       	nop
    5128:	00 00       	nop
    512a:	7d 9b       	sbis	0x0f, 5	; 15
    512c:	03 c0       	rjmp	.+6      	; 0x5134 <Read+0x52>
    512e:	00 c0       	rjmp	.+0      	; 0x5130 <Read+0x4e>
    5130:	00 c0       	rjmp	.+0      	; 0x5132 <Read+0x50>
    5132:	02 c0       	rjmp	.+4      	; 0x5138 <Read+0x56>
    5134:	90 68       	ori	r25, 0x80	; 128
    5136:	90 83       	st	Z, r25
    5138:	94 e1       	ldi	r25, 0x14	; 20
    513a:	9a 95       	dec	r25
    513c:	f1 f7       	brne	.-4      	; 0x513a <Read+0x58>
		BB_ReadBuffer[b] >>=1; asm("NOP\nNOP\n"); if (_PIN & _DATA)   _delay_us(.2); else BB_ReadBuffer[b] |= 0x80;  _delay_us(3.7);
    513e:	90 81       	ld	r25, Z
    5140:	96 95       	lsr	r25
    5142:	90 83       	st	Z, r25
    5144:	00 00       	nop
    5146:	00 00       	nop
    5148:	7d 9b       	sbis	0x0f, 5	; 15
    514a:	03 c0       	rjmp	.+6      	; 0x5152 <Read+0x70>
    514c:	00 c0       	rjmp	.+0      	; 0x514e <Read+0x6c>
    514e:	00 c0       	rjmp	.+0      	; 0x5150 <Read+0x6e>
    5150:	02 c0       	rjmp	.+4      	; 0x5156 <Read+0x74>
    5152:	90 68       	ori	r25, 0x80	; 128
    5154:	90 83       	st	Z, r25
    5156:	94 e1       	ldi	r25, 0x14	; 20
    5158:	9a 95       	dec	r25
    515a:	f1 f7       	brne	.-4      	; 0x5158 <Read+0x76>
		BB_ReadBuffer[b] >>=1; asm("NOP\nNOP\n"); if (_PIN & _DATA)   _delay_us(.2); else BB_ReadBuffer[b] |= 0x80;  _delay_us(3.7);
    515c:	90 81       	ld	r25, Z
    515e:	96 95       	lsr	r25
    5160:	90 83       	st	Z, r25
    5162:	00 00       	nop
    5164:	00 00       	nop
    5166:	7d 9b       	sbis	0x0f, 5	; 15
    5168:	03 c0       	rjmp	.+6      	; 0x5170 <Read+0x8e>
    516a:	00 c0       	rjmp	.+0      	; 0x516c <Read+0x8a>
    516c:	00 c0       	rjmp	.+0      	; 0x516e <Read+0x8c>
    516e:	02 c0       	rjmp	.+4      	; 0x5174 <Read+0x92>
    5170:	90 68       	ori	r25, 0x80	; 128
    5172:	90 83       	st	Z, r25
    5174:	94 e1       	ldi	r25, 0x14	; 20
    5176:	9a 95       	dec	r25
    5178:	f1 f7       	brne	.-4      	; 0x5176 <Read+0x94>
		BB_ReadBuffer[b] >>=1; asm("NOP\nNOP\n"); if (_PIN & _DATA)   _delay_us(.2); else BB_ReadBuffer[b] |= 0x80;  _delay_us(3.7);
    517a:	90 81       	ld	r25, Z
    517c:	96 95       	lsr	r25
    517e:	90 83       	st	Z, r25
    5180:	00 00       	nop
    5182:	00 00       	nop
    5184:	7d 9b       	sbis	0x0f, 5	; 15
    5186:	03 c0       	rjmp	.+6      	; 0x518e <Read+0xac>
    5188:	00 c0       	rjmp	.+0      	; 0x518a <Read+0xa8>
    518a:	00 c0       	rjmp	.+0      	; 0x518c <Read+0xaa>
    518c:	02 c0       	rjmp	.+4      	; 0x5192 <Read+0xb0>
    518e:	90 68       	ori	r25, 0x80	; 128
    5190:	90 83       	st	Z, r25
    5192:	94 e1       	ldi	r25, 0x14	; 20
    5194:	9a 95       	dec	r25
    5196:	f1 f7       	brne	.-4      	; 0x5194 <Read+0xb2>
		BB_ReadBuffer[b] >>=1; asm("NOP\nNOP\n"); if (_PIN & _DATA)   _delay_us(.2); else BB_ReadBuffer[b] |= 0x80;  _delay_us(3.7);
    5198:	90 81       	ld	r25, Z
    519a:	96 95       	lsr	r25
    519c:	90 83       	st	Z, r25
    519e:	00 00       	nop
    51a0:	00 00       	nop
    51a2:	7d 9b       	sbis	0x0f, 5	; 15
    51a4:	03 c0       	rjmp	.+6      	; 0x51ac <Read+0xca>
    51a6:	00 c0       	rjmp	.+0      	; 0x51a8 <Read+0xc6>
    51a8:	00 c0       	rjmp	.+0      	; 0x51aa <Read+0xc8>
    51aa:	02 c0       	rjmp	.+4      	; 0x51b0 <Read+0xce>
    51ac:	90 68       	ori	r25, 0x80	; 128
    51ae:	90 83       	st	Z, r25
    51b0:	94 e1       	ldi	r25, 0x14	; 20
    51b2:	9a 95       	dec	r25
    51b4:	f1 f7       	brne	.-4      	; 0x51b2 <Read+0xd0>
		BB_ReadBuffer[b] >>=1; asm("NOP\nNOP\n"); if (_PIN & _DATA)   _delay_us(.2); else BB_ReadBuffer[b] |= 0x80;  _delay_us(3.7);
    51b6:	90 81       	ld	r25, Z
    51b8:	96 95       	lsr	r25
    51ba:	90 83       	st	Z, r25
    51bc:	00 00       	nop
    51be:	00 00       	nop
    51c0:	7d 9b       	sbis	0x0f, 5	; 15
    51c2:	03 c0       	rjmp	.+6      	; 0x51ca <Read+0xe8>
    51c4:	00 c0       	rjmp	.+0      	; 0x51c6 <Read+0xe4>
    51c6:	00 c0       	rjmp	.+0      	; 0x51c8 <Read+0xe6>
    51c8:	02 c0       	rjmp	.+4      	; 0x51ce <Read+0xec>
    51ca:	90 68       	ori	r25, 0x80	; 128
    51cc:	90 83       	st	Z, r25
    51ce:	94 e1       	ldi	r25, 0x14	; 20
    51d0:	9a 95       	dec	r25
    51d2:	f1 f7       	brne	.-4      	; 0x51d0 <Read+0xee>
		BB_ReadBuffer[b] >>=1; asm("NOP\nNOP\n"); if (_PIN & _DATA)   _delay_us(.2); else BB_ReadBuffer[b] |= 0x80;  _delay_us(3.7);
    51d4:	90 81       	ld	r25, Z
    51d6:	96 95       	lsr	r25
    51d8:	90 83       	st	Z, r25
    51da:	00 00       	nop
    51dc:	00 00       	nop
    51de:	7d 9b       	sbis	0x0f, 5	; 15
    51e0:	03 c0       	rjmp	.+6      	; 0x51e8 <Read+0x106>
    51e2:	00 c0       	rjmp	.+0      	; 0x51e4 <Read+0x102>
    51e4:	00 c0       	rjmp	.+0      	; 0x51e6 <Read+0x104>
    51e6:	02 c0       	rjmp	.+4      	; 0x51ec <Read+0x10a>
    51e8:	90 68       	ori	r25, 0x80	; 128
    51ea:	90 83       	st	Z, r25
    51ec:	94 e1       	ldi	r25, 0x14	; 20
    51ee:	9a 95       	dec	r25
    51f0:	f1 f7       	brne	.-4      	; 0x51ee <Read+0x10c>
		BB_ReadBuffer[b] >>=1; asm("NOP\nNOP\n"); if (_PIN & _DATA)   _delay_us(.2); else BB_ReadBuffer[b] |= 0x80;  
    51f2:	90 81       	ld	r25, Z
    51f4:	96 95       	lsr	r25
    51f6:	90 83       	st	Z, r25
    51f8:	00 00       	nop
    51fa:	00 00       	nop
    51fc:	7d 9b       	sbis	0x0f, 5	; 15
    51fe:	03 c0       	rjmp	.+6      	; 0x5206 <Read+0x124>
    5200:	00 c0       	rjmp	.+0      	; 0x5202 <Read+0x120>
    5202:	00 c0       	rjmp	.+0      	; 0x5204 <Read+0x122>
    5204:	02 c0       	rjmp	.+4      	; 0x520a <Read+0x128>
    5206:	90 68       	ori	r25, 0x80	; 128
    5208:	90 83       	st	Z, r25

		count=0;
		if ( _PIN & _DATA )
    520a:	7d 9b       	sbis	0x0f, 5	; 15
    520c:	17 c0       	rjmp	.+46     	; 0x523c <Read+0x15a>
    520e:	20 e0       	ldi	r18, 0x00	; 0
    5210:	30 e0       	ldi	r19, 0x00	; 0
		{ 
			WHILE_DATA_IS_HI
    5212:	7d 9b       	sbis	0x0f, 5	; 15
    5214:	0b c0       	rjmp	.+22     	; 0x522c <Read+0x14a>
    5216:	2f 5f       	subi	r18, 0xFF	; 255
    5218:	3f 4f       	sbci	r19, 0xFF	; 255
    521a:	2c 3d       	cpi	r18, 0xDC	; 220
    521c:	95 e0       	ldi	r25, 0x05	; 5
    521e:	39 07       	cpc	r19, r25
    5220:	c1 f7       	brne	.-16     	; 0x5212 <Read+0x130>
    5222:	04 c0       	rjmp	.+8      	; 0x522c <Read+0x14a>
			WHILE_DATA_IS_LO
    5224:	7d 99       	sbic	0x0f, 5	; 15
    5226:	06 c0       	rjmp	.+12     	; 0x5234 <Read+0x152>
    5228:	2f 5f       	subi	r18, 0xFF	; 255
    522a:	3f 4f       	sbci	r19, 0xFF	; 255
    522c:	2c 3d       	cpi	r18, 0xDC	; 220
    522e:	95 e0       	ldi	r25, 0x05	; 5
    5230:	39 07       	cpc	r19, r25
    5232:	c1 f7       	brne	.-16     	; 0x5224 <Read+0x142>
    5234:	96 e0       	ldi	r25, 0x06	; 6
    5236:	9a 95       	dec	r25
    5238:	f1 f7       	brne	.-4      	; 0x5236 <Read+0x154>
    523a:	20 c0       	rjmp	.+64     	; 0x527c <Read+0x19a>
		BB_ReadBuffer[b] >>=1; asm("NOP\nNOP\n"); if (_PIN & _DATA)   _delay_us(.2); else BB_ReadBuffer[b] |= 0x80;  _delay_us(3.7);
		BB_ReadBuffer[b] >>=1; asm("NOP\nNOP\n"); if (_PIN & _DATA)   _delay_us(.2); else BB_ReadBuffer[b] |= 0x80;  _delay_us(3.7);
		BB_ReadBuffer[b] >>=1; asm("NOP\nNOP\n"); if (_PIN & _DATA)   _delay_us(.2); else BB_ReadBuffer[b] |= 0x80;  

		count=0;
		if ( _PIN & _DATA )
    523c:	20 e0       	ldi	r18, 0x00	; 0
    523e:	30 e0       	ldi	r19, 0x00	; 0
			WHILE_DATA_IS_LO
			_delay_us(1.1);
		}
		else
		{
			WHILE_DATA_IS_LO
    5240:	7d 99       	sbic	0x0f, 5	; 15
    5242:	0b c0       	rjmp	.+22     	; 0x525a <Read+0x178>
    5244:	2f 5f       	subi	r18, 0xFF	; 255
    5246:	3f 4f       	sbci	r19, 0xFF	; 255
    5248:	2c 3d       	cpi	r18, 0xDC	; 220
    524a:	95 e0       	ldi	r25, 0x05	; 5
    524c:	39 07       	cpc	r19, r25
    524e:	c1 f7       	brne	.-16     	; 0x5240 <Read+0x15e>
    5250:	04 c0       	rjmp	.+8      	; 0x525a <Read+0x178>
			WHILE_DATA_IS_HI
    5252:	7d 9b       	sbis	0x0f, 5	; 15
    5254:	0b c0       	rjmp	.+22     	; 0x526c <Read+0x18a>
    5256:	2f 5f       	subi	r18, 0xFF	; 255
    5258:	3f 4f       	sbci	r19, 0xFF	; 255
    525a:	2c 3d       	cpi	r18, 0xDC	; 220
    525c:	95 e0       	ldi	r25, 0x05	; 5
    525e:	39 07       	cpc	r19, r25
    5260:	c1 f7       	brne	.-16     	; 0x5252 <Read+0x170>
    5262:	04 c0       	rjmp	.+8      	; 0x526c <Read+0x18a>
			WHILE_DATA_IS_LO
    5264:	7d 99       	sbic	0x0f, 5	; 15
    5266:	06 c0       	rjmp	.+12     	; 0x5274 <Read+0x192>
    5268:	2f 5f       	subi	r18, 0xFF	; 255
    526a:	3f 4f       	sbci	r19, 0xFF	; 255
    526c:	2c 3d       	cpi	r18, 0xDC	; 220
    526e:	95 e0       	ldi	r25, 0x05	; 5
    5270:	39 07       	cpc	r19, r25
    5272:	c1 f7       	brne	.-16     	; 0x5264 <Read+0x182>
    5274:	95 e0       	ldi	r25, 0x05	; 5
    5276:	9a 95       	dec	r25
    5278:	f1 f7       	brne	.-4      	; 0x5276 <Read+0x194>
    527a:	00 00       	nop
	
	if ( (_PIN & _BOTH) != 0x00 ) return GET_CONTROLLER_STATUS_ERROR_NOTREADY;//wrong condition.
	_delay_us(3); 
	

	for (char b = 0; b < size; b++)
    527c:	4f 5f       	subi	r20, 0xFF	; 255
    527e:	31 96       	adiw	r30, 0x01	; 1
    5280:	4c cf       	rjmp	.-360    	; 0x511a <Read+0x38>
    5282:	85 e3       	ldi	r24, 0x35	; 53
    5284:	8a 95       	dec	r24
    5286:	f1 f7       	brne	.-4      	; 0x5284 <Read+0x1a2>
    5288:	00 00       	nop
		}
		
	}

	_delay_us(10);//best to pause out reads. 
	return BB_ReadBuffer[0]; 	
    528a:	80 91 43 03 	lds	r24, 0x0343
    528e:	08 95       	ret

00005290 <Write>:
	

signed char Write(unsigned char data)
{	
	int count=0;
	_DDR &= ~_BOTH;//in to be sure
    5290:	90 b3       	in	r25, 0x10	; 16
    5292:	9f 79       	andi	r25, 0x9F	; 159
    5294:	90 bb       	out	0x10, r25	; 16
    5296:	28 e6       	ldi	r18, 0x68	; 104
    5298:	32 e4       	ldi	r19, 0x42	; 66
	WHILE_LINE_IS_LO//this will wait up to near 5.6 ms, this may be bad for xbox... but psx needs more then 4.6 as it takes that long to poll on a Bliss-Box
    529a:	9f b1       	in	r25, 0x0f	; 15
    529c:	90 76       	andi	r25, 0x60	; 96
    529e:	39 f4       	brne	.+14     	; 0x52ae <Write+0x1e>
    52a0:	21 50       	subi	r18, 0x01	; 1
    52a2:	31 09       	sbc	r19, r1
    52a4:	21 15       	cp	r18, r1
    52a6:	31 05       	cpc	r19, r1
    52a8:	c1 f7       	brne	.-16     	; 0x529a <Write+0xa>
		
	if (count == MAX_TIME2) 
	{
		return -1;//was not ready.
    52aa:	8f ef       	ldi	r24, 0xFF	; 255
    52ac:	08 95       	ret
    52ae:	9a e1       	ldi	r25, 0x1A	; 26
    52b0:	9a 95       	dec	r25
    52b2:	f1 f7       	brne	.-4      	; 0x52b0 <Write+0x20>
    52b4:	00 c0       	rjmp	.+0      	; 0x52b6 <Write+0x26>
	}
	
	
	_delay_us(5);//new spec, must wait 5 us before we talk so the resister values are stable. 

	_DDR |= _BOTH;// out
    52b6:	90 b3       	in	r25, 0x10	; 16
    52b8:	90 66       	ori	r25, 0x60	; 96
    52ba:	90 bb       	out	0x10, r25	; 16
	_PORT &= ~_BOTH;//start talk both low
    52bc:	91 b3       	in	r25, 0x11	; 17
    52be:	9f 79       	andi	r25, 0x9F	; 159
    52c0:	91 bb       	out	0x11, r25	; 17
    52c2:	27 e0       	ldi	r18, 0x07	; 7
    52c4:	2a 95       	dec	r18
    52c6:	f1 f7       	brne	.-4      	; 0x52c4 <Write+0x34>
    52c8:	98 e0       	ldi	r25, 0x08	; 8
	_delay_us(1.3);
	for (char bit=0;bit<8;bit++)
	{
		_PORT |= _DATA;//set bit high
    52ca:	8d 9a       	sbi	0x11, 5	; 17
    52cc:	2a e0       	ldi	r18, 0x0A	; 10
    52ce:	2a 95       	dec	r18
    52d0:	f1 f7       	brne	.-4      	; 0x52ce <Write+0x3e>
    52d2:	00 c0       	rjmp	.+0      	; 0x52d4 <Write+0x44>
		_delay_us(2);
		if (data & 0x01) _PORT &= ~_DATA;
    52d4:	80 fd       	sbrc	r24, 0
    52d6:	8d 98       	cbi	0x11, 5	; 17
    52d8:	2a e0       	ldi	r18, 0x0A	; 10
    52da:	2a 95       	dec	r18
    52dc:	f1 f7       	brne	.-4      	; 0x52da <Write+0x4a>
    52de:	00 c0       	rjmp	.+0      	; 0x52e0 <Write+0x50>
		_delay_us(2);	
		data >>=1;
    52e0:	86 95       	lsr	r24
    52e2:	91 50       	subi	r25, 0x01	; 1
	_delay_us(5);//new spec, must wait 5 us before we talk so the resister values are stable. 

	_DDR |= _BOTH;// out
	_PORT &= ~_BOTH;//start talk both low
	_delay_us(1.3);
	for (char bit=0;bit<8;bit++)
    52e4:	91 f7       	brne	.-28     	; 0x52ca <Write+0x3a>
		if (data & 0x01) _PORT &= ~_DATA;
		_delay_us(2);	
		data >>=1;
	}
	//out signal
	_PORT  |= _DATA;_delay_us(1); //bring bit hi
    52e6:	8d 9a       	sbi	0x11, 5	; 17
    52e8:	85 e0       	ldi	r24, 0x05	; 5
    52ea:	8a 95       	dec	r24
    52ec:	f1 f7       	brne	.-4      	; 0x52ea <Write+0x5a>
    52ee:	00 00       	nop
	_PORT &= ~_DATA;_delay_us(3); //bring bit lo for 3, end of transfer (last byte)
    52f0:	8d 98       	cbi	0x11, 5	; 17
    52f2:	90 e1       	ldi	r25, 0x10	; 16
    52f4:	9a 95       	dec	r25
    52f6:	f1 f7       	brne	.-4      	; 0x52f4 <Write+0x64>
	_PORT  |= _BOTH;//both hi
    52f8:	81 b3       	in	r24, 0x11	; 17
    52fa:	80 66       	ori	r24, 0x60	; 96
    52fc:	81 bb       	out	0x11, r24	; 17
	_DDR &= ~_BOTH;//in
    52fe:	80 b3       	in	r24, 0x10	; 16
    5300:	8f 79       	andi	r24, 0x9F	; 159
    5302:	80 bb       	out	0x10, r24	; 16
    5304:	2a e1       	ldi	r18, 0x1A	; 26
    5306:	2a 95       	dec	r18
    5308:	f1 f7       	brne	.-4      	; 0x5306 <Write+0x76>
    530a:	00 c0       	rjmp	.+0      	; 0x530c <Write+0x7c>
	_delay_us(5);//breath - neeeded to make this a 5 for 32u4 chips
	return 0;
    530c:	80 e0       	ldi	r24, 0x00	; 0
    530e:	08 95       	ret

00005310 <getBridgeInterface>:
};

Bridge_interface *getBridgeInterface(void)
{
	return &bridge;
    5310:	8a ea       	ldi	r24, 0xAA	; 170
    5312:	91 e0       	ldi	r25, 0x01	; 1
    5314:	08 95       	ret

00005316 <Endpoint_ConfigureEndpoint_Prv>:
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    5316:	98 2f       	mov	r25, r24
    5318:	97 30       	cpi	r25, 0x07	; 7
    531a:	58 f5       	brcc	.+86     	; 0x5372 <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    531c:	90 93 e9 00 	sts	0x00E9, r25
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
    5320:	98 17       	cp	r25, r24
    5322:	39 f0       	breq	.+14     	; 0x5332 <Endpoint_ConfigureEndpoint_Prv+0x1c>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    5324:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    5328:	20 91 ed 00 	lds	r18, 0x00ED
			UEIENXTemp  = UEIENX;
    532c:	50 91 f0 00 	lds	r21, 0x00F0
    5330:	03 c0       	rjmp	.+6      	; 0x5338 <Endpoint_ConfigureEndpoint_Prv+0x22>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
    5332:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
    5334:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
    5336:	50 e0       	ldi	r21, 0x00	; 0
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    5338:	21 ff       	sbrs	r18, 1
    533a:	19 c0       	rjmp	.+50     	; 0x536e <Endpoint_ConfigureEndpoint_Prv+0x58>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    533c:	30 91 eb 00 	lds	r19, 0x00EB
    5340:	3e 7f       	andi	r19, 0xFE	; 254
    5342:	30 93 eb 00 	sts	0x00EB, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    5346:	30 91 ed 00 	lds	r19, 0x00ED
    534a:	3d 7f       	andi	r19, 0xFD	; 253
    534c:	30 93 ed 00 	sts	0x00ED, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    5350:	30 91 eb 00 	lds	r19, 0x00EB
    5354:	31 60       	ori	r19, 0x01	; 1
    5356:	30 93 eb 00 	sts	0x00EB, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    535a:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    535e:	20 93 ed 00 	sts	0x00ED, r18
		UEIENX  = UEIENXTemp;
    5362:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    5366:	20 91 ee 00 	lds	r18, 0x00EE

		if (!(Endpoint_IsConfigured()))
    536a:	27 ff       	sbrs	r18, 7
    536c:	07 c0       	rjmp	.+14     	; 0x537c <Endpoint_ConfigureEndpoint_Prv+0x66>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    536e:	9f 5f       	subi	r25, 0xFF	; 255
    5370:	d3 cf       	rjmp	.-90     	; 0x5318 <Endpoint_ConfigureEndpoint_Prv+0x2>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5372:	8f 70       	andi	r24, 0x0F	; 15
    5374:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
    5378:	81 e0       	ldi	r24, 0x01	; 1
    537a:	08 95       	ret
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
    537c:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    537e:	08 95       	ret

00005380 <USB_Disable>:
	USB_ResetInterface();
}

void USB_Disable(void)
{
	USB_INT_DisableAllInterrupts();
    5380:	17 d0       	rcall	.+46     	; 0x53b0 <USB_INT_DisableAllInterrupts>
    5382:	1e d0       	rcall	.+60     	; 0x53c0 <USB_INT_ClearAllInterrupts>
	USB_INT_ClearAllInterrupts();
    5384:	e0 ee       	ldi	r30, 0xE0	; 224
    5386:	f0 e0       	ldi	r31, 0x00	; 0
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    5388:	80 81       	ld	r24, Z
    538a:	81 60       	ori	r24, 0x01	; 1
    538c:	80 83       	st	Z, r24
    538e:	e8 ed       	ldi	r30, 0xD8	; 216
    5390:	f0 e0       	ldi	r31, 0x00	; 0
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USBCON &= ~(1 << USBE);
    5392:	80 81       	ld	r24, Z
    5394:	8f 77       	andi	r24, 0x7F	; 127
    5396:	80 83       	st	Z, r24
    5398:	19 bc       	out	0x29, r1	; 41
    539a:	a7 ed       	ldi	r26, 0xD7	; 215
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    539c:	b0 e0       	ldi	r27, 0x00	; 0

			static inline void USB_REG_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_Off(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON &= ~(1 << UVREGE);
    539e:	8c 91       	ld	r24, X
    53a0:	8e 7f       	andi	r24, 0xFE	; 254
    53a2:	8c 93       	st	X, r24
    53a4:	80 81       	ld	r24, Z
    53a6:	8f 7e       	andi	r24, 0xEF	; 239
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    53a8:	80 83       	st	Z, r24
    53aa:	10 92 96 03 	sts	0x0396, r1

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
	#endif

	USB_IsInitialized = false;
    53ae:	08 95       	ret

000053b0 <USB_INT_DisableAllInterrupts>:
void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
    53b0:	e8 ed       	ldi	r30, 0xD8	; 216
    53b2:	f0 e0       	ldi	r31, 0x00	; 0
    53b4:	80 81       	ld	r24, Z
    53b6:	8e 7f       	andi	r24, 0xFE	; 254
    53b8:	80 83       	st	Z, r24
	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    53ba:	10 92 e2 00 	sts	0x00E2, r1
    53be:	08 95       	ret

000053c0 <USB_INT_ClearAllInterrupts>:
}

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    53c0:	10 92 da 00 	sts	0x00DA, r1
	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    53c4:	10 92 e1 00 	sts	0x00E1, r1
    53c8:	08 95       	ret

000053ca <__vector_10>:
	#endif
}

ISR(USB_GEN_vect, ISR_BLOCK)
{
    53ca:	1f 92       	push	r1
    53cc:	0f 92       	push	r0
    53ce:	0f b6       	in	r0, 0x3f	; 63
    53d0:	0f 92       	push	r0
    53d2:	11 24       	eor	r1, r1
    53d4:	2f 93       	push	r18
    53d6:	3f 93       	push	r19
    53d8:	4f 93       	push	r20
    53da:	5f 93       	push	r21
    53dc:	6f 93       	push	r22
    53de:	7f 93       	push	r23
    53e0:	8f 93       	push	r24
    53e2:	9f 93       	push	r25
    53e4:	af 93       	push	r26
    53e6:	bf 93       	push	r27
    53e8:	ef 93       	push	r30
    53ea:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    53ec:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    53f0:	82 ff       	sbrs	r24, 2
    53f2:	0a c0       	rjmp	.+20     	; 0x5408 <__vector_10+0x3e>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    53f4:	80 91 e2 00 	lds	r24, 0x00E2
    53f8:	82 ff       	sbrs	r24, 2
    53fa:	06 c0       	rjmp	.+12     	; 0x5408 <__vector_10+0x3e>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    53fc:	80 91 e1 00 	lds	r24, 0x00E1
    5400:	8b 7f       	andi	r24, 0xFB	; 251
    5402:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    5406:	a5 d0       	rcall	.+330    	; 0x5552 <USB_Event_Stub>
    5408:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    540c:	80 ff       	sbrs	r24, 0
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    540e:	1d c0       	rjmp	.+58     	; 0x544a <__vector_10+0x80>
    5410:	80 91 d8 00 	lds	r24, 0x00D8
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    5414:	80 ff       	sbrs	r24, 0
    5416:	19 c0       	rjmp	.+50     	; 0x544a <__vector_10+0x80>
    5418:	80 91 da 00 	lds	r24, 0x00DA
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    541c:	8e 7f       	andi	r24, 0xFE	; 254
    541e:	80 93 da 00 	sts	0x00DA, r24
    5422:	80 91 d9 00 	lds	r24, 0x00D9
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    5426:	80 ff       	sbrs	r24, 0
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    5428:	0c c0       	rjmp	.+24     	; 0x5442 <__vector_10+0x78>
    542a:	80 e1       	ldi	r24, 0x10	; 16

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    542c:	89 bd       	out	0x29, r24	; 41
    542e:	82 e1       	ldi	r24, 0x12	; 18
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    5430:	89 bd       	out	0x29, r24	; 41
    5432:	09 b4       	in	r0, 0x29	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    5434:	00 fe       	sbrs	r0, 0
    5436:	fd cf       	rjmp	.-6      	; 0x5432 <__vector_10+0x68>
    5438:	81 e0       	ldi	r24, 0x01	; 1
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    543a:	80 93 97 03 	sts	0x0397, r24
    543e:	89 d0       	rcall	.+274    	; 0x5552 <USB_Event_Stub>
			EVENT_USB_Device_Connect();
    5440:	04 c0       	rjmp	.+8      	; 0x544a <__vector_10+0x80>
    5442:	19 bc       	out	0x29, r1	; 41
    5444:	10 92 97 03 	sts	0x0397, r1
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    5448:	84 d0       	rcall	.+264    	; 0x5552 <USB_Event_Stub>
    544a:	80 91 e1 00 	lds	r24, 0x00E1
			EVENT_USB_Device_Disconnect();
    544e:	80 ff       	sbrs	r24, 0
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    5450:	18 c0       	rjmp	.+48     	; 0x5482 <__vector_10+0xb8>
    5452:	80 91 e2 00 	lds	r24, 0x00E2
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    5456:	80 ff       	sbrs	r24, 0
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    5458:	14 c0       	rjmp	.+40     	; 0x5482 <__vector_10+0xb8>
    545a:	80 91 e2 00 	lds	r24, 0x00E2
    545e:	8e 7f       	andi	r24, 0xFE	; 254
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    5460:	80 93 e2 00 	sts	0x00E2, r24
    5464:	80 91 e2 00 	lds	r24, 0x00E2
    5468:	80 61       	ori	r24, 0x10	; 16
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    546a:	80 93 e2 00 	sts	0x00E2, r24
    546e:	80 91 d8 00 	lds	r24, 0x00D8
    5472:	80 62       	ori	r24, 0x20	; 32
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    5474:	80 93 d8 00 	sts	0x00D8, r24
    5478:	19 bc       	out	0x29, r1	; 41
    547a:	85 e0       	ldi	r24, 0x05	; 5
    547c:	80 93 97 03 	sts	0x0397, r24

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    5480:	68 d0       	rcall	.+208    	; 0x5552 <USB_Event_Stub>
    5482:	80 91 e1 00 	lds	r24, 0x00E1
		EVENT_USB_Device_Suspend();
    5486:	84 ff       	sbrs	r24, 4
    5488:	2d c0       	rjmp	.+90     	; 0x54e4 <__vector_10+0x11a>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    548a:	80 91 e2 00 	lds	r24, 0x00E2
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    548e:	84 ff       	sbrs	r24, 4
    5490:	29 c0       	rjmp	.+82     	; 0x54e4 <__vector_10+0x11a>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    5492:	80 e1       	ldi	r24, 0x10	; 16
    5494:	89 bd       	out	0x29, r24	; 41
    5496:	82 e1       	ldi	r24, 0x12	; 18
    5498:	89 bd       	out	0x29, r24	; 41

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    549a:	09 b4       	in	r0, 0x29	; 41
    549c:	00 fe       	sbrs	r0, 0
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    549e:	fd cf       	rjmp	.-6      	; 0x549a <__vector_10+0xd0>
    54a0:	80 91 d8 00 	lds	r24, 0x00D8
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    54a4:	8f 7d       	andi	r24, 0xDF	; 223
    54a6:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    54aa:	80 91 e1 00 	lds	r24, 0x00E1
    54ae:	8f 7e       	andi	r24, 0xEF	; 239
    54b0:	80 93 e1 00 	sts	0x00E1, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    54b4:	80 91 e2 00 	lds	r24, 0x00E2
    54b8:	8f 7e       	andi	r24, 0xEF	; 239
    54ba:	80 93 e2 00 	sts	0x00E2, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    54be:	80 91 e2 00 	lds	r24, 0x00E2
    54c2:	81 60       	ori	r24, 0x01	; 1
    54c4:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    54c8:	80 91 93 03 	lds	r24, 0x0393
    54cc:	81 11       	cpse	r24, r1
    54ce:	04 c0       	rjmp	.+8      	; 0x54d8 <__vector_10+0x10e>
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    54d0:	80 91 e3 00 	lds	r24, 0x00E3
    54d4:	87 ff       	sbrs	r24, 7
    54d6:	02 c0       	rjmp	.+4      	; 0x54dc <__vector_10+0x112>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    54d8:	84 e0       	ldi	r24, 0x04	; 4
    54da:	01 c0       	rjmp	.+2      	; 0x54de <__vector_10+0x114>
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    54dc:	81 e0       	ldi	r24, 0x01	; 1
    54de:	80 93 97 03 	sts	0x0397, r24
    54e2:	37 d0       	rcall	.+110    	; 0x5552 <USB_Event_Stub>
    54e4:	80 91 e1 00 	lds	r24, 0x00E1
    54e8:	83 ff       	sbrs	r24, 3

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    54ea:	22 c0       	rjmp	.+68     	; 0x5530 <__vector_10+0x166>
    54ec:	80 91 e2 00 	lds	r24, 0x00E2
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    54f0:	83 ff       	sbrs	r24, 3
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    54f2:	1e c0       	rjmp	.+60     	; 0x5530 <__vector_10+0x166>
    54f4:	80 91 e1 00 	lds	r24, 0x00E1
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    54f8:	87 7f       	andi	r24, 0xF7	; 247
    54fa:	80 93 e1 00 	sts	0x00E1, r24
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    54fe:	82 e0       	ldi	r24, 0x02	; 2
    5500:	80 93 97 03 	sts	0x0397, r24
    5504:	10 92 93 03 	sts	0x0393, r1
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    5508:	80 91 e1 00 	lds	r24, 0x00E1
    550c:	8e 7f       	andi	r24, 0xFE	; 254
		USB_Device_ConfigurationNumber = 0;
    550e:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    5512:	80 91 e2 00 	lds	r24, 0x00E2
    5516:	8e 7f       	andi	r24, 0xFE	; 254
    5518:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    551c:	80 91 e2 00 	lds	r24, 0x00E2
    5520:	80 61       	ori	r24, 0x10	; 16
    5522:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    5526:	42 e3       	ldi	r20, 0x32	; 50
    5528:	60 e0       	ldi	r22, 0x00	; 0
    552a:	80 e0       	ldi	r24, 0x00	; 0
    552c:	f4 de       	rcall	.-536    	; 0x5316 <Endpoint_ConfigureEndpoint_Prv>
    552e:	11 d0       	rcall	.+34     	; 0x5552 <USB_Event_Stub>
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);
			
				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;
			
				return Endpoint_ConfigureEndpoint_Prv(Number,
    5530:	ff 91       	pop	r31
    5532:	ef 91       	pop	r30
    5534:	bf 91       	pop	r27
    5536:	af 91       	pop	r26
    5538:	9f 91       	pop	r25

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    553a:	8f 91       	pop	r24
    553c:	7f 91       	pop	r23
		USB_ResetInterface();

		EVENT_USB_UIDChange();
	}
	#endif
}
    553e:	6f 91       	pop	r22
    5540:	5f 91       	pop	r21
    5542:	4f 91       	pop	r20
    5544:	3f 91       	pop	r19
    5546:	2f 91       	pop	r18
    5548:	0f 90       	pop	r0
    554a:	0f be       	out	0x3f, r0	; 63
    554c:	0f 90       	pop	r0
    554e:	1f 90       	pop	r1
    5550:	18 95       	reti

00005552 <USB_Event_Stub>:
#define  __INCLUDE_FROM_USB_DRIVER
#include "Events.h"

// cppcheck-suppress unusedFunction
void USB_Event_Stub(void)
{
    5552:	08 95       	ret

00005554 <__tablejump2__>:
    5554:	ee 0f       	add	r30, r30
    5556:	ff 1f       	adc	r31, r31

00005558 <__tablejump__>:
    5558:	05 90       	lpm	r0, Z+
    555a:	f4 91       	lpm	r31, Z
    555c:	e0 2d       	mov	r30, r0
    555e:	09 94       	ijmp

00005560 <memcmp>:
    5560:	fb 01       	movw	r30, r22
    5562:	dc 01       	movw	r26, r24
    5564:	04 c0       	rjmp	.+8      	; 0x556e <memcmp+0xe>
    5566:	8d 91       	ld	r24, X+
    5568:	01 90       	ld	r0, Z+
    556a:	80 19       	sub	r24, r0
    556c:	21 f4       	brne	.+8      	; 0x5576 <memcmp+0x16>
    556e:	41 50       	subi	r20, 0x01	; 1
    5570:	50 40       	sbci	r21, 0x00	; 0
    5572:	c8 f7       	brcc	.-14     	; 0x5566 <memcmp+0x6>
    5574:	88 1b       	sub	r24, r24
    5576:	99 0b       	sbc	r25, r25
    5578:	08 95       	ret

0000557a <memcpy>:
    557a:	fb 01       	movw	r30, r22
    557c:	dc 01       	movw	r26, r24
    557e:	02 c0       	rjmp	.+4      	; 0x5584 <memcpy+0xa>
    5580:	01 90       	ld	r0, Z+
    5582:	0d 92       	st	X+, r0
    5584:	41 50       	subi	r20, 0x01	; 1
    5586:	50 40       	sbci	r21, 0x00	; 0
    5588:	d8 f7       	brcc	.-10     	; 0x5580 <memcpy+0x6>
    558a:	08 95       	ret

0000558c <_exit>:
    558c:	f8 94       	cli

0000558e <__stop_program>:
    558e:	ff cf       	rjmp	.-2      	; 0x558e <__stop_program>
